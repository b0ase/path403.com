{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/event-emitter\n *\n * Type-safe event emitter with async support.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Event listener function */\nexport type EventListener<T = unknown> = (data: T) => void | Promise<void>;\n\n/** Listener options */\nexport interface ListenerOptions {\n  once?: boolean;\n  prepend?: boolean;\n}\n\n/** Listener entry */\ninterface ListenerEntry<T = unknown> {\n  listener: EventListener<T>;\n  once: boolean;\n}\n\n/** Emitter options */\nexport interface EmitterOptions {\n  maxListeners?: number;\n  captureRejections?: boolean;\n}\n\n/** Emitter stats */\nexport interface EmitterStats {\n  eventCount: number;\n  listenerCount: number;\n  events: Array<{ name: string; listeners: number }>;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULT_MAX_LISTENERS = 10;\n\n// ============================================================================\n// Event Emitter\n// ============================================================================\n\nexport class EventEmitter<T extends Record<string, unknown> = Record<string, unknown>> {\n  private _listeners: Map<string, ListenerEntry[]> = new Map();\n  private maxListeners: number;\n  private captureRejections: boolean;\n\n  constructor(options?: EmitterOptions) {\n    this.maxListeners = options?.maxListeners ?? DEFAULT_MAX_LISTENERS;\n    this.captureRejections = options?.captureRejections ?? false;\n  }\n\n  // ==========================================================================\n  // Core Methods\n  // ==========================================================================\n\n  on<K extends keyof T & string>(\n    event: K,\n    listener: EventListener<T[K]>,\n    options?: ListenerOptions\n  ): this {\n    return this.addListener(event, listener, { ...options, once: false });\n  }\n\n  once<K extends keyof T & string>(\n    event: K,\n    listener: EventListener<T[K]>\n  ): this {\n    return this.addListener(event, listener, { once: true });\n  }\n\n  off<K extends keyof T & string>(event: K, listener: EventListener<T[K]>): this {\n    return this.removeListener(event, listener);\n  }\n\n  emit<K extends keyof T & string>(event: K, data: T[K]): boolean {\n    const entries = this._listeners.get(event);\n    if (!entries || entries.length === 0) {\n      return false;\n    }\n\n    const toRemove: EventListener[] = [];\n\n    for (const entry of entries) {\n      try {\n        const result = entry.listener(data);\n\n        if (this.captureRejections && result instanceof Promise) {\n          result.catch(err => {\n            this.emit('error' as K, err as T[K]);\n          });\n        }\n      } catch (err) {\n        if (this.captureRejections) {\n          this.emit('error' as K, err as T[K]);\n        } else {\n          throw err;\n        }\n      }\n\n      if (entry.once) {\n        toRemove.push(entry.listener);\n      }\n    }\n\n    for (const listener of toRemove) {\n      this.removeListener(event, listener as EventListener<T[K]>);\n    }\n\n    return true;\n  }\n\n  async emitAsync<K extends keyof T & string>(event: K, data: T[K]): Promise<boolean> {\n    const entries = this._listeners.get(event);\n    if (!entries || entries.length === 0) {\n      return false;\n    }\n\n    const toRemove: EventListener[] = [];\n\n    for (const entry of entries) {\n      try {\n        await entry.listener(data);\n      } catch (err) {\n        if (this.captureRejections) {\n          this.emit('error' as K, err as T[K]);\n        } else {\n          throw err;\n        }\n      }\n\n      if (entry.once) {\n        toRemove.push(entry.listener);\n      }\n    }\n\n    for (const listener of toRemove) {\n      this.removeListener(event, listener as EventListener<T[K]>);\n    }\n\n    return true;\n  }\n\n  async emitParallel<K extends keyof T & string>(event: K, data: T[K]): Promise<boolean> {\n    const entries = this._listeners.get(event);\n    if (!entries || entries.length === 0) {\n      return false;\n    }\n\n    const promises = entries.map(async entry => {\n      try {\n        await entry.listener(data);\n        return { entry, error: null };\n      } catch (err) {\n        return { entry, error: err };\n      }\n    });\n\n    const results = await Promise.all(promises);\n\n    const toRemove: EventListener[] = [];\n    for (const { entry, error } of results) {\n      if (error) {\n        if (this.captureRejections) {\n          this.emit('error' as K, error as T[K]);\n        } else {\n          throw error;\n        }\n      }\n      if (entry.once) {\n        toRemove.push(entry.listener);\n      }\n    }\n\n    for (const listener of toRemove) {\n      this.removeListener(event, listener as EventListener<T[K]>);\n    }\n\n    return true;\n  }\n\n  // ==========================================================================\n  // Listener Management\n  // ==========================================================================\n\n  addListener<K extends keyof T & string>(\n    event: K,\n    listener: EventListener<T[K]>,\n    options?: ListenerOptions\n  ): this {\n    let entries = this._listeners.get(event);\n    if (!entries) {\n      entries = [];\n      this._listeners.set(event, entries);\n    }\n\n    // Check max listeners\n    if (entries.length >= this.maxListeners) {\n      console.warn(\n        `MaxListenersExceededWarning: Possible memory leak detected. ` +\n        `${entries.length + 1} listeners added to event \"${event}\".`\n      );\n    }\n\n    const entry: ListenerEntry = {\n      listener: listener as EventListener,\n      once: options?.once ?? false,\n    };\n\n    if (options?.prepend) {\n      entries.unshift(entry);\n    } else {\n      entries.push(entry);\n    }\n\n    return this;\n  }\n\n  removeListener<K extends keyof T & string>(event: K, listener: EventListener<T[K]>): this {\n    const entries = this._listeners.get(event);\n    if (!entries) return this;\n\n    const index = entries.findIndex(e => e.listener === listener);\n    if (index !== -1) {\n      entries.splice(index, 1);\n    }\n\n    if (entries.length === 0) {\n      this._listeners.delete(event);\n    }\n\n    return this;\n  }\n\n  removeAllListeners(event?: string): this {\n    if (event) {\n      this._listeners.delete(event);\n    } else {\n      this._listeners.clear();\n    }\n    return this;\n  }\n\n  // ==========================================================================\n  // Inspection\n  // ==========================================================================\n\n  listenerCount(event: string): number {\n    return this._listeners.get(event)?.length ?? 0;\n  }\n\n  getListeners(event: string): EventListener[] {\n    return (this._listeners.get(event) ?? []).map(e => e.listener);\n  }\n\n  eventNames(): string[] {\n    return Array.from(this._listeners.keys());\n  }\n\n  getMaxListeners(): number {\n    return this.maxListeners;\n  }\n\n  setMaxListeners(n: number): this {\n    this.maxListeners = n;\n    return this;\n  }\n\n  getStats(): EmitterStats {\n    const events: Array<{ name: string; listeners: number }> = [];\n    let totalListeners = 0;\n\n    for (const [name, entries] of this._listeners) {\n      events.push({ name, listeners: entries.length });\n      totalListeners += entries.length;\n    }\n\n    return {\n      eventCount: this._listeners.size,\n      listenerCount: totalListeners,\n      events,\n    };\n  }\n\n  // ==========================================================================\n  // Promise-based Helpers\n  // ==========================================================================\n\n  waitFor<K extends keyof T & string>(\n    event: K,\n    options?: { timeout?: number }\n  ): Promise<T[K]> {\n    return new Promise((resolve, reject) => {\n      let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n      const listener: EventListener<T[K]> = (data) => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        this.off(event, listener);\n        resolve(data);\n      };\n\n      this.on(event, listener);\n\n      if (options?.timeout) {\n        timeoutId = setTimeout(() => {\n          this.off(event, listener);\n          reject(new Error(`Timeout waiting for event \"${event}\"`));\n        }, options.timeout);\n      }\n    });\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createEventEmitter<T extends Record<string, unknown> = Record<string, unknown>>(\n  options?: EmitterOptions\n): EventEmitter<T> {\n  return new EventEmitter<T>(options);\n}\n\n// ============================================================================\n// Event Bus (Singleton pattern)\n// ============================================================================\n\nexport class EventBus extends EventEmitter<Record<string, unknown>> {\n  private static instances: Map<string, EventBus> = new Map();\n\n  static getInstance(name: string = 'default'): EventBus {\n    let instance = EventBus.instances.get(name);\n    if (!instance) {\n      instance = new EventBus();\n      EventBus.instances.set(name, instance);\n    }\n    return instance;\n  }\n\n  static resetInstance(name: string = 'default'): void {\n    const instance = EventBus.instances.get(name);\n    if (instance) {\n      instance.removeAllListeners();\n      EventBus.instances.delete(name);\n    }\n  }\n\n  static resetAll(): void {\n    for (const instance of EventBus.instances.values()) {\n      instance.removeAllListeners();\n    }\n    EventBus.instances.clear();\n  }\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function once<T>(\n  emitter: EventEmitter<Record<string, T>>,\n  event: string\n): Promise<T> {\n  return new Promise((resolve) => {\n    emitter.once(event, (data: T) => {\n      resolve(data);\n    });\n  });\n}\n\nexport function onceWithTimeout<T>(\n  emitter: EventEmitter<Record<string, T>>,\n  event: string,\n  timeoutMs: number\n): Promise<T> {\n  return Promise.race([\n    once(emitter, event),\n    new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(`Timeout waiting for \"${event}\"`)), timeoutMs);\n    }),\n  ]);\n}\n"],"mappings":"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","names":[]}