{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/object-utils\n *\n * Object utilities: deep clone, merge, pick, omit, diff, and more.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Generic object type */\nexport type PlainObject = Record<string, unknown>;\n\n/** Path type for nested access */\nexport type Path = string | (string | number)[];\n\n/** Diff result */\nexport interface DiffResult {\n  added: PlainObject;\n  removed: PlainObject;\n  changed: PlainObject;\n  unchanged: PlainObject;\n}\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Check if value is a plain object\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (typeof value !== 'object' || value === null) return false;\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n}\n\n/**\n * Check if value is empty (null, undefined, empty string, empty array, empty object)\n */\nexport function isEmpty(value: unknown): boolean {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string') return value.length === 0;\n  if (Array.isArray(value)) return value.length === 0;\n  if (isPlainObject(value)) return Object.keys(value).length === 0;\n  return false;\n}\n\n/**\n * Check if value is not empty\n */\nexport function isNotEmpty<T>(value: T): value is NonNullable<T> {\n  return !isEmpty(value);\n}\n\n// ============================================================================\n// Deep Clone\n// ============================================================================\n\n/**\n * Deep clone an object\n */\nexport function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((item) => deepClone(item)) as T;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime()) as T;\n  }\n\n  if (value instanceof Map) {\n    return new Map(Array.from(value.entries()).map(([k, v]) => [deepClone(k), deepClone(v)])) as T;\n  }\n\n  if (value instanceof Set) {\n    return new Set(Array.from(value).map((item) => deepClone(item))) as T;\n  }\n\n  const result: PlainObject = {};\n  for (const key of Object.keys(value)) {\n    result[key] = deepClone((value as PlainObject)[key]);\n  }\n  return result as T;\n}\n\n/**\n * Shallow clone an object\n */\nexport function shallowClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return [...value] as T;\n  }\n\n  return { ...value };\n}\n\n// ============================================================================\n// Deep Merge\n// ============================================================================\n\n/**\n * Deep merge objects\n */\nexport function deepMerge<T extends PlainObject>(...objects: Partial<T>[]): T {\n  const result: PlainObject = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key of Object.keys(obj)) {\n      const targetValue = result[key];\n      const sourceValue = obj[key];\n\n      if (isPlainObject(targetValue) && isPlainObject(sourceValue)) {\n        result[key] = deepMerge(targetValue, sourceValue);\n      } else if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n        result[key] = [...targetValue, ...sourceValue];\n      } else if (sourceValue !== undefined) {\n        result[key] = deepClone(sourceValue);\n      }\n    }\n  }\n\n  return result as T;\n}\n\n/**\n * Shallow merge objects\n */\nexport function shallowMerge<T extends PlainObject>(...objects: Partial<T>[]): T {\n  return Object.assign({}, ...objects) as T;\n}\n\n// ============================================================================\n// Pick & Omit\n// ============================================================================\n\n/**\n * Pick specified keys from object\n */\nexport function pick<T extends PlainObject, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Omit specified keys from object\n */\nexport function omit<T extends PlainObject, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n  for (const key of keys) {\n    delete result[key];\n  }\n  return result as Omit<T, K>;\n}\n\n/**\n * Pick keys by predicate\n */\nexport function pickBy<T extends PlainObject>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (predicate(value as T[keyof T], key as keyof T)) {\n      (result as PlainObject)[key] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Omit keys by predicate\n */\nexport function omitBy<T extends PlainObject>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  return pickBy(obj, (value, key) => !predicate(value, key));\n}\n\n// ============================================================================\n// Deep Access\n// ============================================================================\n\n/**\n * Get value at path\n */\nexport function get<T = unknown>(obj: PlainObject, path: Path, defaultValue?: T): T | undefined {\n  const keys = typeof path === 'string' ? path.split('.') : path;\n  let result: unknown = obj;\n\n  for (const key of keys) {\n    if (result === null || result === undefined) {\n      return defaultValue;\n    }\n    result = (result as PlainObject)[key];\n  }\n\n  return (result === undefined ? defaultValue : result) as T | undefined;\n}\n\n/**\n * Set value at path\n */\nexport function set<T extends PlainObject>(obj: T, path: Path, value: unknown): T {\n  const keys = typeof path === 'string' ? path.split('.') : path;\n  const result = deepClone(obj);\n  let current: PlainObject = result;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (!(key in current) || !isPlainObject(current[key])) {\n      current[key] = typeof keys[i + 1] === 'number' ? [] : {};\n    }\n    current = current[key] as PlainObject;\n  }\n\n  current[keys[keys.length - 1]] = value;\n  return result;\n}\n\n/**\n * Check if path exists in object\n */\nexport function has(obj: PlainObject, path: Path): boolean {\n  const keys = typeof path === 'string' ? path.split('.') : path;\n  let current: unknown = obj;\n\n  for (const key of keys) {\n    if (current === null || current === undefined) {\n      return false;\n    }\n    if (!(key in (current as PlainObject))) {\n      return false;\n    }\n    current = (current as PlainObject)[key];\n  }\n\n  return true;\n}\n\n/**\n * Delete value at path\n */\nexport function unset<T extends PlainObject>(obj: T, path: Path): T {\n  const keys = typeof path === 'string' ? path.split('.') : path;\n  const result = deepClone(obj);\n  let current: PlainObject = result;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (!(key in current)) {\n      return result;\n    }\n    current = current[key] as PlainObject;\n  }\n\n  delete current[keys[keys.length - 1]];\n  return result;\n}\n\n// ============================================================================\n// Object Transformation\n// ============================================================================\n\n/**\n * Map object values\n */\nexport function mapValues<T extends PlainObject, R>(\n  obj: T,\n  fn: (value: T[keyof T], key: keyof T) => R\n): Record<keyof T, R> {\n  const result = {} as Record<keyof T, R>;\n  for (const [key, value] of Object.entries(obj)) {\n    result[key as keyof T] = fn(value as T[keyof T], key as keyof T);\n  }\n  return result;\n}\n\n/**\n * Map object keys\n */\nexport function mapKeys<T extends PlainObject>(\n  obj: T,\n  fn: (key: keyof T, value: T[keyof T]) => string\n): PlainObject {\n  const result: PlainObject = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = fn(key as keyof T, value as T[keyof T]);\n    result[newKey] = value;\n  }\n  return result;\n}\n\n/**\n * Filter object entries\n */\nexport function filterEntries<T extends PlainObject>(\n  obj: T,\n  predicate: (key: keyof T, value: T[keyof T]) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (predicate(key as keyof T, value as T[keyof T])) {\n      (result as PlainObject)[key] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Flatten nested object\n */\nexport function flatten(obj: PlainObject, delimiter: string = '.'): PlainObject {\n  const result: PlainObject = {};\n\n  function recurse(current: PlainObject, prefix: string): void {\n    for (const [key, value] of Object.entries(current)) {\n      const newKey = prefix ? `${prefix}${delimiter}${key}` : key;\n      if (isPlainObject(value)) {\n        recurse(value, newKey);\n      } else {\n        result[newKey] = value;\n      }\n    }\n  }\n\n  recurse(obj, '');\n  return result;\n}\n\n/**\n * Unflatten object\n */\nexport function unflatten(obj: PlainObject, delimiter: string = '.'): PlainObject {\n  const result: PlainObject = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const keys = key.split(delimiter);\n    let current = result;\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      const k = keys[i];\n      if (!(k in current)) {\n        current[k] = {};\n      }\n      current = current[k] as PlainObject;\n    }\n\n    current[keys[keys.length - 1]] = value;\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Comparison\n// ============================================================================\n\n/**\n * Deep equality check\n */\nexport function deepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n\n  if (typeof a !== typeof b) return false;\n\n  if (a === null || b === null) return a === b;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    return a.every((item, index) => deepEqual(item, b[index]));\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a as PlainObject);\n    const keysB = Object.keys(b as PlainObject);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) =>\n      deepEqual((a as PlainObject)[key], (b as PlainObject)[key])\n    );\n  }\n\n  return false;\n}\n\n/**\n * Get diff between two objects\n */\nexport function diff(a: PlainObject, b: PlainObject): DiffResult {\n  const added: PlainObject = {};\n  const removed: PlainObject = {};\n  const changed: PlainObject = {};\n  const unchanged: PlainObject = {};\n\n  const allKeys = new Set([...Object.keys(a), ...Object.keys(b)]);\n\n  for (const key of allKeys) {\n    const inA = key in a;\n    const inB = key in b;\n\n    if (inA && !inB) {\n      removed[key] = a[key];\n    } else if (!inA && inB) {\n      added[key] = b[key];\n    } else if (deepEqual(a[key], b[key])) {\n      unchanged[key] = a[key];\n    } else {\n      changed[key] = { from: a[key], to: b[key] };\n    }\n  }\n\n  return { added, removed, changed, unchanged };\n}\n\n// ============================================================================\n// Object Creation\n// ============================================================================\n\n/**\n * Create object from entries\n */\nexport function fromEntries<K extends string, V>(entries: [K, V][]): Record<K, V> {\n  return Object.fromEntries(entries) as Record<K, V>;\n}\n\n/**\n * Create object from keys with default value\n */\nexport function fromKeys<K extends string, V>(keys: K[], value: V): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const key of keys) {\n    result[key] = value;\n  }\n  return result;\n}\n\n/**\n * Create object from keys with value factory\n */\nexport function fromKeysBy<K extends string, V>(keys: K[], fn: (key: K) => V): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const key of keys) {\n    result[key] = fn(key);\n  }\n  return result;\n}\n\n/**\n * Invert object keys and values\n */\nexport function invert<T extends PlainObject>(obj: T): PlainObject {\n  const result: PlainObject = {};\n  for (const [key, value] of Object.entries(obj)) {\n    result[String(value)] = key;\n  }\n  return result;\n}\n\n// ============================================================================\n// Null/Undefined Handling\n// ============================================================================\n\n/**\n * Remove null and undefined values\n */\nexport function compact<T extends PlainObject>(obj: T): Partial<T> {\n  return pickBy(obj, (value) => value !== null && value !== undefined) as Partial<T>;\n}\n\n/**\n * Remove falsy values\n */\nexport function compactFalsy<T extends PlainObject>(obj: T): Partial<T> {\n  return pickBy(obj, (value) => Boolean(value)) as Partial<T>;\n}\n\n/**\n * Set default values for undefined keys\n */\nexport function defaults<T extends PlainObject>(obj: Partial<T>, defaultValues: T): T {\n  const result = { ...defaultValues };\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      (result as PlainObject)[key] = value;\n    }\n  }\n  return result;\n}\n\n// ============================================================================\n// Iteration\n// ============================================================================\n\n/**\n * For each entry in object\n */\nexport function forEachEntry<T extends PlainObject>(\n  obj: T,\n  fn: (key: keyof T, value: T[keyof T]) => void\n): void {\n  for (const [key, value] of Object.entries(obj)) {\n    fn(key as keyof T, value as T[keyof T]);\n  }\n}\n\n/**\n * Get entries as array\n */\nexport function entries<T extends PlainObject>(obj: T): Array<[keyof T, T[keyof T]]> {\n  return Object.entries(obj) as Array<[keyof T, T[keyof T]]>;\n}\n\n/**\n * Get keys as array\n */\nexport function keys<T extends PlainObject>(obj: T): Array<keyof T> {\n  return Object.keys(obj) as Array<keyof T>;\n}\n\n/**\n * Get values as array\n */\nexport function values<T extends PlainObject>(obj: T): Array<T[keyof T]> {\n  return Object.values(obj) as Array<T[keyof T]>;\n}\n"],"mappings":"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","names":["keys","entries"]}