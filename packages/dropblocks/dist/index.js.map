{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/dropblocks\n *\n * Decentralized storage management with multi-provider support.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Storage provider type */\nexport type StorageProvider =\n  | 'ipfs'\n  | 'arweave'\n  | 'bsv'\n  | 'filecoin'\n  | 's3'\n  | 'r2'\n  | 'local'\n  | 'ordinals';\n\n/** File status */\nexport type FileStatus =\n  | 'pending'\n  | 'uploading'\n  | 'pinned'\n  | 'replicated'\n  | 'failed'\n  | 'deleted';\n\n/** Content identifier type */\nexport type ContentIdType = 'cid' | 'txid' | 'inscription' | 'url' | 'hash';\n\n/** Storage file metadata */\nexport interface StorageFile {\n  id: string;\n  name: string;\n  mimeType: string;\n  size: number;\n  contentId: string;\n  contentIdType: ContentIdType;\n  provider: StorageProvider;\n  status: FileStatus;\n  url?: string;\n  gateway?: string;\n  checksum: string;\n  createdAt: Date;\n  updatedAt: Date;\n  expiresAt?: Date;\n  metadata?: Record<string, unknown>;\n  replicas?: FileReplica[];\n}\n\n/** File replica on another provider */\nexport interface FileReplica {\n  provider: StorageProvider;\n  contentId: string;\n  contentIdType: ContentIdType;\n  url?: string;\n  status: FileStatus;\n  syncedAt: Date;\n}\n\n/** Upload options */\nexport interface UploadOptions {\n  name?: string;\n  mimeType?: string;\n  encrypt?: boolean;\n  encryptionKey?: string;\n  replicate?: StorageProvider[];\n  pin?: boolean;\n  expiresAt?: Date;\n  metadata?: Record<string, unknown>;\n  onProgress?: (progress: UploadProgress) => void;\n}\n\n/** Upload progress */\nexport interface UploadProgress {\n  bytesUploaded: number;\n  totalBytes: number;\n  percentage: number;\n  provider: StorageProvider;\n}\n\n/** Provider configuration */\nexport interface ProviderConfig {\n  provider: StorageProvider;\n  endpoint?: string;\n  apiKey?: string;\n  secretKey?: string;\n  bucket?: string;\n  gateway?: string;\n  options?: Record<string, unknown>;\n}\n\n/** Storage stats */\nexport interface StorageStats {\n  totalFiles: number;\n  totalSize: number;\n  byProvider: Record<StorageProvider, { files: number; size: number }>;\n  byStatus: Record<FileStatus, number>;\n}\n\n/** Pin status */\nexport interface PinStatus {\n  isPinned: boolean;\n  provider: StorageProvider;\n  contentId: string;\n  pinnedAt?: Date;\n  expiresAt?: Date;\n}\n\n// ============================================================================\n// Provider Adapters (Interfaces)\n// ============================================================================\n\n/** Storage provider adapter interface */\nexport interface StorageAdapter {\n  provider: StorageProvider;\n\n  upload(\n    data: Uint8Array | string,\n    options?: UploadOptions\n  ): Promise<StorageFile>;\n\n  download(contentId: string): Promise<Uint8Array>;\n\n  delete(contentId: string): Promise<boolean>;\n\n  getUrl(contentId: string): string;\n\n  pin(contentId: string): Promise<PinStatus>;\n\n  unpin(contentId: string): Promise<boolean>;\n\n  getStatus(contentId: string): Promise<FileStatus>;\n}\n\n// ============================================================================\n// IPFS Adapter\n// ============================================================================\n\nexport class IPFSAdapter implements StorageAdapter {\n  provider: StorageProvider = 'ipfs';\n  private gateway: string;\n  private apiEndpoint?: string;\n  private apiKey?: string;\n\n  constructor(config: ProviderConfig) {\n    this.gateway = config.gateway || 'https://ipfs.io/ipfs/';\n    this.apiEndpoint = config.endpoint;\n    this.apiKey = config.apiKey;\n  }\n\n  async upload(\n    data: Uint8Array | string,\n    options?: UploadOptions\n  ): Promise<StorageFile> {\n    // In real implementation, this would use IPFS HTTP API or Pinata/Infura\n    const content = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n    const checksum = await this.computeChecksum(content);\n\n    // Simulate CID generation (real impl would use ipfs-only-hash or actual IPFS)\n    const cid = `Qm${this.generateRandomString(44)}`;\n\n    return {\n      id: this.generateId(),\n      name: options?.name || 'untitled',\n      mimeType: options?.mimeType || 'application/octet-stream',\n      size: content.length,\n      contentId: cid,\n      contentIdType: 'cid',\n      provider: 'ipfs',\n      status: 'pinned',\n      url: `${this.gateway}${cid}`,\n      gateway: this.gateway,\n      checksum,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      expiresAt: options?.expiresAt,\n      metadata: options?.metadata,\n    };\n  }\n\n  async download(contentId: string): Promise<Uint8Array> {\n    const response = await fetch(`${this.gateway}${contentId}`);\n    if (!response.ok) {\n      throw new Error(`Failed to download from IPFS: ${response.statusText}`);\n    }\n    return new Uint8Array(await response.arrayBuffer());\n  }\n\n  async delete(_contentId: string): Promise<boolean> {\n    // IPFS doesn't support deletion, only unpinning\n    return false;\n  }\n\n  getUrl(contentId: string): string {\n    return `${this.gateway}${contentId}`;\n  }\n\n  async pin(contentId: string): Promise<PinStatus> {\n    // Would call pinning service API\n    return {\n      isPinned: true,\n      provider: 'ipfs',\n      contentId,\n      pinnedAt: new Date(),\n    };\n  }\n\n  async unpin(_contentId: string): Promise<boolean> {\n    // Would call pinning service API\n    return true;\n  }\n\n  async getStatus(_contentId: string): Promise<FileStatus> {\n    return 'pinned';\n  }\n\n  private generateId(): string {\n    return `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateRandomString(length: number): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n  }\n\n  private async computeChecksum(data: Uint8Array): Promise<string> {\n    // Simple hash for demo - real impl would use crypto.subtle\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      hash = ((hash << 5) - hash) + data[i];\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n}\n\n// ============================================================================\n// Arweave Adapter\n// ============================================================================\n\nexport class ArweaveAdapter implements StorageAdapter {\n  provider: StorageProvider = 'arweave';\n  private gateway: string;\n  private apiEndpoint: string;\n\n  constructor(config: ProviderConfig) {\n    this.gateway = config.gateway || 'https://arweave.net/';\n    this.apiEndpoint = config.endpoint || 'https://arweave.net';\n  }\n\n  async upload(\n    data: Uint8Array | string,\n    options?: UploadOptions\n  ): Promise<StorageFile> {\n    const content = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n    const checksum = await this.computeChecksum(content);\n\n    // Simulate Arweave TXID (43 chars base64url)\n    const txid = this.generateRandomString(43);\n\n    return {\n      id: this.generateId(),\n      name: options?.name || 'untitled',\n      mimeType: options?.mimeType || 'application/octet-stream',\n      size: content.length,\n      contentId: txid,\n      contentIdType: 'txid',\n      provider: 'arweave',\n      status: 'pinned',\n      url: `${this.gateway}${txid}`,\n      gateway: this.gateway,\n      checksum,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      metadata: options?.metadata,\n    };\n  }\n\n  async download(contentId: string): Promise<Uint8Array> {\n    const response = await fetch(`${this.gateway}${contentId}`);\n    if (!response.ok) {\n      throw new Error(`Failed to download from Arweave: ${response.statusText}`);\n    }\n    return new Uint8Array(await response.arrayBuffer());\n  }\n\n  async delete(_contentId: string): Promise<boolean> {\n    // Arweave is permanent - cannot delete\n    return false;\n  }\n\n  getUrl(contentId: string): string {\n    return `${this.gateway}${contentId}`;\n  }\n\n  async pin(contentId: string): Promise<PinStatus> {\n    // Arweave is permanent - always \"pinned\"\n    return {\n      isPinned: true,\n      provider: 'arweave',\n      contentId,\n      pinnedAt: new Date(),\n    };\n  }\n\n  async unpin(_contentId: string): Promise<boolean> {\n    // Cannot unpin from Arweave\n    return false;\n  }\n\n  async getStatus(_contentId: string): Promise<FileStatus> {\n    return 'pinned';\n  }\n\n  private generateId(): string {\n    return `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateRandomString(length: number): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n  }\n\n  private async computeChecksum(data: Uint8Array): Promise<string> {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      hash = ((hash << 5) - hash) + data[i];\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n}\n\n// ============================================================================\n// BSV Adapter\n// ============================================================================\n\nexport class BSVAdapter implements StorageAdapter {\n  provider: StorageProvider = 'bsv';\n  private network: 'mainnet' | 'testnet';\n\n  constructor(config: ProviderConfig) {\n    this.network = config.options?.network as 'mainnet' | 'testnet' || 'mainnet';\n  }\n\n  async upload(\n    data: Uint8Array | string,\n    options?: UploadOptions\n  ): Promise<StorageFile> {\n    const content = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n    const checksum = await this.computeChecksum(content);\n\n    // Simulate BSV TXID (64 char hex)\n    const txid = this.generateTxid();\n\n    return {\n      id: this.generateId(),\n      name: options?.name || 'untitled',\n      mimeType: options?.mimeType || 'application/octet-stream',\n      size: content.length,\n      contentId: txid,\n      contentIdType: 'txid',\n      provider: 'bsv',\n      status: 'pinned',\n      url: this.getUrl(txid),\n      checksum,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      metadata: options?.metadata,\n    };\n  }\n\n  async download(contentId: string): Promise<Uint8Array> {\n    const url = `https://api.whatsonchain.com/v1/bsv/${this.network}/tx/${contentId}/hex`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to download from BSV: ${response.statusText}`);\n    }\n    const hex = await response.text();\n    // Parse OP_RETURN data from transaction\n    return this.hexToBytes(hex);\n  }\n\n  async delete(_contentId: string): Promise<boolean> {\n    // Blockchain is permanent\n    return false;\n  }\n\n  getUrl(contentId: string): string {\n    return `https://whatsonchain.com/tx/${contentId}`;\n  }\n\n  async pin(contentId: string): Promise<PinStatus> {\n    return {\n      isPinned: true,\n      provider: 'bsv',\n      contentId,\n      pinnedAt: new Date(),\n    };\n  }\n\n  async unpin(_contentId: string): Promise<boolean> {\n    return false;\n  }\n\n  async getStatus(_contentId: string): Promise<FileStatus> {\n    return 'pinned';\n  }\n\n  private generateId(): string {\n    return `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateTxid(): string {\n    const chars = '0123456789abcdef';\n    let result = '';\n    for (let i = 0; i < 64; i++) {\n      result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n  }\n\n  private async computeChecksum(data: Uint8Array): Promise<string> {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      hash = ((hash << 5) - hash) + data[i];\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n\n  private hexToBytes(hex: string): Uint8Array {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);\n    }\n    return bytes;\n  }\n}\n\n// ============================================================================\n// DropBlocks Manager\n// ============================================================================\n\nexport class DropBlocksManager {\n  private adapters: Map<StorageProvider, StorageAdapter> = new Map();\n  private files: Map<string, StorageFile> = new Map();\n  private defaultProvider: StorageProvider;\n\n  constructor(defaultProvider: StorageProvider = 'ipfs') {\n    this.defaultProvider = defaultProvider;\n  }\n\n  registerAdapter(adapter: StorageAdapter): void {\n    this.adapters.set(adapter.provider, adapter);\n  }\n\n  setDefaultProvider(provider: StorageProvider): void {\n    if (!this.adapters.has(provider)) {\n      throw new Error(`No adapter registered for provider: ${provider}`);\n    }\n    this.defaultProvider = provider;\n  }\n\n  private getAdapter(provider: StorageProvider): StorageAdapter {\n    const adapter = this.adapters.get(provider);\n    if (!adapter) {\n      throw new Error(`No adapter registered for provider: ${provider}`);\n    }\n    return adapter;\n  }\n\n  async upload(\n    data: Uint8Array | string,\n    options?: UploadOptions & { provider?: StorageProvider }\n  ): Promise<StorageFile> {\n    const provider = options?.provider || this.defaultProvider;\n    const adapter = this.getAdapter(provider);\n\n    const file = await adapter.upload(data, options);\n    this.files.set(file.id, file);\n\n    // Handle replication\n    if (options?.replicate && options.replicate.length > 0) {\n      const replicas: FileReplica[] = [];\n\n      for (const replicaProvider of options.replicate) {\n        if (replicaProvider === provider) continue;\n\n        try {\n          const replicaAdapter = this.getAdapter(replicaProvider);\n          const replicaFile = await replicaAdapter.upload(data, options);\n\n          replicas.push({\n            provider: replicaProvider,\n            contentId: replicaFile.contentId,\n            contentIdType: replicaFile.contentIdType,\n            url: replicaFile.url,\n            status: 'replicated',\n            syncedAt: new Date(),\n          });\n        } catch (error) {\n          replicas.push({\n            provider: replicaProvider,\n            contentId: '',\n            contentIdType: 'hash',\n            status: 'failed',\n            syncedAt: new Date(),\n          });\n        }\n      }\n\n      file.replicas = replicas;\n      file.status = 'replicated';\n      this.files.set(file.id, file);\n    }\n\n    return file;\n  }\n\n  async download(\n    fileIdOrContentId: string,\n    provider?: StorageProvider\n  ): Promise<Uint8Array> {\n    // Try to find by file ID first\n    const file = this.files.get(fileIdOrContentId);\n\n    if (file) {\n      const adapter = this.getAdapter(provider || file.provider);\n      return adapter.download(file.contentId);\n    }\n\n    // Otherwise treat as content ID\n    if (!provider) {\n      throw new Error('Provider required when downloading by content ID');\n    }\n\n    const adapter = this.getAdapter(provider);\n    return adapter.download(fileIdOrContentId);\n  }\n\n  async delete(fileId: string): Promise<boolean> {\n    const file = this.files.get(fileId);\n    if (!file) return false;\n\n    const adapter = this.getAdapter(file.provider);\n    await adapter.delete(file.contentId);\n\n    file.status = 'deleted';\n    file.updatedAt = new Date();\n    this.files.set(fileId, file);\n\n    return true;\n  }\n\n  getFile(fileId: string): StorageFile | undefined {\n    return this.files.get(fileId);\n  }\n\n  getFileByContentId(contentId: string): StorageFile | undefined {\n    for (const file of this.files.values()) {\n      if (file.contentId === contentId) return file;\n    }\n    return undefined;\n  }\n\n  getUrl(fileId: string): string | undefined {\n    const file = this.files.get(fileId);\n    if (!file) return undefined;\n\n    const adapter = this.getAdapter(file.provider);\n    return adapter.getUrl(file.contentId);\n  }\n\n  async pin(fileId: string): Promise<PinStatus | undefined> {\n    const file = this.files.get(fileId);\n    if (!file) return undefined;\n\n    const adapter = this.getAdapter(file.provider);\n    return adapter.pin(file.contentId);\n  }\n\n  async unpin(fileId: string): Promise<boolean> {\n    const file = this.files.get(fileId);\n    if (!file) return false;\n\n    const adapter = this.getAdapter(file.provider);\n    return adapter.unpin(file.contentId);\n  }\n\n  listFiles(filter?: {\n    provider?: StorageProvider;\n    status?: FileStatus;\n    mimeType?: string;\n  }): StorageFile[] {\n    let files = Array.from(this.files.values());\n\n    if (filter?.provider) {\n      files = files.filter(f => f.provider === filter.provider);\n    }\n    if (filter?.status) {\n      files = files.filter(f => f.status === filter.status);\n    }\n    if (filter?.mimeType) {\n      files = files.filter(f => f.mimeType === filter.mimeType);\n    }\n\n    return files;\n  }\n\n  getStats(): StorageStats {\n    const files = Array.from(this.files.values());\n\n    const byProvider: Record<string, { files: number; size: number }> = {};\n    const byStatus: Record<string, number> = {};\n\n    let totalSize = 0;\n\n    for (const file of files) {\n      totalSize += file.size;\n\n      if (!byProvider[file.provider]) {\n        byProvider[file.provider] = { files: 0, size: 0 };\n      }\n      byProvider[file.provider].files++;\n      byProvider[file.provider].size += file.size;\n\n      byStatus[file.status] = (byStatus[file.status] || 0) + 1;\n    }\n\n    return {\n      totalFiles: files.length,\n      totalSize,\n      byProvider: byProvider as StorageStats['byProvider'],\n      byStatus: byStatus as StorageStats['byStatus'],\n    };\n  }\n\n  async replicate(\n    fileId: string,\n    targetProviders: StorageProvider[]\n  ): Promise<FileReplica[]> {\n    const file = this.files.get(fileId);\n    if (!file) {\n      throw new Error(`File not found: ${fileId}`);\n    }\n\n    // Download from original\n    const data = await this.download(fileId);\n\n    const replicas: FileReplica[] = file.replicas || [];\n\n    for (const provider of targetProviders) {\n      if (provider === file.provider) continue;\n\n      // Check if already replicated\n      const existingReplica = replicas.find(r => r.provider === provider);\n      if (existingReplica && existingReplica.status === 'replicated') continue;\n\n      try {\n        const adapter = this.getAdapter(provider);\n        const replicaFile = await adapter.upload(data, {\n          name: file.name,\n          mimeType: file.mimeType,\n          metadata: file.metadata,\n        });\n\n        const replicaIndex = replicas.findIndex(r => r.provider === provider);\n        const replica: FileReplica = {\n          provider,\n          contentId: replicaFile.contentId,\n          contentIdType: replicaFile.contentIdType,\n          url: replicaFile.url,\n          status: 'replicated',\n          syncedAt: new Date(),\n        };\n\n        if (replicaIndex >= 0) {\n          replicas[replicaIndex] = replica;\n        } else {\n          replicas.push(replica);\n        }\n      } catch (error) {\n        const replica: FileReplica = {\n          provider,\n          contentId: '',\n          contentIdType: 'hash',\n          status: 'failed',\n          syncedAt: new Date(),\n        };\n        replicas.push(replica);\n      }\n    }\n\n    file.replicas = replicas;\n    file.status = 'replicated';\n    file.updatedAt = new Date();\n    this.files.set(fileId, file);\n\n    return replicas;\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createDropBlocks(\n  defaultProvider: StorageProvider = 'ipfs'\n): DropBlocksManager {\n  return new DropBlocksManager(defaultProvider);\n}\n\nexport function createIPFSAdapter(config: Partial<ProviderConfig> = {}): IPFSAdapter {\n  return new IPFSAdapter({ provider: 'ipfs', ...config });\n}\n\nexport function createArweaveAdapter(config: Partial<ProviderConfig> = {}): ArweaveAdapter {\n  return new ArweaveAdapter({ provider: 'arweave', ...config });\n}\n\nexport function createBSVAdapter(config: Partial<ProviderConfig> = {}): BSVAdapter {\n  return new BSVAdapter({ provider: 'bsv', ...config });\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function formatFileSize(bytes: number): string {\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let unitIndex = 0;\n  let size = bytes;\n\n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n\n  return `${size.toFixed(2)} ${units[unitIndex]}`;\n}\n\nexport function getMimeType(filename: string): string {\n  const ext = filename.split('.').pop()?.toLowerCase();\n\n  const mimeTypes: Record<string, string> = {\n    // Images\n    jpg: 'image/jpeg',\n    jpeg: 'image/jpeg',\n    png: 'image/png',\n    gif: 'image/gif',\n    webp: 'image/webp',\n    svg: 'image/svg+xml',\n    // Documents\n    pdf: 'application/pdf',\n    doc: 'application/msword',\n    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    // Data\n    json: 'application/json',\n    xml: 'application/xml',\n    csv: 'text/csv',\n    // Code\n    js: 'application/javascript',\n    ts: 'application/typescript',\n    html: 'text/html',\n    css: 'text/css',\n    // Media\n    mp3: 'audio/mpeg',\n    mp4: 'video/mp4',\n    webm: 'video/webm',\n    // Archives\n    zip: 'application/zip',\n    tar: 'application/x-tar',\n    gz: 'application/gzip',\n  };\n\n  return mimeTypes[ext || ''] || 'application/octet-stream';\n}\n\nexport function isIPFSCid(str: string): boolean {\n  return str.startsWith('Qm') || str.startsWith('bafy');\n}\n\nexport function isArweaveTxid(str: string): boolean {\n  return /^[a-zA-Z0-9_-]{43}$/.test(str);\n}\n\nexport function isBSVTxid(str: string): boolean {\n  return /^[a-fA-F0-9]{64}$/.test(str);\n}\n\nexport function detectProvider(contentId: string): StorageProvider | undefined {\n  if (isIPFSCid(contentId)) return 'ipfs';\n  if (isArweaveTxid(contentId)) return 'arweave';\n  if (isBSVTxid(contentId)) return 'bsv';\n  return undefined;\n}\n"],"mappings":"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","names":["adapter"]}