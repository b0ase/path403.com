{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/market-table\n *\n * Trading interface types and utilities for token markets.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Order side */\nexport type OrderSide = 'buy' | 'sell';\n\n/** Order type */\nexport type OrderType = 'market' | 'limit' | 'stop' | 'stop_limit';\n\n/** Order status */\nexport type OrderStatus =\n  | 'pending'\n  | 'open'\n  | 'partial'\n  | 'filled'\n  | 'cancelled'\n  | 'expired';\n\n/** Time in force */\nexport type TimeInForce = 'gtc' | 'ioc' | 'fok' | 'day';\n\n/** Trade status */\nexport type TradeStatus = 'pending' | 'settled' | 'failed';\n\n/** Market status */\nexport type MarketStatus = 'active' | 'paused' | 'closed';\n\n/** Token pair */\nexport interface TokenPair {\n  id: string;\n  baseToken: TokenInfo;\n  quoteToken: TokenInfo;\n  status: MarketStatus;\n  minOrderSize: bigint;\n  maxOrderSize: bigint;\n  tickSize: bigint;\n  makerFee: number;\n  takerFee: number;\n}\n\n/** Token info */\nexport interface TokenInfo {\n  id: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  contractAddress?: string;\n  iconUrl?: string;\n}\n\n/** Order */\nexport interface Order {\n  id: string;\n  pairId: string;\n  userId: string;\n  side: OrderSide;\n  type: OrderType;\n  status: OrderStatus;\n  price: bigint;\n  amount: bigint;\n  filled: bigint;\n  remaining: bigint;\n  avgFillPrice?: bigint;\n  timeInForce: TimeInForce;\n  stopPrice?: bigint;\n  createdAt: Date;\n  updatedAt: Date;\n  expiresAt?: Date;\n}\n\n/** Trade */\nexport interface Trade {\n  id: string;\n  pairId: string;\n  buyOrderId: string;\n  sellOrderId: string;\n  buyerId: string;\n  sellerId: string;\n  price: bigint;\n  amount: bigint;\n  buyerFee: bigint;\n  sellerFee: bigint;\n  status: TradeStatus;\n  txid?: string;\n  createdAt: Date;\n  settledAt?: Date;\n}\n\n/** Order book level */\nexport interface OrderBookLevel {\n  price: bigint;\n  amount: bigint;\n  orderCount: number;\n}\n\n/** Order book */\nexport interface OrderBook {\n  pairId: string;\n  bids: OrderBookLevel[];\n  asks: OrderBookLevel[];\n  spread: bigint;\n  spreadPercent: number;\n  lastUpdated: Date;\n}\n\n/** Market ticker */\nexport interface MarketTicker {\n  pairId: string;\n  lastPrice: bigint;\n  priceChange24h: bigint;\n  priceChangePercent24h: number;\n  high24h: bigint;\n  low24h: bigint;\n  volume24h: bigint;\n  quoteVolume24h: bigint;\n  openPrice24h: bigint;\n  bestBid: bigint;\n  bestAsk: bigint;\n  lastUpdated: Date;\n}\n\n/** Candlestick (OHLCV) */\nexport interface Candlestick {\n  timestamp: Date;\n  open: bigint;\n  high: bigint;\n  low: bigint;\n  close: bigint;\n  volume: bigint;\n}\n\n/** Time interval */\nexport type TimeInterval = '1m' | '5m' | '15m' | '1h' | '4h' | '1d' | '1w';\n\n/** Market stats */\nexport interface MarketStats {\n  pairId: string;\n  totalTrades: number;\n  totalVolume: bigint;\n  avgTradeSize: bigint;\n  makers: number;\n  takers: number;\n}\n\n/** User portfolio */\nexport interface UserPortfolio {\n  userId: string;\n  balances: TokenBalance[];\n  openOrders: Order[];\n  totalValueQuote: bigint;\n}\n\n/** Token balance */\nexport interface TokenBalance {\n  tokenId: string;\n  symbol: string;\n  available: bigint;\n  locked: bigint;\n  total: bigint;\n  valueInQuote?: bigint;\n}\n\n/** Create order input */\nexport interface CreateOrderInput {\n  pairId: string;\n  side: OrderSide;\n  type: OrderType;\n  price?: bigint;\n  amount: bigint;\n  timeInForce?: TimeInForce;\n  stopPrice?: bigint;\n}\n\n// ============================================================================\n// Market Manager\n// ============================================================================\n\nexport class MarketManager {\n  private pairs: Map<string, TokenPair> = new Map();\n  private orders: Map<string, Order> = new Map();\n  private trades: Trade[] = [];\n  private orderBooks: Map<string, OrderBook> = new Map();\n  private tickers: Map<string, MarketTicker> = new Map();\n  private matchCallback?: (buyOrder: Order, sellOrder: Order, amount: bigint, price: bigint) => Promise<Trade>;\n\n  // ==========================================================================\n  // Pair Management\n  // ==========================================================================\n\n  registerPair(pair: TokenPair): void {\n    this.pairs.set(pair.id, pair);\n    this.initializeOrderBook(pair.id);\n    this.initializeTicker(pair.id);\n  }\n\n  getPair(pairId: string): TokenPair | undefined {\n    return this.pairs.get(pairId);\n  }\n\n  getAllPairs(): TokenPair[] {\n    return Array.from(this.pairs.values());\n  }\n\n  getActivePairs(): TokenPair[] {\n    return Array.from(this.pairs.values()).filter(p => p.status === 'active');\n  }\n\n  // ==========================================================================\n  // Order Management\n  // ==========================================================================\n\n  async createOrder(input: CreateOrderInput, userId: string): Promise<Order> {\n    const pair = this.pairs.get(input.pairId);\n    if (!pair) throw new Error('Pair not found');\n    if (pair.status !== 'active') throw new Error('Market is not active');\n\n    // Validate order\n    this.validateOrder(input, pair);\n\n    const order: Order = {\n      id: this.generateId('order'),\n      pairId: input.pairId,\n      userId,\n      side: input.side,\n      type: input.type,\n      status: 'pending',\n      price: input.price || BigInt(0),\n      amount: input.amount,\n      filled: BigInt(0),\n      remaining: input.amount,\n      timeInForce: input.timeInForce || 'gtc',\n      stopPrice: input.stopPrice,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.orders.set(order.id, order);\n\n    // Try to match immediately for market orders\n    if (input.type === 'market' || input.type === 'limit') {\n      await this.matchOrder(order);\n    }\n\n    // Add to order book if not fully filled\n    if (order.remaining > BigInt(0) && order.status !== 'filled') {\n      order.status = 'open';\n      this.addToOrderBook(order);\n    }\n\n    return order;\n  }\n\n  cancelOrder(orderId: string, userId: string): Order {\n    const order = this.orders.get(orderId);\n    if (!order) throw new Error('Order not found');\n    if (order.userId !== userId) throw new Error('Not your order');\n    if (order.status !== 'open' && order.status !== 'partial') {\n      throw new Error('Order cannot be cancelled');\n    }\n\n    order.status = 'cancelled';\n    order.updatedAt = new Date();\n    this.removeFromOrderBook(order);\n\n    return order;\n  }\n\n  getOrder(orderId: string): Order | undefined {\n    return this.orders.get(orderId);\n  }\n\n  getUserOrders(userId: string, pairId?: string): Order[] {\n    return Array.from(this.orders.values()).filter(o => {\n      if (o.userId !== userId) return false;\n      if (pairId && o.pairId !== pairId) return false;\n      return true;\n    });\n  }\n\n  getOpenOrders(userId: string, pairId?: string): Order[] {\n    return this.getUserOrders(userId, pairId).filter(\n      o => o.status === 'open' || o.status === 'partial'\n    );\n  }\n\n  // ==========================================================================\n  // Order Matching\n  // ==========================================================================\n\n  setMatchCallback(callback: (buyOrder: Order, sellOrder: Order, amount: bigint, price: bigint) => Promise<Trade>): void {\n    this.matchCallback = callback;\n  }\n\n  private async matchOrder(order: Order): Promise<void> {\n    const orderBook = this.orderBooks.get(order.pairId);\n    if (!orderBook) return;\n\n    const oppositeBook = order.side === 'buy' ? orderBook.asks : orderBook.bids;\n\n    for (const level of oppositeBook) {\n      if (order.remaining <= BigInt(0)) break;\n\n      // Check price match\n      if (order.type === 'limit') {\n        if (order.side === 'buy' && level.price > order.price) break;\n        if (order.side === 'sell' && level.price < order.price) break;\n      }\n\n      // Find matching orders at this level\n      const matchingOrders = Array.from(this.orders.values()).filter(o =>\n        o.pairId === order.pairId &&\n        o.side !== order.side &&\n        o.price === level.price &&\n        (o.status === 'open' || o.status === 'partial')\n      );\n\n      for (const matchOrder of matchingOrders) {\n        if (order.remaining <= BigInt(0)) break;\n\n        const matchAmount = order.remaining < matchOrder.remaining\n          ? order.remaining\n          : matchOrder.remaining;\n\n        await this.executeTrade(order, matchOrder, matchAmount, level.price);\n      }\n    }\n  }\n\n  private async executeTrade(\n    buyOrder: Order,\n    sellOrder: Order,\n    amount: bigint,\n    price: bigint\n  ): Promise<Trade> {\n    const pair = this.pairs.get(buyOrder.pairId)!;\n\n    const trade: Trade = {\n      id: this.generateId('trade'),\n      pairId: buyOrder.pairId,\n      buyOrderId: buyOrder.id,\n      sellOrderId: sellOrder.id,\n      buyerId: buyOrder.userId,\n      sellerId: sellOrder.userId,\n      price,\n      amount,\n      buyerFee: (amount * BigInt(Math.floor(pair.takerFee * 10000))) / BigInt(10000),\n      sellerFee: (amount * BigInt(Math.floor(pair.makerFee * 10000))) / BigInt(10000),\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    // Update orders\n    this.updateOrderFill(buyOrder, amount, price);\n    this.updateOrderFill(sellOrder, amount, price);\n\n    // Execute via callback if provided\n    if (this.matchCallback) {\n      const result = await this.matchCallback(buyOrder, sellOrder, amount, price);\n      trade.txid = result.txid;\n      trade.status = result.status;\n      trade.settledAt = result.settledAt;\n    } else {\n      trade.status = 'settled';\n      trade.settledAt = new Date();\n    }\n\n    this.trades.push(trade);\n    this.updateTicker(buyOrder.pairId, price, amount);\n\n    return trade;\n  }\n\n  private updateOrderFill(order: Order, amount: bigint, price: bigint): void {\n    order.filled += amount;\n    order.remaining -= amount;\n    order.updatedAt = new Date();\n\n    // Calculate average fill price\n    const totalValue = (order.avgFillPrice || BigInt(0)) * (order.filled - amount) + price * amount;\n    order.avgFillPrice = totalValue / order.filled;\n\n    if (order.remaining <= BigInt(0)) {\n      order.status = 'filled';\n      this.removeFromOrderBook(order);\n    } else {\n      order.status = 'partial';\n      this.updateOrderBook(order.pairId);\n    }\n  }\n\n  // ==========================================================================\n  // Order Book\n  // ==========================================================================\n\n  private initializeOrderBook(pairId: string): void {\n    this.orderBooks.set(pairId, {\n      pairId,\n      bids: [],\n      asks: [],\n      spread: BigInt(0),\n      spreadPercent: 0,\n      lastUpdated: new Date(),\n    });\n  }\n\n  private addToOrderBook(order: Order): void {\n    const book = this.orderBooks.get(order.pairId);\n    if (!book) return;\n\n    const levels = order.side === 'buy' ? book.bids : book.asks;\n    const existingLevel = levels.find(l => l.price === order.price);\n\n    if (existingLevel) {\n      existingLevel.amount += order.remaining;\n      existingLevel.orderCount++;\n    } else {\n      levels.push({\n        price: order.price,\n        amount: order.remaining,\n        orderCount: 1,\n      });\n\n      // Sort: bids descending, asks ascending\n      if (order.side === 'buy') {\n        levels.sort((a, b) => Number(b.price - a.price));\n      } else {\n        levels.sort((a, b) => Number(a.price - b.price));\n      }\n    }\n\n    this.updateSpread(book);\n  }\n\n  private removeFromOrderBook(order: Order): void {\n    const book = this.orderBooks.get(order.pairId);\n    if (!book) return;\n\n    const levels = order.side === 'buy' ? book.bids : book.asks;\n    const levelIndex = levels.findIndex(l => l.price === order.price);\n\n    if (levelIndex >= 0) {\n      levels[levelIndex].amount -= order.remaining;\n      levels[levelIndex].orderCount--;\n\n      if (levels[levelIndex].amount <= BigInt(0)) {\n        levels.splice(levelIndex, 1);\n      }\n    }\n\n    this.updateSpread(book);\n  }\n\n  private updateOrderBook(pairId: string): void {\n    const book = this.orderBooks.get(pairId);\n    if (book) {\n      book.lastUpdated = new Date();\n      this.updateSpread(book);\n    }\n  }\n\n  private updateSpread(book: OrderBook): void {\n    if (book.bids.length > 0 && book.asks.length > 0) {\n      const bestBid = book.bids[0].price;\n      const bestAsk = book.asks[0].price;\n      book.spread = bestAsk - bestBid;\n      book.spreadPercent = Number((book.spread * BigInt(10000)) / bestAsk) / 100;\n    } else {\n      book.spread = BigInt(0);\n      book.spreadPercent = 0;\n    }\n  }\n\n  getOrderBook(pairId: string, depth?: number): OrderBook | undefined {\n    const book = this.orderBooks.get(pairId);\n    if (!book) return undefined;\n\n    return {\n      ...book,\n      bids: depth ? book.bids.slice(0, depth) : book.bids,\n      asks: depth ? book.asks.slice(0, depth) : book.asks,\n    };\n  }\n\n  // ==========================================================================\n  // Ticker & Stats\n  // ==========================================================================\n\n  private initializeTicker(pairId: string): void {\n    this.tickers.set(pairId, {\n      pairId,\n      lastPrice: BigInt(0),\n      priceChange24h: BigInt(0),\n      priceChangePercent24h: 0,\n      high24h: BigInt(0),\n      low24h: BigInt(0),\n      volume24h: BigInt(0),\n      quoteVolume24h: BigInt(0),\n      openPrice24h: BigInt(0),\n      bestBid: BigInt(0),\n      bestAsk: BigInt(0),\n      lastUpdated: new Date(),\n    });\n  }\n\n  private updateTicker(pairId: string, price: bigint, volume: bigint): void {\n    const ticker = this.tickers.get(pairId);\n    if (!ticker) return;\n\n    ticker.lastPrice = price;\n    ticker.volume24h += volume;\n    ticker.quoteVolume24h += price * volume;\n\n    if (ticker.high24h === BigInt(0) || price > ticker.high24h) {\n      ticker.high24h = price;\n    }\n    if (ticker.low24h === BigInt(0) || price < ticker.low24h) {\n      ticker.low24h = price;\n    }\n\n    const book = this.orderBooks.get(pairId);\n    if (book) {\n      ticker.bestBid = book.bids[0]?.price || BigInt(0);\n      ticker.bestAsk = book.asks[0]?.price || BigInt(0);\n    }\n\n    ticker.lastUpdated = new Date();\n  }\n\n  getTicker(pairId: string): MarketTicker | undefined {\n    return this.tickers.get(pairId);\n  }\n\n  getAllTickers(): MarketTicker[] {\n    return Array.from(this.tickers.values());\n  }\n\n  getTrades(pairId: string, limit?: number): Trade[] {\n    const trades = this.trades\n      .filter(t => t.pairId === pairId)\n      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n\n    return limit ? trades.slice(0, limit) : trades;\n  }\n\n  // ==========================================================================\n  // Validation\n  // ==========================================================================\n\n  private validateOrder(input: CreateOrderInput, pair: TokenPair): void {\n    if (input.amount < pair.minOrderSize) {\n      throw new Error(`Minimum order size is ${pair.minOrderSize}`);\n    }\n    if (input.amount > pair.maxOrderSize) {\n      throw new Error(`Maximum order size is ${pair.maxOrderSize}`);\n    }\n    if (input.type === 'limit' && !input.price) {\n      throw new Error('Limit orders require a price');\n    }\n    if (input.price && input.price % pair.tickSize !== BigInt(0)) {\n      throw new Error(`Price must be a multiple of tick size ${pair.tickSize}`);\n    }\n  }\n\n  private generateId(prefix: string): string {\n    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createMarketManager(): MarketManager {\n  return new MarketManager();\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function formatPrice(price: bigint, decimals: number): string {\n  const divisor = BigInt(10 ** decimals);\n  const whole = price / divisor;\n  const fraction = price % divisor;\n  if (fraction === BigInt(0)) return whole.toString();\n  return `${whole}.${fraction.toString().padStart(decimals, '0').replace(/0+$/, '')}`;\n}\n\nexport function parsePrice(price: string, decimals: number): bigint {\n  const [whole, fraction = ''] = price.split('.');\n  const paddedFraction = fraction.padEnd(decimals, '0').slice(0, decimals);\n  return BigInt(whole + paddedFraction);\n}\n\nexport function calculateTotal(price: bigint, amount: bigint, decimals: number): bigint {\n  return (price * amount) / BigInt(10 ** decimals);\n}\n\nexport function getPriceChangeColor(change: number): string {\n  if (change > 0) return '#22C55E';\n  if (change < 0) return '#EF4444';\n  return '#6B7280';\n}\n\nexport function formatVolume(volume: bigint): string {\n  const num = Number(volume);\n  if (num >= 1e9) return `${(num / 1e9).toFixed(2)}B`;\n  if (num >= 1e6) return `${(num / 1e6).toFixed(2)}M`;\n  if (num >= 1e3) return `${(num / 1e3).toFixed(2)}K`;\n  return num.toFixed(2);\n}\n"],"mappings":"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","names":[]}