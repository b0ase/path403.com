{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/network-graph\n *\n * D3 force-directed network graph types and utilities.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Node type */\nexport type NodeType =\n  | 'default'\n  | 'user'\n  | 'token'\n  | 'organization'\n  | 'project'\n  | 'transaction'\n  | 'file'\n  | 'group';\n\n/** Edge type */\nexport type EdgeType =\n  | 'default'\n  | 'owns'\n  | 'member'\n  | 'transfer'\n  | 'relationship'\n  | 'dependency'\n  | 'bidirectional';\n\n/** Node shape */\nexport type NodeShape = 'circle' | 'square' | 'diamond' | 'triangle' | 'hexagon';\n\n/** Graph node */\nexport interface GraphNode {\n  id: string;\n  label: string;\n  type: NodeType;\n  shape?: NodeShape;\n  size?: number;\n  color?: string;\n  icon?: string;\n  image?: string;\n  metadata?: Record<string, unknown>;\n  // D3 simulation properties\n  x?: number;\n  y?: number;\n  vx?: number;\n  vy?: number;\n  fx?: number | null;\n  fy?: number | null;\n  index?: number;\n}\n\n/** Graph edge/link */\nexport interface GraphEdge {\n  id: string;\n  source: string | GraphNode;\n  target: string | GraphNode;\n  type: EdgeType;\n  label?: string;\n  weight?: number;\n  color?: string;\n  dashed?: boolean;\n  animated?: boolean;\n  metadata?: Record<string, unknown>;\n  index?: number;\n}\n\n/** Graph data */\nexport interface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n\n/** Force simulation config */\nexport interface ForceConfig {\n  /** Center force strength */\n  centerStrength?: number;\n  /** Charge force strength (negative = repel) */\n  chargeStrength?: number;\n  /** Collision radius multiplier */\n  collisionRadius?: number;\n  /** Link distance */\n  linkDistance?: number;\n  /** Link strength */\n  linkStrength?: number;\n  /** Alpha decay rate */\n  alphaDecay?: number;\n  /** Velocity decay */\n  velocityDecay?: number;\n  /** Alpha target for stabilization */\n  alphaTarget?: number;\n}\n\n/** Layout type */\nexport type LayoutType =\n  | 'force'\n  | 'circular'\n  | 'hierarchical'\n  | 'radial'\n  | 'grid'\n  | 'tree';\n\n/** Layout config */\nexport interface LayoutConfig {\n  type: LayoutType;\n  width: number;\n  height: number;\n  padding?: number;\n  force?: ForceConfig;\n}\n\n/** Graph viewport */\nexport interface GraphViewport {\n  x: number;\n  y: number;\n  zoom: number;\n  minZoom?: number;\n  maxZoom?: number;\n}\n\n/** Graph selection */\nexport interface GraphSelection {\n  nodes: string[];\n  edges: string[];\n}\n\n/** Graph interaction event */\nexport interface GraphEvent {\n  type: 'click' | 'dblclick' | 'hover' | 'drag' | 'select';\n  target: 'node' | 'edge' | 'background';\n  nodeId?: string;\n  edgeId?: string;\n  position?: { x: number; y: number };\n}\n\n/** Graph callbacks */\nexport interface GraphCallbacks {\n  onNodeClick?: (node: GraphNode) => void;\n  onNodeDoubleClick?: (node: GraphNode) => void;\n  onNodeHover?: (node: GraphNode | null) => void;\n  onNodeDrag?: (node: GraphNode, position: { x: number; y: number }) => void;\n  onEdgeClick?: (edge: GraphEdge) => void;\n  onBackgroundClick?: (position: { x: number; y: number }) => void;\n  onSelectionChange?: (selection: GraphSelection) => void;\n  onZoomChange?: (viewport: GraphViewport) => void;\n}\n\n// ============================================================================\n// Default Configurations\n// ============================================================================\n\nexport const DEFAULT_FORCE_CONFIG: ForceConfig = {\n  centerStrength: 0.05,\n  chargeStrength: -300,\n  collisionRadius: 1.5,\n  linkDistance: 100,\n  linkStrength: 0.5,\n  alphaDecay: 0.02,\n  velocityDecay: 0.4,\n  alphaTarget: 0,\n};\n\nexport const NODE_COLORS: Record<NodeType, string> = {\n  default: '#6B7280',\n  user: '#3B82F6',\n  token: '#F59E0B',\n  organization: '#8B5CF6',\n  project: '#10B981',\n  transaction: '#EF4444',\n  file: '#EC4899',\n  group: '#6366F1',\n};\n\nexport const EDGE_COLORS: Record<EdgeType, string> = {\n  default: '#9CA3AF',\n  owns: '#3B82F6',\n  member: '#10B981',\n  transfer: '#F59E0B',\n  relationship: '#8B5CF6',\n  dependency: '#EF4444',\n  bidirectional: '#6366F1',\n};\n\n// ============================================================================\n// Graph Manager\n// ============================================================================\n\nexport class GraphManager {\n  private data: GraphData;\n  private config: LayoutConfig;\n  private viewport: GraphViewport;\n  private selection: GraphSelection;\n  private nodeMap: Map<string, GraphNode>;\n  private edgeMap: Map<string, GraphEdge>;\n\n  constructor(config: LayoutConfig) {\n    this.config = config;\n    this.data = { nodes: [], edges: [] };\n    this.viewport = { x: 0, y: 0, zoom: 1, minZoom: 0.1, maxZoom: 4 };\n    this.selection = { nodes: [], edges: [] };\n    this.nodeMap = new Map();\n    this.edgeMap = new Map();\n  }\n\n  setData(data: GraphData): void {\n    this.data = data;\n    this.nodeMap.clear();\n    this.edgeMap.clear();\n\n    for (const node of data.nodes) {\n      this.nodeMap.set(node.id, node);\n    }\n    for (const edge of data.edges) {\n      this.edgeMap.set(edge.id, edge);\n    }\n  }\n\n  getData(): GraphData {\n    return { ...this.data };\n  }\n\n  addNode(node: GraphNode): void {\n    if (this.nodeMap.has(node.id)) {\n      throw new Error(`Node already exists: ${node.id}`);\n    }\n    this.data.nodes.push(node);\n    this.nodeMap.set(node.id, node);\n  }\n\n  removeNode(nodeId: string): void {\n    const index = this.data.nodes.findIndex(n => n.id === nodeId);\n    if (index >= 0) {\n      this.data.nodes.splice(index, 1);\n      this.nodeMap.delete(nodeId);\n\n      // Remove connected edges\n      this.data.edges = this.data.edges.filter(e => {\n        const sourceId = typeof e.source === 'string' ? e.source : e.source.id;\n        const targetId = typeof e.target === 'string' ? e.target : e.target.id;\n        const keep = sourceId !== nodeId && targetId !== nodeId;\n        if (!keep) {\n          this.edgeMap.delete(e.id);\n        }\n        return keep;\n      });\n    }\n  }\n\n  updateNode(nodeId: string, updates: Partial<GraphNode>): void {\n    const node = this.nodeMap.get(nodeId);\n    if (node) {\n      Object.assign(node, updates);\n    }\n  }\n\n  getNode(nodeId: string): GraphNode | undefined {\n    return this.nodeMap.get(nodeId);\n  }\n\n  addEdge(edge: GraphEdge): void {\n    if (this.edgeMap.has(edge.id)) {\n      throw new Error(`Edge already exists: ${edge.id}`);\n    }\n    this.data.edges.push(edge);\n    this.edgeMap.set(edge.id, edge);\n  }\n\n  removeEdge(edgeId: string): void {\n    const index = this.data.edges.findIndex(e => e.id === edgeId);\n    if (index >= 0) {\n      this.data.edges.splice(index, 1);\n      this.edgeMap.delete(edgeId);\n    }\n  }\n\n  updateEdge(edgeId: string, updates: Partial<GraphEdge>): void {\n    const edge = this.edgeMap.get(edgeId);\n    if (edge) {\n      Object.assign(edge, updates);\n    }\n  }\n\n  getEdge(edgeId: string): GraphEdge | undefined {\n    return this.edgeMap.get(edgeId);\n  }\n\n  getConnectedEdges(nodeId: string): GraphEdge[] {\n    return this.data.edges.filter(e => {\n      const sourceId = typeof e.source === 'string' ? e.source : e.source.id;\n      const targetId = typeof e.target === 'string' ? e.target : e.target.id;\n      return sourceId === nodeId || targetId === nodeId;\n    });\n  }\n\n  getNeighbors(nodeId: string): GraphNode[] {\n    const neighborIds = new Set<string>();\n    for (const edge of this.getConnectedEdges(nodeId)) {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      if (sourceId === nodeId) neighborIds.add(targetId);\n      if (targetId === nodeId) neighborIds.add(sourceId);\n    }\n    return Array.from(neighborIds)\n      .map(id => this.nodeMap.get(id))\n      .filter((n): n is GraphNode => !!n);\n  }\n\n  setSelection(selection: GraphSelection): void {\n    this.selection = selection;\n  }\n\n  getSelection(): GraphSelection {\n    return { ...this.selection };\n  }\n\n  selectNode(nodeId: string, multi = false): void {\n    if (multi) {\n      if (!this.selection.nodes.includes(nodeId)) {\n        this.selection.nodes.push(nodeId);\n      }\n    } else {\n      this.selection = { nodes: [nodeId], edges: [] };\n    }\n  }\n\n  deselectNode(nodeId: string): void {\n    this.selection.nodes = this.selection.nodes.filter(id => id !== nodeId);\n  }\n\n  clearSelection(): void {\n    this.selection = { nodes: [], edges: [] };\n  }\n\n  setViewport(viewport: Partial<GraphViewport>): void {\n    Object.assign(this.viewport, viewport);\n    if (this.viewport.minZoom && this.viewport.zoom < this.viewport.minZoom) {\n      this.viewport.zoom = this.viewport.minZoom;\n    }\n    if (this.viewport.maxZoom && this.viewport.zoom > this.viewport.maxZoom) {\n      this.viewport.zoom = this.viewport.maxZoom;\n    }\n  }\n\n  getViewport(): GraphViewport {\n    return { ...this.viewport };\n  }\n\n  fitToView(padding = 50): void {\n    if (this.data.nodes.length === 0) return;\n\n    let minX = Infinity, minY = Infinity;\n    let maxX = -Infinity, maxY = -Infinity;\n\n    for (const node of this.data.nodes) {\n      if (node.x !== undefined && node.y !== undefined) {\n        minX = Math.min(minX, node.x);\n        minY = Math.min(minY, node.y);\n        maxX = Math.max(maxX, node.x);\n        maxY = Math.max(maxY, node.y);\n      }\n    }\n\n    if (minX === Infinity) return;\n\n    const graphWidth = maxX - minX + padding * 2;\n    const graphHeight = maxY - minY + padding * 2;\n\n    const zoom = Math.min(\n      this.config.width / graphWidth,\n      this.config.height / graphHeight,\n      this.viewport.maxZoom || 4\n    );\n\n    this.viewport = {\n      ...this.viewport,\n      x: (minX + maxX) / 2,\n      y: (minY + maxY) / 2,\n      zoom: Math.max(zoom, this.viewport.minZoom || 0.1),\n    };\n  }\n\n  getStats(): {\n    nodeCount: number;\n    edgeCount: number;\n    density: number;\n    avgDegree: number;\n  } {\n    const nodeCount = this.data.nodes.length;\n    const edgeCount = this.data.edges.length;\n    const maxEdges = (nodeCount * (nodeCount - 1)) / 2;\n    const density = maxEdges > 0 ? edgeCount / maxEdges : 0;\n    const avgDegree = nodeCount > 0 ? (2 * edgeCount) / nodeCount : 0;\n\n    return { nodeCount, edgeCount, density, avgDegree };\n  }\n}\n\n// ============================================================================\n// Layout Functions\n// ============================================================================\n\nexport function applyCircularLayout(\n  nodes: GraphNode[],\n  width: number,\n  height: number,\n  padding = 50\n): void {\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(width, height) / 2 - padding;\n\n  nodes.forEach((node, i) => {\n    const angle = (2 * Math.PI * i) / nodes.length - Math.PI / 2;\n    node.x = centerX + radius * Math.cos(angle);\n    node.y = centerY + radius * Math.sin(angle);\n  });\n}\n\nexport function applyGridLayout(\n  nodes: GraphNode[],\n  width: number,\n  height: number,\n  padding = 50\n): void {\n  const cols = Math.ceil(Math.sqrt(nodes.length));\n  const cellWidth = (width - padding * 2) / cols;\n  const cellHeight = (height - padding * 2) / Math.ceil(nodes.length / cols);\n\n  nodes.forEach((node, i) => {\n    const col = i % cols;\n    const row = Math.floor(i / cols);\n    node.x = padding + cellWidth * (col + 0.5);\n    node.y = padding + cellHeight * (row + 0.5);\n  });\n}\n\nexport function applyRadialLayout(\n  nodes: GraphNode[],\n  width: number,\n  height: number,\n  centerNodeId?: string\n): void {\n  const centerX = width / 2;\n  const centerY = height / 2;\n\n  // Find center node or use first\n  const centerNode = centerNodeId\n    ? nodes.find(n => n.id === centerNodeId)\n    : nodes[0];\n\n  if (!centerNode) return;\n\n  centerNode.x = centerX;\n  centerNode.y = centerY;\n\n  const others = nodes.filter(n => n.id !== centerNode.id);\n  const radius = Math.min(width, height) / 3;\n\n  others.forEach((node, i) => {\n    const angle = (2 * Math.PI * i) / others.length;\n    node.x = centerX + radius * Math.cos(angle);\n    node.y = centerY + radius * Math.sin(angle);\n  });\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createGraphManager(config: LayoutConfig): GraphManager {\n  return new GraphManager(config);\n}\n\nexport function createNode(\n  id: string,\n  label: string,\n  type: NodeType = 'default',\n  options?: Partial<GraphNode>\n): GraphNode {\n  return {\n    id,\n    label,\n    type,\n    color: NODE_COLORS[type],\n    size: 20,\n    ...options,\n  };\n}\n\nexport function createEdge(\n  id: string,\n  source: string,\n  target: string,\n  type: EdgeType = 'default',\n  options?: Partial<GraphEdge>\n): GraphEdge {\n  return {\n    id,\n    source,\n    target,\n    type,\n    color: EDGE_COLORS[type],\n    ...options,\n  };\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function generateEdgeId(sourceId: string, targetId: string): string {\n  return `${sourceId}-${targetId}`;\n}\n\nexport function getNodeDegree(nodeId: string, edges: GraphEdge[]): number {\n  return edges.filter(e => {\n    const sourceId = typeof e.source === 'string' ? e.source : e.source.id;\n    const targetId = typeof e.target === 'string' ? e.target : e.target.id;\n    return sourceId === nodeId || targetId === nodeId;\n  }).length;\n}\n\nexport function filterByNodeType(data: GraphData, types: NodeType[]): GraphData {\n  const nodeIds = new Set(data.nodes.filter(n => types.includes(n.type)).map(n => n.id));\n  return {\n    nodes: data.nodes.filter(n => nodeIds.has(n.id)),\n    edges: data.edges.filter(e => {\n      const sourceId = typeof e.source === 'string' ? e.source : e.source.id;\n      const targetId = typeof e.target === 'string' ? e.target : e.target.id;\n      return nodeIds.has(sourceId) && nodeIds.has(targetId);\n    }),\n  };\n}\n\nexport function mergeGraphs(...graphs: GraphData[]): GraphData {\n  const nodeMap = new Map<string, GraphNode>();\n  const edgeMap = new Map<string, GraphEdge>();\n\n  for (const graph of graphs) {\n    for (const node of graph.nodes) {\n      nodeMap.set(node.id, node);\n    }\n    for (const edge of graph.edges) {\n      edgeMap.set(edge.id, edge);\n    }\n  }\n\n  return {\n    nodes: Array.from(nodeMap.values()),\n    edges: Array.from(edgeMap.values()),\n  };\n}\n\nexport function calculateBoundingBox(nodes: GraphNode[]): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} | null {\n  if (nodes.length === 0) return null;\n\n  let minX = Infinity, minY = Infinity;\n  let maxX = -Infinity, maxY = -Infinity;\n\n  for (const node of nodes) {\n    if (node.x !== undefined && node.y !== undefined) {\n      minX = Math.min(minX, node.x);\n      minY = Math.min(minY, node.y);\n      maxX = Math.max(maxX, node.x);\n      maxY = Math.max(maxY, node.y);\n    }\n  }\n\n  if (minX === Infinity) return null;\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4JO,IAAM,uBAAoC;AAAA,EAC/C,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB,iBAAiB;AAAA,EACjB,cAAc;AAAA,EACd,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,aAAa;AACf;AAEO,IAAM,cAAwC;AAAA,EACnD,SAAS;AAAA,EACT,MAAM;AAAA,EACN,OAAO;AAAA,EACP,cAAc;AAAA,EACd,SAAS;AAAA,EACT,aAAa;AAAA,EACb,MAAM;AAAA,EACN,OAAO;AACT;AAEO,IAAM,cAAwC;AAAA,EACnD,SAAS;AAAA,EACT,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,eAAe;AACjB;AAMO,IAAM,eAAN,MAAmB;AAAA,EAQxB,YAAY,QAAsB;AAChC,SAAK,SAAS;AACd,SAAK,OAAO,EAAE,OAAO,CAAC,GAAG,OAAO,CAAC,EAAE;AACnC,SAAK,WAAW,EAAE,GAAG,GAAG,GAAG,GAAG,MAAM,GAAG,SAAS,KAAK,SAAS,EAAE;AAChE,SAAK,YAAY,EAAE,OAAO,CAAC,GAAG,OAAO,CAAC,EAAE;AACxC,SAAK,UAAU,oBAAI,IAAI;AACvB,SAAK,UAAU,oBAAI,IAAI;AAAA,EACzB;AAAA,EAEA,QAAQ,MAAuB;AAC7B,SAAK,OAAO;AACZ,SAAK,QAAQ,MAAM;AACnB,SAAK,QAAQ,MAAM;AAEnB,eAAW,QAAQ,KAAK,OAAO;AAC7B,WAAK,QAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,IAChC;AACA,eAAW,QAAQ,KAAK,OAAO;AAC7B,WAAK,QAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,UAAqB;AACnB,WAAO,EAAE,GAAG,KAAK,KAAK;AAAA,EACxB;AAAA,EAEA,QAAQ,MAAuB;AAC7B,QAAI,KAAK,QAAQ,IAAI,KAAK,EAAE,GAAG;AAC7B,YAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE,EAAE;AAAA,IACnD;AACA,SAAK,KAAK,MAAM,KAAK,IAAI;AACzB,SAAK,QAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,EAChC;AAAA,EAEA,WAAW,QAAsB;AAC/B,UAAM,QAAQ,KAAK,KAAK,MAAM,UAAU,OAAK,EAAE,OAAO,MAAM;AAC5D,QAAI,SAAS,GAAG;AACd,WAAK,KAAK,MAAM,OAAO,OAAO,CAAC;AAC/B,WAAK,QAAQ,OAAO,MAAM;AAG1B,WAAK,KAAK,QAAQ,KAAK,KAAK,MAAM,OAAO,OAAK;AAC5C,cAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,cAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,cAAM,OAAO,aAAa,UAAU,aAAa;AACjD,YAAI,CAAC,MAAM;AACT,eAAK,QAAQ,OAAO,EAAE,EAAE;AAAA,QAC1B;AACA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,WAAW,QAAgB,SAAmC;AAC5D,UAAM,OAAO,KAAK,QAAQ,IAAI,MAAM;AACpC,QAAI,MAAM;AACR,aAAO,OAAO,MAAM,OAAO;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,QAAQ,QAAuC;AAC7C,WAAO,KAAK,QAAQ,IAAI,MAAM;AAAA,EAChC;AAAA,EAEA,QAAQ,MAAuB;AAC7B,QAAI,KAAK,QAAQ,IAAI,KAAK,EAAE,GAAG;AAC7B,YAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE,EAAE;AAAA,IACnD;AACA,SAAK,KAAK,MAAM,KAAK,IAAI;AACzB,SAAK,QAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,EAChC;AAAA,EAEA,WAAW,QAAsB;AAC/B,UAAM,QAAQ,KAAK,KAAK,MAAM,UAAU,OAAK,EAAE,OAAO,MAAM;AAC5D,QAAI,SAAS,GAAG;AACd,WAAK,KAAK,MAAM,OAAO,OAAO,CAAC;AAC/B,WAAK,QAAQ,OAAO,MAAM;AAAA,IAC5B;AAAA,EACF;AAAA,EAEA,WAAW,QAAgB,SAAmC;AAC5D,UAAM,OAAO,KAAK,QAAQ,IAAI,MAAM;AACpC,QAAI,MAAM;AACR,aAAO,OAAO,MAAM,OAAO;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,QAAQ,QAAuC;AAC7C,WAAO,KAAK,QAAQ,IAAI,MAAM;AAAA,EAChC;AAAA,EAEA,kBAAkB,QAA6B;AAC7C,WAAO,KAAK,KAAK,MAAM,OAAO,OAAK;AACjC,YAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,YAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,aAAO,aAAa,UAAU,aAAa;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA,EAEA,aAAa,QAA6B;AACxC,UAAM,cAAc,oBAAI,IAAY;AACpC,eAAW,QAAQ,KAAK,kBAAkB,MAAM,GAAG;AACjD,YAAM,WAAW,OAAO,KAAK,WAAW,WAAW,KAAK,SAAS,KAAK,OAAO;AAC7E,YAAM,WAAW,OAAO,KAAK,WAAW,WAAW,KAAK,SAAS,KAAK,OAAO;AAC7E,UAAI,aAAa,OAAQ,aAAY,IAAI,QAAQ;AACjD,UAAI,aAAa,OAAQ,aAAY,IAAI,QAAQ;AAAA,IACnD;AACA,WAAO,MAAM,KAAK,WAAW,EAC1B,IAAI,QAAM,KAAK,QAAQ,IAAI,EAAE,CAAC,EAC9B,OAAO,CAAC,MAAsB,CAAC,CAAC,CAAC;AAAA,EACtC;AAAA,EAEA,aAAa,WAAiC;AAC5C,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,eAA+B;AAC7B,WAAO,EAAE,GAAG,KAAK,UAAU;AAAA,EAC7B;AAAA,EAEA,WAAW,QAAgB,QAAQ,OAAa;AAC9C,QAAI,OAAO;AACT,UAAI,CAAC,KAAK,UAAU,MAAM,SAAS,MAAM,GAAG;AAC1C,aAAK,UAAU,MAAM,KAAK,MAAM;AAAA,MAClC;AAAA,IACF,OAAO;AACL,WAAK,YAAY,EAAE,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,EAAE;AAAA,IAChD;AAAA,EACF;AAAA,EAEA,aAAa,QAAsB;AACjC,SAAK,UAAU,QAAQ,KAAK,UAAU,MAAM,OAAO,QAAM,OAAO,MAAM;AAAA,EACxE;AAAA,EAEA,iBAAuB;AACrB,SAAK,YAAY,EAAE,OAAO,CAAC,GAAG,OAAO,CAAC,EAAE;AAAA,EAC1C;AAAA,EAEA,YAAY,UAAwC;AAClD,WAAO,OAAO,KAAK,UAAU,QAAQ;AACrC,QAAI,KAAK,SAAS,WAAW,KAAK,SAAS,OAAO,KAAK,SAAS,SAAS;AACvE,WAAK,SAAS,OAAO,KAAK,SAAS;AAAA,IACrC;AACA,QAAI,KAAK,SAAS,WAAW,KAAK,SAAS,OAAO,KAAK,SAAS,SAAS;AACvE,WAAK,SAAS,OAAO,KAAK,SAAS;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,cAA6B;AAC3B,WAAO,EAAE,GAAG,KAAK,SAAS;AAAA,EAC5B;AAAA,EAEA,UAAU,UAAU,IAAU;AAC5B,QAAI,KAAK,KAAK,MAAM,WAAW,EAAG;AAElC,QAAI,OAAO,UAAU,OAAO;AAC5B,QAAI,OAAO,WAAW,OAAO;AAE7B,eAAW,QAAQ,KAAK,KAAK,OAAO;AAClC,UAAI,KAAK,MAAM,UAAa,KAAK,MAAM,QAAW;AAChD,eAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,eAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,eAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,eAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAAA,MAC9B;AAAA,IACF;AAEA,QAAI,SAAS,SAAU;AAEvB,UAAM,aAAa,OAAO,OAAO,UAAU;AAC3C,UAAM,cAAc,OAAO,OAAO,UAAU;AAE5C,UAAM,OAAO,KAAK;AAAA,MAChB,KAAK,OAAO,QAAQ;AAAA,MACpB,KAAK,OAAO,SAAS;AAAA,MACrB,KAAK,SAAS,WAAW;AAAA,IAC3B;AAEA,SAAK,WAAW;AAAA,MACd,GAAG,KAAK;AAAA,MACR,IAAI,OAAO,QAAQ;AAAA,MACnB,IAAI,OAAO,QAAQ;AAAA,MACnB,MAAM,KAAK,IAAI,MAAM,KAAK,SAAS,WAAW,GAAG;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,WAKE;AACA,UAAM,YAAY,KAAK,KAAK,MAAM;AAClC,UAAM,YAAY,KAAK,KAAK,MAAM;AAClC,UAAM,WAAY,aAAa,YAAY,KAAM;AACjD,UAAM,UAAU,WAAW,IAAI,YAAY,WAAW;AACtD,UAAM,YAAY,YAAY,IAAK,IAAI,YAAa,YAAY;AAEhE,WAAO,EAAE,WAAW,WAAW,SAAS,UAAU;AAAA,EACpD;AACF;AAMO,SAAS,oBACd,OACA,OACA,QACA,UAAU,IACJ;AACN,QAAM,UAAU,QAAQ;AACxB,QAAM,UAAU,SAAS;AACzB,QAAM,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI,IAAI;AAE7C,QAAM,QAAQ,CAAC,MAAM,MAAM;AACzB,UAAM,QAAS,IAAI,KAAK,KAAK,IAAK,MAAM,SAAS,KAAK,KAAK;AAC3D,SAAK,IAAI,UAAU,SAAS,KAAK,IAAI,KAAK;AAC1C,SAAK,IAAI,UAAU,SAAS,KAAK,IAAI,KAAK;AAAA,EAC5C,CAAC;AACH;AAEO,SAAS,gBACd,OACA,OACA,QACA,UAAU,IACJ;AACN,QAAM,OAAO,KAAK,KAAK,KAAK,KAAK,MAAM,MAAM,CAAC;AAC9C,QAAM,aAAa,QAAQ,UAAU,KAAK;AAC1C,QAAM,cAAc,SAAS,UAAU,KAAK,KAAK,KAAK,MAAM,SAAS,IAAI;AAEzE,QAAM,QAAQ,CAAC,MAAM,MAAM;AACzB,UAAM,MAAM,IAAI;AAChB,UAAM,MAAM,KAAK,MAAM,IAAI,IAAI;AAC/B,SAAK,IAAI,UAAU,aAAa,MAAM;AACtC,SAAK,IAAI,UAAU,cAAc,MAAM;AAAA,EACzC,CAAC;AACH;AAEO,SAAS,kBACd,OACA,OACA,QACA,cACM;AACN,QAAM,UAAU,QAAQ;AACxB,QAAM,UAAU,SAAS;AAGzB,QAAM,aAAa,eACf,MAAM,KAAK,OAAK,EAAE,OAAO,YAAY,IACrC,MAAM,CAAC;AAEX,MAAI,CAAC,WAAY;AAEjB,aAAW,IAAI;AACf,aAAW,IAAI;AAEf,QAAM,SAAS,MAAM,OAAO,OAAK,EAAE,OAAO,WAAW,EAAE;AACvD,QAAM,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI;AAEzC,SAAO,QAAQ,CAAC,MAAM,MAAM;AAC1B,UAAM,QAAS,IAAI,KAAK,KAAK,IAAK,OAAO;AACzC,SAAK,IAAI,UAAU,SAAS,KAAK,IAAI,KAAK;AAC1C,SAAK,IAAI,UAAU,SAAS,KAAK,IAAI,KAAK;AAAA,EAC5C,CAAC;AACH;AAMO,SAAS,mBAAmB,QAAoC;AACrE,SAAO,IAAI,aAAa,MAAM;AAChC;AAEO,SAAS,WACd,IACA,OACA,OAAiB,WACjB,SACW;AACX,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,YAAY,IAAI;AAAA,IACvB,MAAM;AAAA,IACN,GAAG;AAAA,EACL;AACF;AAEO,SAAS,WACd,IACA,QACA,QACA,OAAiB,WACjB,SACW;AACX,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,YAAY,IAAI;AAAA,IACvB,GAAG;AAAA,EACL;AACF;AAMO,SAAS,eAAe,UAAkB,UAA0B;AACzE,SAAO,GAAG,QAAQ,IAAI,QAAQ;AAChC;AAEO,SAAS,cAAc,QAAgB,OAA4B;AACxE,SAAO,MAAM,OAAO,OAAK;AACvB,UAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,UAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,WAAO,aAAa,UAAU,aAAa;AAAA,EAC7C,CAAC,EAAE;AACL;AAEO,SAAS,iBAAiB,MAAiB,OAA8B;AAC9E,QAAM,UAAU,IAAI,IAAI,KAAK,MAAM,OAAO,OAAK,MAAM,SAAS,EAAE,IAAI,CAAC,EAAE,IAAI,OAAK,EAAE,EAAE,CAAC;AACrF,SAAO;AAAA,IACL,OAAO,KAAK,MAAM,OAAO,OAAK,QAAQ,IAAI,EAAE,EAAE,CAAC;AAAA,IAC/C,OAAO,KAAK,MAAM,OAAO,OAAK;AAC5B,YAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,YAAM,WAAW,OAAO,EAAE,WAAW,WAAW,EAAE,SAAS,EAAE,OAAO;AACpE,aAAO,QAAQ,IAAI,QAAQ,KAAK,QAAQ,IAAI,QAAQ;AAAA,IACtD,CAAC;AAAA,EACH;AACF;AAEO,SAAS,eAAe,QAAgC;AAC7D,QAAM,UAAU,oBAAI,IAAuB;AAC3C,QAAM,UAAU,oBAAI,IAAuB;AAE3C,aAAW,SAAS,QAAQ;AAC1B,eAAW,QAAQ,MAAM,OAAO;AAC9B,cAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,IAC3B;AACA,eAAW,QAAQ,MAAM,OAAO;AAC9B,cAAQ,IAAI,KAAK,IAAI,IAAI;AAAA,IAC3B;AAAA,EACF;AAEA,SAAO;AAAA,IACL,OAAO,MAAM,KAAK,QAAQ,OAAO,CAAC;AAAA,IAClC,OAAO,MAAM,KAAK,QAAQ,OAAO,CAAC;AAAA,EACpC;AACF;AAEO,SAAS,qBAAqB,OAK5B;AACP,MAAI,MAAM,WAAW,EAAG,QAAO;AAE/B,MAAI,OAAO,UAAU,OAAO;AAC5B,MAAI,OAAO,WAAW,OAAO;AAE7B,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,MAAM,UAAa,KAAK,MAAM,QAAW;AAChD,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAAA,IAC9B;AAAA,EACF;AAEA,MAAI,SAAS,SAAU,QAAO;AAE9B,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO;AAAA,EACjB;AACF;","names":[]}