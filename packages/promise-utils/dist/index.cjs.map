{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/promise-utils\n *\n * Promise utilities: debounce, throttle, batch, pool, and more.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Async function type */\nexport type AsyncFn<T, A extends unknown[] = unknown[]> = (...args: A) => Promise<T>;\n\n/** Deferred promise */\nexport interface Deferred<T> {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: unknown) => void;\n}\n\n/** Pool task */\nexport interface PoolTask<T> {\n  fn: () => Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: unknown) => void;\n}\n\n/** Batch result */\nexport type BatchResult<T> = { status: 'fulfilled'; value: T } | { status: 'rejected'; reason: unknown };\n\n// ============================================================================\n// Basic Utilities\n// ============================================================================\n\n/**\n * Create a deferred promise\n */\nexport function deferred<T>(): Deferred<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/**\n * Sleep for a given duration\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Create a cancellable promise\n */\nexport function cancellable<T>(promise: Promise<T>): {\n  promise: Promise<T>;\n  cancel: () => void;\n} {\n  let cancelled = false;\n  let rejectFn: (reason: Error) => void;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    rejectFn = reject;\n    promise\n      .then((value) => {\n        if (!cancelled) resolve(value);\n      })\n      .catch((error) => {\n        if (!cancelled) reject(error);\n      });\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      cancelled = true;\n      rejectFn(new Error('Cancelled'));\n    },\n  };\n}\n\n// ============================================================================\n// Debounce & Throttle\n// ============================================================================\n\n/**\n * Debounce an async function\n */\nexport function debounce<T, A extends unknown[]>(\n  fn: (...args: A) => Promise<T>,\n  wait: number\n): (...args: A) => Promise<T> {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let pending: Deferred<T> | null = null;\n\n  return (...args: A): Promise<T> => {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    if (!pending) {\n      pending = deferred<T>();\n    }\n\n    const currentPending = pending;\n\n    timeout = setTimeout(async () => {\n      timeout = null;\n      pending = null;\n\n      try {\n        const result = await fn(...args);\n        currentPending.resolve(result);\n      } catch (error) {\n        currentPending.reject(error);\n      }\n    }, wait);\n\n    return currentPending.promise;\n  };\n}\n\n/**\n * Throttle an async function\n */\nexport function throttle<T, A extends unknown[]>(\n  fn: (...args: A) => Promise<T>,\n  limit: number\n): (...args: A) => Promise<T> {\n  let lastRun = 0;\n  let pending: Promise<T> | null = null;\n\n  return async (...args: A): Promise<T> => {\n    const now = Date.now();\n\n    if (pending) {\n      return pending;\n    }\n\n    if (now - lastRun >= limit) {\n      lastRun = now;\n      return fn(...args);\n    }\n\n    const delay = limit - (now - lastRun);\n    pending = sleep(delay).then(() => {\n      pending = null;\n      lastRun = Date.now();\n      return fn(...args);\n    });\n\n    return pending;\n  };\n}\n\n// ============================================================================\n// Concurrency Control\n// ============================================================================\n\n/**\n * Promise pool for concurrent execution with limit\n */\nexport class PromisePool<T = unknown> {\n  private concurrency: number;\n  private running = 0;\n  private queue: PoolTask<T>[] = [];\n\n  constructor(concurrency: number = 5) {\n    this.concurrency = concurrency;\n  }\n\n  async add(fn: () => Promise<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      this.queue.push({ fn, resolve, reject });\n      this.runNext();\n    });\n  }\n\n  private async runNext(): Promise<void> {\n    if (this.running >= this.concurrency || this.queue.length === 0) {\n      return;\n    }\n\n    const task = this.queue.shift();\n    if (!task) return;\n\n    this.running++;\n\n    try {\n      const result = await task.fn();\n      task.resolve(result);\n    } catch (error) {\n      task.reject(error);\n    } finally {\n      this.running--;\n      this.runNext();\n    }\n  }\n\n  getStats(): { running: number; queued: number; concurrency: number } {\n    return {\n      running: this.running,\n      queued: this.queue.length,\n      concurrency: this.concurrency,\n    };\n  }\n\n  setConcurrency(n: number): void {\n    this.concurrency = n;\n    // Trigger queued tasks if concurrency increased\n    for (let i = 0; i < n - this.running; i++) {\n      this.runNext();\n    }\n  }\n}\n\n/**\n * Execute promises with concurrency limit\n */\nexport async function pool<T>(\n  tasks: Array<() => Promise<T>>,\n  concurrency: number = 5\n): Promise<T[]> {\n  const promisePool = new PromisePool<T>(concurrency);\n  return Promise.all(tasks.map((task) => promisePool.add(task)));\n}\n\n/**\n * Execute promises in parallel with settled results\n */\nexport async function allSettled<T>(\n  tasks: Array<() => Promise<T>>,\n  concurrency?: number\n): Promise<Array<BatchResult<T>>> {\n  const wrapped = tasks.map(\n    (task) => () =>\n      task()\n        .then((value): BatchResult<T> => ({ status: 'fulfilled', value }))\n        .catch((reason): BatchResult<T> => ({ status: 'rejected', reason }))\n  );\n\n  if (concurrency) {\n    return pool(wrapped, concurrency);\n  }\n\n  return Promise.all(wrapped.map((fn) => fn()));\n}\n\n// ============================================================================\n// Batching\n// ============================================================================\n\n/**\n * Batch multiple calls into a single execution\n */\nexport function batch<K, V>(\n  fn: (keys: K[]) => Promise<Map<K, V>>,\n  options: { maxSize?: number; maxWait?: number } = {}\n): (key: K) => Promise<V> {\n  const { maxSize = 100, maxWait = 10 } = options;\n\n  let queue: Array<{ key: K; deferred: Deferred<V> }> = [];\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n\n  const flush = async () => {\n    const currentQueue = queue;\n    queue = [];\n    timeout = null;\n\n    if (currentQueue.length === 0) return;\n\n    const keys = currentQueue.map((item) => item.key);\n\n    try {\n      const results = await fn(keys);\n      for (const item of currentQueue) {\n        const value = results.get(item.key);\n        if (value !== undefined) {\n          item.deferred.resolve(value);\n        } else {\n          item.deferred.reject(new Error(`No result for key: ${String(item.key)}`));\n        }\n      }\n    } catch (error) {\n      for (const item of currentQueue) {\n        item.deferred.reject(error);\n      }\n    }\n  };\n\n  return (key: K): Promise<V> => {\n    const d = deferred<V>();\n    queue.push({ key, deferred: d });\n\n    if (queue.length >= maxSize) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      flush();\n    } else if (!timeout) {\n      timeout = setTimeout(flush, maxWait);\n    }\n\n    return d.promise;\n  };\n}\n\n// ============================================================================\n// Memoization\n// ============================================================================\n\n/**\n * Memoize an async function\n */\nexport function memoize<T, A extends unknown[]>(\n  fn: (...args: A) => Promise<T>,\n  options: {\n    keyFn?: (...args: A) => string;\n    ttl?: number;\n    maxSize?: number;\n  } = {}\n): (...args: A) => Promise<T> {\n  const { keyFn = (...args) => JSON.stringify(args), ttl, maxSize = 1000 } = options;\n\n  const cache = new Map<string, { value: T; expires?: number }>();\n\n  return async (...args: A): Promise<T> => {\n    const key = keyFn(...args);\n    const cached = cache.get(key);\n\n    if (cached) {\n      if (!cached.expires || cached.expires > Date.now()) {\n        return cached.value;\n      }\n      cache.delete(key);\n    }\n\n    const value = await fn(...args);\n\n    // Evict oldest if at capacity\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      if (firstKey) cache.delete(firstKey);\n    }\n\n    cache.set(key, {\n      value,\n      expires: ttl ? Date.now() + ttl : undefined,\n    });\n\n    return value;\n  };\n}\n\n// ============================================================================\n// Race & First Settled\n// ============================================================================\n\n/**\n * Race promises with proper cleanup\n */\nexport async function race<T>(\n  tasks: Array<() => Promise<T>>,\n  onCancel?: (index: number) => void\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let settled = false;\n\n    tasks.forEach((task, index) => {\n      task()\n        .then((value) => {\n          if (!settled) {\n            settled = true;\n            resolve(value);\n            // Notify other tasks they can cancel\n            tasks.forEach((_, i) => {\n              if (i !== index && onCancel) {\n                onCancel(i);\n              }\n            });\n          }\n        })\n        .catch((error) => {\n          if (!settled) {\n            settled = true;\n            reject(error);\n          }\n        });\n    });\n  });\n}\n\n/**\n * Get the first successfully settled promise\n */\nexport async function firstFulfilled<T>(\n  tasks: Array<() => Promise<T>>\n): Promise<T> {\n  const errors: Error[] = [];\n\n  return new Promise((resolve, reject) => {\n    let pending = tasks.length;\n\n    tasks.forEach((task) => {\n      task()\n        .then(resolve)\n        .catch((error) => {\n          errors.push(error);\n          pending--;\n          if (pending === 0) {\n            reject(new AggregateError(errors, 'All promises rejected'));\n          }\n        });\n    });\n  });\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Wait for a condition to be true\n */\nexport async function waitFor(\n  condition: () => boolean | Promise<boolean>,\n  options: { interval?: number; timeout?: number } = {}\n): Promise<void> {\n  const { interval = 100, timeout = 30000 } = options;\n  const start = Date.now();\n\n  while (true) {\n    if (await condition()) {\n      return;\n    }\n\n    if (Date.now() - start > timeout) {\n      throw new Error('waitFor timeout');\n    }\n\n    await sleep(interval);\n  }\n}\n\n/**\n * Retry a promise until it succeeds or reaches max attempts\n */\nexport async function retryUntil<T>(\n  fn: () => Promise<T>,\n  predicate: (result: T) => boolean,\n  options: { maxAttempts?: number; delay?: number } = {}\n): Promise<T> {\n  const { maxAttempts = 10, delay = 1000 } = options;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    const result = await fn();\n    if (predicate(result)) {\n      return result;\n    }\n\n    if (attempt < maxAttempts) {\n      await sleep(delay);\n    }\n  }\n\n  throw new Error('retryUntil max attempts reached');\n}\n\n/**\n * Map with concurrency limit\n */\nexport async function mapAsync<T, R>(\n  items: T[],\n  fn: (item: T, index: number) => Promise<R>,\n  concurrency: number = 5\n): Promise<R[]> {\n  const tasks = items.map((item, index) => () => fn(item, index));\n  return pool(tasks, concurrency);\n}\n\n/**\n * Filter with async predicate\n */\nexport async function filterAsync<T>(\n  items: T[],\n  predicate: (item: T, index: number) => Promise<boolean>,\n  concurrency: number = 5\n): Promise<T[]> {\n  const results = await mapAsync(\n    items,\n    async (item, index) => ({ item, keep: await predicate(item, index) }),\n    concurrency\n  );\n  return results.filter((r) => r.keep).map((r) => r.item);\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createPool<T>(concurrency?: number): PromisePool<T> {\n  return new PromisePool<T>(concurrency);\n}\n\n// ============================================================================\n// AggregateError Polyfill\n// ============================================================================\n\nclass AggregateError extends Error {\n  errors: Error[];\n\n  constructor(errors: Error[], message: string) {\n    super(message);\n    this.name = 'AggregateError';\n    this.errors = errors;\n  }\n}\n"],"mappings":"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","names":[]}