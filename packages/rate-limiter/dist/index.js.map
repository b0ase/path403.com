{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/rate-limiter\n *\n * Rate limiting utilities for APIs and services.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Rate limit algorithm */\nexport type RateLimitAlgorithm =\n  | 'fixed-window'\n  | 'sliding-window'\n  | 'token-bucket'\n  | 'leaky-bucket';\n\n/** Rate limit status */\nexport type RateLimitStatus = 'allowed' | 'limited' | 'blocked';\n\n/** Rate limit config */\nexport interface RateLimitConfig {\n  algorithm?: RateLimitAlgorithm;\n  maxRequests: number;\n  windowMs: number;\n  keyPrefix?: string;\n  skipFailedRequests?: boolean;\n  skipSuccessfulRequests?: boolean;\n  blockDuration?: number;\n  burstLimit?: number;\n}\n\n/** Rate limit result */\nexport interface RateLimitResult {\n  allowed: boolean;\n  status: RateLimitStatus;\n  remaining: number;\n  total: number;\n  resetAt: Date;\n  retryAfter?: number;\n}\n\n/** Rate limit entry */\nexport interface RateLimitEntry {\n  count: number;\n  startTime: number;\n  lastRequest: number;\n  blocked?: boolean;\n  blockedUntil?: number;\n  tokens?: number;\n}\n\n/** Rate limit headers */\nexport interface RateLimitHeaders {\n  'X-RateLimit-Limit': string;\n  'X-RateLimit-Remaining': string;\n  'X-RateLimit-Reset': string;\n  'Retry-After'?: string;\n}\n\n/** Store interface */\nexport interface RateLimitStore {\n  get(key: string): Promise<RateLimitEntry | null>;\n  set(key: string, entry: RateLimitEntry, ttlMs: number): Promise<void>;\n  increment(key: string, windowMs: number): Promise<RateLimitEntry>;\n  delete(key: string): Promise<void>;\n  reset(): Promise<void>;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULT_CONFIG: Required<RateLimitConfig> = {\n  algorithm: 'sliding-window',\n  maxRequests: 100,\n  windowMs: 60000, // 1 minute\n  keyPrefix: 'rl:',\n  skipFailedRequests: false,\n  skipSuccessfulRequests: false,\n  blockDuration: 0,\n  burstLimit: 0,\n};\n\n// ============================================================================\n// In-Memory Store\n// ============================================================================\n\nexport class MemoryStore implements RateLimitStore {\n  private store: Map<string, RateLimitEntry> = new Map();\n  private timers: Map<string, ReturnType<typeof setTimeout>> = new Map();\n\n  async get(key: string): Promise<RateLimitEntry | null> {\n    return this.store.get(key) || null;\n  }\n\n  async set(key: string, entry: RateLimitEntry, ttlMs: number): Promise<void> {\n    this.store.set(key, entry);\n\n    // Clear existing timer\n    const existingTimer = this.timers.get(key);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Set cleanup timer\n    const timer = setTimeout(() => {\n      this.store.delete(key);\n      this.timers.delete(key);\n    }, ttlMs);\n\n    this.timers.set(key, timer);\n  }\n\n  async increment(key: string, windowMs: number): Promise<RateLimitEntry> {\n    const now = Date.now();\n    const existing = this.store.get(key);\n\n    if (!existing || now - existing.startTime >= windowMs) {\n      const entry: RateLimitEntry = {\n        count: 1,\n        startTime: now,\n        lastRequest: now,\n      };\n      await this.set(key, entry, windowMs);\n      return entry;\n    }\n\n    existing.count++;\n    existing.lastRequest = now;\n    return existing;\n  }\n\n  async delete(key: string): Promise<void> {\n    const timer = this.timers.get(key);\n    if (timer) {\n      clearTimeout(timer);\n      this.timers.delete(key);\n    }\n    this.store.delete(key);\n  }\n\n  async reset(): Promise<void> {\n    for (const timer of this.timers.values()) {\n      clearTimeout(timer);\n    }\n    this.timers.clear();\n    this.store.clear();\n  }\n\n  size(): number {\n    return this.store.size;\n  }\n}\n\n// ============================================================================\n// Rate Limiter\n// ============================================================================\n\nexport class RateLimiter {\n  private config: Required<RateLimitConfig>;\n  private store: RateLimitStore;\n\n  constructor(config: RateLimitConfig, store?: RateLimitStore) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.store = store || new MemoryStore();\n  }\n\n  // ==========================================================================\n  // Core Methods\n  // ==========================================================================\n\n  async check(key: string): Promise<RateLimitResult> {\n    const fullKey = this.config.keyPrefix + key;\n\n    switch (this.config.algorithm) {\n      case 'token-bucket':\n        return this.checkTokenBucket(fullKey);\n      case 'leaky-bucket':\n        return this.checkLeakyBucket(fullKey);\n      case 'fixed-window':\n        return this.checkFixedWindow(fullKey);\n      case 'sliding-window':\n      default:\n        return this.checkSlidingWindow(fullKey);\n    }\n  }\n\n  async consume(key: string, tokens: number = 1): Promise<RateLimitResult> {\n    const fullKey = this.config.keyPrefix + key;\n    const result = await this.check(key);\n\n    if (result.allowed) {\n      const entry = await this.store.get(fullKey);\n      if (entry) {\n        entry.count += tokens - 1; // Already incremented by 1 in check\n        await this.store.set(fullKey, entry, this.config.windowMs);\n      }\n    }\n\n    return result;\n  }\n\n  async reset(key: string): Promise<void> {\n    const fullKey = this.config.keyPrefix + key;\n    await this.store.delete(fullKey);\n  }\n\n  async block(key: string, durationMs?: number): Promise<void> {\n    const fullKey = this.config.keyPrefix + key;\n    const duration = durationMs || this.config.blockDuration || this.config.windowMs;\n    const now = Date.now();\n\n    const entry: RateLimitEntry = {\n      count: this.config.maxRequests,\n      startTime: now,\n      lastRequest: now,\n      blocked: true,\n      blockedUntil: now + duration,\n    };\n\n    await this.store.set(fullKey, entry, duration);\n  }\n\n  async unblock(key: string): Promise<void> {\n    await this.reset(key);\n  }\n\n  // ==========================================================================\n  // Algorithm Implementations\n  // ==========================================================================\n\n  private async checkFixedWindow(key: string): Promise<RateLimitResult> {\n    const now = Date.now();\n    const entry = await this.store.increment(key, this.config.windowMs);\n\n    // Check if blocked\n    if (entry.blocked && entry.blockedUntil && now < entry.blockedUntil) {\n      return this.createBlockedResult(entry, now);\n    }\n\n    const allowed = entry.count <= this.config.maxRequests;\n    const remaining = Math.max(0, this.config.maxRequests - entry.count);\n    const resetAt = new Date(entry.startTime + this.config.windowMs);\n\n    if (!allowed && this.config.blockDuration > 0) {\n      await this.block(key.replace(this.config.keyPrefix, ''));\n    }\n\n    return {\n      allowed,\n      status: allowed ? 'allowed' : 'limited',\n      remaining,\n      total: this.config.maxRequests,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil((resetAt.getTime() - now) / 1000),\n    };\n  }\n\n  private async checkSlidingWindow(key: string): Promise<RateLimitResult> {\n    const now = Date.now();\n    const entry = await this.store.get(key);\n\n    if (!entry) {\n      const newEntry: RateLimitEntry = {\n        count: 1,\n        startTime: now,\n        lastRequest: now,\n      };\n      await this.store.set(key, newEntry, this.config.windowMs);\n\n      return {\n        allowed: true,\n        status: 'allowed',\n        remaining: this.config.maxRequests - 1,\n        total: this.config.maxRequests,\n        resetAt: new Date(now + this.config.windowMs),\n      };\n    }\n\n    // Check if blocked\n    if (entry.blocked && entry.blockedUntil && now < entry.blockedUntil) {\n      return this.createBlockedResult(entry, now);\n    }\n\n    // Calculate sliding window weight\n    const windowStart = now - this.config.windowMs;\n    const previousWindowWeight = Math.max(0, (entry.startTime + this.config.windowMs - now) / this.config.windowMs);\n    const currentWindowCount = now >= entry.startTime + this.config.windowMs ? 1 : entry.count + 1;\n    const previousWindowCount = now >= entry.startTime + this.config.windowMs ? entry.count : 0;\n\n    const weightedCount = previousWindowCount * previousWindowWeight + currentWindowCount;\n    const allowed = weightedCount <= this.config.maxRequests;\n\n    // Update entry\n    if (now >= entry.startTime + this.config.windowMs) {\n      entry.count = 1;\n      entry.startTime = now;\n    } else {\n      entry.count++;\n    }\n    entry.lastRequest = now;\n    await this.store.set(key, entry, this.config.windowMs * 2);\n\n    const remaining = Math.max(0, Math.floor(this.config.maxRequests - weightedCount));\n    const resetAt = new Date(entry.startTime + this.config.windowMs);\n\n    if (!allowed && this.config.blockDuration > 0) {\n      await this.block(key.replace(this.config.keyPrefix, ''));\n    }\n\n    return {\n      allowed,\n      status: allowed ? 'allowed' : 'limited',\n      remaining,\n      total: this.config.maxRequests,\n      resetAt,\n      retryAfter: allowed ? undefined : Math.ceil((resetAt.getTime() - now) / 1000),\n    };\n  }\n\n  private async checkTokenBucket(key: string): Promise<RateLimitResult> {\n    const now = Date.now();\n    const entry = await this.store.get(key);\n\n    const refillRate = this.config.maxRequests / this.config.windowMs;\n    const maxTokens = this.config.burstLimit || this.config.maxRequests;\n\n    if (!entry) {\n      const newEntry: RateLimitEntry = {\n        count: 0,\n        startTime: now,\n        lastRequest: now,\n        tokens: maxTokens - 1,\n      };\n      await this.store.set(key, newEntry, this.config.windowMs);\n\n      return {\n        allowed: true,\n        status: 'allowed',\n        remaining: maxTokens - 1,\n        total: maxTokens,\n        resetAt: new Date(now + this.config.windowMs),\n      };\n    }\n\n    // Check if blocked\n    if (entry.blocked && entry.blockedUntil && now < entry.blockedUntil) {\n      return this.createBlockedResult(entry, now);\n    }\n\n    // Refill tokens based on time elapsed\n    const elapsed = now - entry.lastRequest;\n    const refilled = Math.min(maxTokens, (entry.tokens || 0) + elapsed * refillRate);\n    const tokens = refilled - 1;\n    const allowed = refilled >= 1;\n\n    entry.tokens = allowed ? tokens : 0;\n    entry.lastRequest = now;\n    entry.count++;\n    await this.store.set(key, entry, this.config.windowMs);\n\n    if (!allowed && this.config.blockDuration > 0) {\n      await this.block(key.replace(this.config.keyPrefix, ''));\n    }\n\n    return {\n      allowed,\n      status: allowed ? 'allowed' : 'limited',\n      remaining: Math.max(0, Math.floor(entry.tokens)),\n      total: maxTokens,\n      resetAt: new Date(now + (maxTokens - (entry.tokens || 0)) / refillRate),\n      retryAfter: allowed ? undefined : Math.ceil(1 / refillRate / 1000),\n    };\n  }\n\n  private async checkLeakyBucket(key: string): Promise<RateLimitResult> {\n    const now = Date.now();\n    const entry = await this.store.get(key);\n\n    const leakRate = this.config.maxRequests / this.config.windowMs; // requests per ms\n    const bucketSize = this.config.burstLimit || this.config.maxRequests;\n\n    if (!entry) {\n      const newEntry: RateLimitEntry = {\n        count: 1,\n        startTime: now,\n        lastRequest: now,\n      };\n      await this.store.set(key, newEntry, this.config.windowMs);\n\n      return {\n        allowed: true,\n        status: 'allowed',\n        remaining: bucketSize - 1,\n        total: bucketSize,\n        resetAt: new Date(now + this.config.windowMs),\n      };\n    }\n\n    // Check if blocked\n    if (entry.blocked && entry.blockedUntil && now < entry.blockedUntil) {\n      return this.createBlockedResult(entry, now);\n    }\n\n    // Calculate leaked amount\n    const elapsed = now - entry.lastRequest;\n    const leaked = elapsed * leakRate;\n    const currentLevel = Math.max(0, entry.count - leaked);\n    const newLevel = currentLevel + 1;\n    const allowed = newLevel <= bucketSize;\n\n    entry.count = allowed ? newLevel : currentLevel;\n    entry.lastRequest = now;\n    await this.store.set(key, entry, this.config.windowMs);\n\n    if (!allowed && this.config.blockDuration > 0) {\n      await this.block(key.replace(this.config.keyPrefix, ''));\n    }\n\n    return {\n      allowed,\n      status: allowed ? 'allowed' : 'limited',\n      remaining: Math.max(0, Math.floor(bucketSize - entry.count)),\n      total: bucketSize,\n      resetAt: new Date(now + entry.count / leakRate),\n      retryAfter: allowed ? undefined : Math.ceil((newLevel - bucketSize) / leakRate / 1000),\n    };\n  }\n\n  private createBlockedResult(entry: RateLimitEntry, now: number): RateLimitResult {\n    const retryAfter = entry.blockedUntil ? Math.ceil((entry.blockedUntil - now) / 1000) : 0;\n    return {\n      allowed: false,\n      status: 'blocked',\n      remaining: 0,\n      total: this.config.maxRequests,\n      resetAt: new Date(entry.blockedUntil || now + this.config.windowMs),\n      retryAfter,\n    };\n  }\n\n  // ==========================================================================\n  // Headers\n  // ==========================================================================\n\n  getHeaders(result: RateLimitResult): RateLimitHeaders {\n    const headers: RateLimitHeaders = {\n      'X-RateLimit-Limit': String(result.total),\n      'X-RateLimit-Remaining': String(result.remaining),\n      'X-RateLimit-Reset': String(Math.ceil(result.resetAt.getTime() / 1000)),\n    };\n\n    if (result.retryAfter) {\n      headers['Retry-After'] = String(result.retryAfter);\n    }\n\n    return headers;\n  }\n\n  // ==========================================================================\n  // Utilities\n  // ==========================================================================\n\n  getConfig(): Required<RateLimitConfig> {\n    return { ...this.config };\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createRateLimiter(config: RateLimitConfig, store?: RateLimitStore): RateLimiter {\n  return new RateLimiter(config, store);\n}\n\nexport function createMemoryStore(): MemoryStore {\n  return new MemoryStore();\n}\n\n// ============================================================================\n// Preset Configurations\n// ============================================================================\n\nexport const PRESETS = {\n  /** Strict: 10 requests per minute */\n  strict: {\n    maxRequests: 10,\n    windowMs: 60000,\n    algorithm: 'sliding-window' as const,\n  },\n\n  /** Standard: 100 requests per minute */\n  standard: {\n    maxRequests: 100,\n    windowMs: 60000,\n    algorithm: 'sliding-window' as const,\n  },\n\n  /** Lenient: 1000 requests per minute */\n  lenient: {\n    maxRequests: 1000,\n    windowMs: 60000,\n    algorithm: 'sliding-window' as const,\n  },\n\n  /** API: 100 requests per 15 minutes */\n  api: {\n    maxRequests: 100,\n    windowMs: 900000,\n    algorithm: 'sliding-window' as const,\n  },\n\n  /** Auth: 5 attempts per 15 minutes with blocking */\n  auth: {\n    maxRequests: 5,\n    windowMs: 900000,\n    algorithm: 'sliding-window' as const,\n    blockDuration: 3600000, // 1 hour\n  },\n\n  /** Burst: Token bucket with burst allowance */\n  burst: {\n    maxRequests: 100,\n    windowMs: 60000,\n    algorithm: 'token-bucket' as const,\n    burstLimit: 20,\n  },\n} as const;\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function createKeyGenerator(\n  ...parts: (string | ((req: unknown) => string))[]\n): (req: unknown) => string {\n  return (req: unknown) => {\n    return parts\n      .map(part => (typeof part === 'function' ? part(req) : part))\n      .filter(Boolean)\n      .join(':');\n  };\n}\n\nexport function extractIP(req: unknown): string {\n  const r = req as Record<string, unknown>;\n  const headers = r.headers as Record<string, unknown> | undefined;\n\n  // Check common headers\n  const forwardedFor = r['x-forwarded-for'] || headers?.['x-forwarded-for'];\n  if (typeof forwardedFor === 'string') {\n    return forwardedFor.split(',')[0].trim();\n  }\n\n  const realIP = r['x-real-ip'] || headers?.['x-real-ip'];\n  if (typeof realIP === 'string') {\n    return realIP;\n  }\n\n  // Check socket\n  if (r.socket && typeof (r.socket as { remoteAddress?: string }).remoteAddress === 'string') {\n    return (r.socket as { remoteAddress: string }).remoteAddress;\n  }\n\n  if (typeof r.ip === 'string') {\n    return r.ip;\n  }\n\n  return 'unknown';\n}\n\nexport function isRateLimited(result: RateLimitResult): boolean {\n  return !result.allowed;\n}\n\nexport function formatRetryAfter(seconds: number): string {\n  if (seconds < 60) return `${seconds} second${seconds === 1 ? '' : 's'}`;\n  const minutes = Math.ceil(seconds / 60);\n  return `${minutes} minute${minutes === 1 ? '' : 's'}`;\n}\n"],"mappings":"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","names":[]}