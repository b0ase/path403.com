{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/bitcoin-signing\n *\n * BSV message signing and verification utilities.\n * Provides type-safe interfaces for Bitcoin message signing.\n *\n * @example\n * ```typescript\n * import {\n *   createSigningRequest,\n *   verifySignatureFormat,\n *   formatSignedMessage,\n * } from '@b0ase/bitcoin-signing';\n *\n * // Create a signing request\n * const request = createSigningRequest({\n *   message: 'I agree to the terms of service',\n *   address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',\n *   purpose: 'terms-agreement',\n * });\n *\n * // After signing with wallet\n * const signedMessage = formatSignedMessage({\n *   message: request.message,\n *   address: request.address,\n *   signature: 'H+signature...',\n * });\n * ```\n *\n * Note: Actual cryptographic signing requires @bsv/sdk or wallet integration.\n * This package provides the type-safe wrapper and utilities.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Signature encoding format */\nexport type SignatureEncoding = 'base64' | 'hex' | 'der';\n\n/** Signing algorithm */\nexport type SigningAlgorithm = 'ecdsa' | 'schnorr';\n\n/** Message signing request */\nexport interface SigningRequest {\n  /** Message to sign */\n  message: string;\n  /** Signer's address */\n  address: string;\n  /** Purpose/context for the signature */\n  purpose?: string;\n  /** Timestamp of request */\n  timestamp: Date;\n  /** Nonce for uniqueness */\n  nonce: string;\n  /** Expiry time */\n  expiresAt?: Date;\n}\n\n/** Signed message */\nexport interface SignedMessage {\n  /** Original message */\n  message: string;\n  /** Signer's address */\n  address: string;\n  /** Signature */\n  signature: string;\n  /** Signature encoding */\n  encoding: SignatureEncoding;\n  /** Algorithm used */\n  algorithm: SigningAlgorithm;\n  /** Timestamp when signed */\n  signedAt: Date;\n  /** Public key (if available) */\n  publicKey?: string;\n}\n\n/** Verification result */\nexport interface VerificationResult {\n  /** Is signature valid */\n  valid: boolean;\n  /** Recovered address (if recoverable) */\n  recoveredAddress?: string;\n  /** Address matches */\n  addressMatches?: boolean;\n  /** Error message if invalid */\n  error?: string;\n}\n\n/** Signing options */\nexport interface SigningOptions {\n  /** Signature encoding (default: base64) */\n  encoding?: SignatureEncoding;\n  /** Algorithm (default: ecdsa) */\n  algorithm?: SigningAlgorithm;\n  /** Include timestamp in message */\n  includeTimestamp?: boolean;\n  /** Message prefix */\n  prefix?: string;\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Bitcoin signed message prefix */\nexport const BITCOIN_SIGNED_MESSAGE_PREFIX = 'Bitcoin Signed Message:\\n';\n\n/** BSV signed message prefix */\nexport const BSV_SIGNED_MESSAGE_PREFIX = 'Bitcoin Signed Message:\\n';\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Generate a random nonce\n */\nexport function generateNonce(length: number = 16): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\n/**\n * Create a signing request\n */\nexport function createSigningRequest(options: {\n  message: string;\n  address: string;\n  purpose?: string;\n  expiresInMs?: number;\n}): SigningRequest {\n  const now = new Date();\n  return {\n    message: options.message,\n    address: options.address,\n    purpose: options.purpose,\n    timestamp: now,\n    nonce: generateNonce(),\n    expiresAt: options.expiresInMs\n      ? new Date(now.getTime() + options.expiresInMs)\n      : undefined,\n  };\n}\n\n/**\n * Format message for signing (with optional prefix)\n */\nexport function formatMessageForSigning(\n  message: string,\n  options?: {\n    includeTimestamp?: boolean;\n    includeNonce?: boolean;\n    nonce?: string;\n    prefix?: string;\n  }\n): string {\n  let formatted = message;\n\n  if (options?.prefix) {\n    formatted = `${options.prefix}${formatted}`;\n  }\n\n  if (options?.includeTimestamp) {\n    formatted = `${formatted}\\nTimestamp: ${new Date().toISOString()}`;\n  }\n\n  if (options?.includeNonce) {\n    const nonce = options.nonce || generateNonce();\n    formatted = `${formatted}\\nNonce: ${nonce}`;\n  }\n\n  return formatted;\n}\n\n/**\n * Create a signed message object\n */\nexport function formatSignedMessage(options: {\n  message: string;\n  address: string;\n  signature: string;\n  encoding?: SignatureEncoding;\n  algorithm?: SigningAlgorithm;\n  publicKey?: string;\n}): SignedMessage {\n  return {\n    message: options.message,\n    address: options.address,\n    signature: options.signature,\n    encoding: options.encoding || 'base64',\n    algorithm: options.algorithm || 'ecdsa',\n    signedAt: new Date(),\n    publicKey: options.publicKey,\n  };\n}\n\n/**\n * Verify signature format (not cryptographic verification)\n */\nexport function verifySignatureFormat(\n  signature: string,\n  encoding: SignatureEncoding = 'base64'\n): { valid: boolean; error?: string } {\n  if (!signature || signature.length === 0) {\n    return { valid: false, error: 'Empty signature' };\n  }\n\n  switch (encoding) {\n    case 'base64':\n      // Base64 should only contain these characters\n      if (!/^[A-Za-z0-9+/]+=*$/.test(signature)) {\n        return { valid: false, error: 'Invalid base64 encoding' };\n      }\n      // Bitcoin signatures are typically 65 bytes = 88 base64 chars\n      if (signature.length < 80 || signature.length > 100) {\n        return { valid: false, error: 'Unexpected signature length for base64' };\n      }\n      break;\n\n    case 'hex':\n      if (!/^[0-9a-fA-F]+$/.test(signature)) {\n        return { valid: false, error: 'Invalid hex encoding' };\n      }\n      // 65 bytes = 130 hex chars\n      if (signature.length < 128 || signature.length > 150) {\n        return { valid: false, error: 'Unexpected signature length for hex' };\n      }\n      break;\n\n    case 'der':\n      if (!/^[0-9a-fA-F]+$/.test(signature)) {\n        return { valid: false, error: 'Invalid DER encoding (should be hex)' };\n      }\n      // DER signatures vary in length\n      if (signature.length < 140 || signature.length > 160) {\n        return { valid: false, error: 'Unexpected DER signature length' };\n      }\n      break;\n  }\n\n  return { valid: true };\n}\n\n/**\n * Verify Bitcoin address format\n */\nexport function verifyAddressFormat(address: string): {\n  valid: boolean;\n  type?: 'legacy' | 'bech32' | 'bech32m';\n  error?: string;\n} {\n  if (!address || address.length === 0) {\n    return { valid: false, error: 'Empty address' };\n  }\n\n  // Legacy P2PKH (starts with 1)\n  if (/^1[a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(address)) {\n    return { valid: true, type: 'legacy' };\n  }\n\n  // Legacy P2SH (starts with 3)\n  if (/^3[a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(address)) {\n    return { valid: true, type: 'legacy' };\n  }\n\n  // Bech32 (starts with bc1q)\n  if (/^bc1q[a-z0-9]{38,58}$/.test(address)) {\n    return { valid: true, type: 'bech32' };\n  }\n\n  // Bech32m (starts with bc1p)\n  if (/^bc1p[a-z0-9]{38,58}$/.test(address)) {\n    return { valid: true, type: 'bech32m' };\n  }\n\n  return { valid: false, error: 'Unrecognized address format' };\n}\n\n/**\n * Parse a signed message string (Bitcoin Core format)\n */\nexport function parseSignedMessageString(signedMessageStr: string): {\n  address?: string;\n  message?: string;\n  signature?: string;\n  error?: string;\n} {\n  const lines = signedMessageStr.trim().split('\\n');\n\n  let address: string | undefined;\n  let message: string | undefined;\n  let signature: string | undefined;\n  let inMessage = false;\n  let messageLines: string[] = [];\n\n  for (const line of lines) {\n    if (line.startsWith('-----BEGIN BITCOIN SIGNED MESSAGE-----')) {\n      inMessage = true;\n      continue;\n    }\n    if (line.startsWith('-----BEGIN SIGNATURE-----')) {\n      inMessage = false;\n      message = messageLines.join('\\n');\n      continue;\n    }\n    if (line.startsWith('-----END BITCOIN SIGNED MESSAGE-----')) {\n      continue;\n    }\n    if (inMessage) {\n      messageLines.push(line);\n    } else if (!address && line.length > 0 && !line.startsWith('-----')) {\n      // First non-empty line after BEGIN SIGNATURE is the address\n      address = line;\n    } else if (address && !signature && line.length > 0 && !line.startsWith('-----')) {\n      signature = line;\n    }\n  }\n\n  if (!address || !message || !signature) {\n    return { error: 'Could not parse signed message format' };\n  }\n\n  return { address, message, signature };\n}\n\n/**\n * Format as Bitcoin Core signed message\n */\nexport function formatAsBitcoinSignedMessage(\n  message: string,\n  address: string,\n  signature: string\n): string {\n  return `-----BEGIN BITCOIN SIGNED MESSAGE-----\n${message}\n-----BEGIN SIGNATURE-----\n${address}\n${signature}\n-----END BITCOIN SIGNED MESSAGE-----`;\n}\n\n/**\n * Hash message for signing (double SHA-256 with prefix)\n * Note: This is a placeholder - actual implementation needs crypto library\n */\nexport function getMessageHash(message: string): string {\n  // Format: length(prefix) + prefix + length(message) + message\n  // Then double SHA-256\n  // This is a placeholder - real implementation needs @bsv/sdk\n  const prefixed = `${BSV_SIGNED_MESSAGE_PREFIX}${message}`;\n  return `hash:${prefixed.length}:${message.substring(0, 8)}...`;\n}\n\n/**\n * Create a challenge message for authentication\n */\nexport function createAuthChallenge(options: {\n  domain: string;\n  address: string;\n  action?: string;\n  expiresInMs?: number;\n}): {\n  challenge: string;\n  request: SigningRequest;\n} {\n  const nonce = generateNonce(32);\n  const timestamp = new Date().toISOString();\n  const action = options.action || 'authenticate';\n\n  const challenge = [\n    `${options.domain} wants you to sign in with your Bitcoin address:`,\n    options.address,\n    '',\n    `Action: ${action}`,\n    `Nonce: ${nonce}`,\n    `Issued At: ${timestamp}`,\n  ].join('\\n');\n\n  const request = createSigningRequest({\n    message: challenge,\n    address: options.address,\n    purpose: action,\n    expiresInMs: options.expiresInMs || 5 * 60 * 1000, // 5 minutes default\n  });\n\n  return { challenge, request };\n}\n"],"mappings":"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","names":[]}