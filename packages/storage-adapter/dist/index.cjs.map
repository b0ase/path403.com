{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/storage-adapter\n *\n * Unified storage interface for localStorage, sessionStorage, IndexedDB, and memory.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Storage adapter interface */\nexport interface StorageAdapter {\n  get<T>(key: string): Promise<T | null>;\n  set<T>(key: string, value: T, options?: StorageOptions): Promise<void>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n  keys(): Promise<string[]>;\n  has(key: string): Promise<boolean>;\n}\n\n/** Storage options */\nexport interface StorageOptions {\n  ttl?: number; // Time to live in milliseconds\n  namespace?: string;\n}\n\n/** Stored item wrapper with metadata */\ninterface StoredItem<T> {\n  value: T;\n  expires?: number;\n  createdAt: number;\n}\n\n// ============================================================================\n// Memory Storage Adapter\n// ============================================================================\n\nexport class MemoryStorageAdapter implements StorageAdapter {\n  private store = new Map<string, StoredItem<unknown>>();\n  private namespace: string;\n\n  constructor(namespace: string = '') {\n    this.namespace = namespace;\n  }\n\n  private getKey(key: string): string {\n    return this.namespace ? `${this.namespace}:${key}` : key;\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    const fullKey = this.getKey(key);\n    const item = this.store.get(fullKey) as StoredItem<T> | undefined;\n\n    if (!item) return null;\n\n    if (item.expires && Date.now() > item.expires) {\n      this.store.delete(fullKey);\n      return null;\n    }\n\n    return item.value;\n  }\n\n  async set<T>(key: string, value: T, options?: StorageOptions): Promise<void> {\n    const fullKey = this.getKey(key);\n    const item: StoredItem<T> = {\n      value,\n      createdAt: Date.now(),\n      expires: options?.ttl ? Date.now() + options.ttl : undefined,\n    };\n    this.store.set(fullKey, item);\n  }\n\n  async delete(key: string): Promise<void> {\n    this.store.delete(this.getKey(key));\n  }\n\n  async clear(): Promise<void> {\n    if (this.namespace) {\n      for (const key of this.store.keys()) {\n        if (key.startsWith(`${this.namespace}:`)) {\n          this.store.delete(key);\n        }\n      }\n    } else {\n      this.store.clear();\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    const prefix = this.namespace ? `${this.namespace}:` : '';\n    const result: string[] = [];\n\n    for (const key of this.store.keys()) {\n      if (!this.namespace || key.startsWith(prefix)) {\n        result.push(this.namespace ? key.slice(prefix.length) : key);\n      }\n    }\n\n    return result;\n  }\n\n  async has(key: string): Promise<boolean> {\n    const value = await this.get(key);\n    return value !== null;\n  }\n}\n\n// ============================================================================\n// Web Storage Adapter (localStorage / sessionStorage)\n// ============================================================================\n\nexport class WebStorageAdapter implements StorageAdapter {\n  private storage: Storage;\n  private namespace: string;\n\n  constructor(storage: Storage, namespace: string = '') {\n    this.storage = storage;\n    this.namespace = namespace;\n  }\n\n  private getKey(key: string): string {\n    return this.namespace ? `${this.namespace}:${key}` : key;\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    const fullKey = this.getKey(key);\n    const raw = this.storage.getItem(fullKey);\n\n    if (!raw) return null;\n\n    try {\n      const item = JSON.parse(raw) as StoredItem<T>;\n\n      if (item.expires && Date.now() > item.expires) {\n        this.storage.removeItem(fullKey);\n        return null;\n      }\n\n      return item.value;\n    } catch {\n      return null;\n    }\n  }\n\n  async set<T>(key: string, value: T, options?: StorageOptions): Promise<void> {\n    const fullKey = this.getKey(key);\n    const item: StoredItem<T> = {\n      value,\n      createdAt: Date.now(),\n      expires: options?.ttl ? Date.now() + options.ttl : undefined,\n    };\n    this.storage.setItem(fullKey, JSON.stringify(item));\n  }\n\n  async delete(key: string): Promise<void> {\n    this.storage.removeItem(this.getKey(key));\n  }\n\n  async clear(): Promise<void> {\n    if (this.namespace) {\n      const prefix = `${this.namespace}:`;\n      const keysToDelete: string[] = [];\n\n      for (let i = 0; i < this.storage.length; i++) {\n        const key = this.storage.key(i);\n        if (key && key.startsWith(prefix)) {\n          keysToDelete.push(key);\n        }\n      }\n\n      for (const key of keysToDelete) {\n        this.storage.removeItem(key);\n      }\n    } else {\n      this.storage.clear();\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    const prefix = this.namespace ? `${this.namespace}:` : '';\n    const result: string[] = [];\n\n    for (let i = 0; i < this.storage.length; i++) {\n      const key = this.storage.key(i);\n      if (key && (!this.namespace || key.startsWith(prefix))) {\n        result.push(this.namespace ? key.slice(prefix.length) : key);\n      }\n    }\n\n    return result;\n  }\n\n  async has(key: string): Promise<boolean> {\n    const value = await this.get(key);\n    return value !== null;\n  }\n}\n\n// ============================================================================\n// IndexedDB Storage Adapter\n// ============================================================================\n\nexport class IndexedDBAdapter implements StorageAdapter {\n  private dbName: string;\n  private storeName: string;\n  private db: IDBDatabase | null = null;\n  private namespace: string;\n\n  constructor(dbName: string = 'b0ase-storage', storeName: string = 'keyvalue', namespace: string = '') {\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.namespace = namespace;\n  }\n\n  private getKey(key: string): string {\n    return this.namespace ? `${this.namespace}:${key}` : key;\n  }\n\n  private async getDB(): Promise<IDBDatabase> {\n    if (this.db) return this.db;\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onerror = () => reject(request.error);\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n\n      request.onupgradeneeded = () => {\n        const db = request.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: 'key' });\n        }\n      };\n    });\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    const db = await this.getDB();\n    const fullKey = this.getKey(key);\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(fullKey);\n\n      request.onerror = () => reject(request.error);\n\n      request.onsuccess = () => {\n        const result = request.result as { key: string; item: StoredItem<T> } | undefined;\n\n        if (!result) {\n          resolve(null);\n          return;\n        }\n\n        if (result.item.expires && Date.now() > result.item.expires) {\n          this.delete(key);\n          resolve(null);\n          return;\n        }\n\n        resolve(result.item.value);\n      };\n    });\n  }\n\n  async set<T>(key: string, value: T, options?: StorageOptions): Promise<void> {\n    const db = await this.getDB();\n    const fullKey = this.getKey(key);\n\n    const item: StoredItem<T> = {\n      value,\n      createdAt: Date.now(),\n      expires: options?.ttl ? Date.now() + options.ttl : undefined,\n    };\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({ key: fullKey, item });\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async delete(key: string): Promise<void> {\n    const db = await this.getDB();\n    const fullKey = this.getKey(key);\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(fullKey);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async clear(): Promise<void> {\n    if (this.namespace) {\n      const keys = await this.keys();\n      for (const key of keys) {\n        await this.delete(key);\n      }\n    } else {\n      const db = await this.getDB();\n\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(this.storeName, 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.clear();\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    const db = await this.getDB();\n    const prefix = this.namespace ? `${this.namespace}:` : '';\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.getAllKeys();\n\n      request.onerror = () => reject(request.error);\n\n      request.onsuccess = () => {\n        const allKeys = request.result as string[];\n        const result = allKeys\n          .filter((key) => !this.namespace || key.startsWith(prefix))\n          .map((key) => (this.namespace ? key.slice(prefix.length) : key));\n        resolve(result);\n      };\n    });\n  }\n\n  async has(key: string): Promise<boolean> {\n    const value = await this.get(key);\n    return value !== null;\n  }\n\n  close(): void {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n}\n\n// ============================================================================\n// Unified Storage Manager\n// ============================================================================\n\nexport type StorageType = 'memory' | 'local' | 'session' | 'indexeddb';\n\nexport interface StorageManagerOptions {\n  type?: StorageType;\n  namespace?: string;\n  fallback?: StorageType;\n}\n\nexport class StorageManager implements StorageAdapter {\n  private adapter: StorageAdapter;\n\n  constructor(options: StorageManagerOptions = {}) {\n    this.adapter = createStorageAdapter(options);\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    return this.adapter.get<T>(key);\n  }\n\n  async set<T>(key: string, value: T, options?: StorageOptions): Promise<void> {\n    return this.adapter.set(key, value, options);\n  }\n\n  async delete(key: string): Promise<void> {\n    return this.adapter.delete(key);\n  }\n\n  async clear(): Promise<void> {\n    return this.adapter.clear();\n  }\n\n  async keys(): Promise<string[]> {\n    return this.adapter.keys();\n  }\n\n  async has(key: string): Promise<boolean> {\n    return this.adapter.has(key);\n  }\n\n  // ==========================================================================\n  // Utility Methods\n  // ==========================================================================\n\n  async getOrSet<T>(key: string, factory: () => T | Promise<T>, options?: StorageOptions): Promise<T> {\n    const existing = await this.get<T>(key);\n    if (existing !== null) return existing;\n\n    const value = await factory();\n    await this.set(key, value, options);\n    return value;\n  }\n\n  async update<T>(key: string, updater: (current: T | null) => T): Promise<T> {\n    const current = await this.get<T>(key);\n    const updated = updater(current);\n    await this.set(key, updated);\n    return updated;\n  }\n\n  async increment(key: string, amount: number = 1): Promise<number> {\n    return this.update<number>(key, (current) => (current || 0) + amount);\n  }\n\n  async decrement(key: string, amount: number = 1): Promise<number> {\n    return this.update<number>(key, (current) => (current || 0) - amount);\n  }\n\n  async append<T>(key: string, item: T): Promise<T[]> {\n    return this.update<T[]>(key, (current) => [...(current || []), item]);\n  }\n\n  async getMultiple<T>(keys: string[]): Promise<Map<string, T | null>> {\n    const results = new Map<string, T | null>();\n    for (const key of keys) {\n      results.set(key, await this.get<T>(key));\n    }\n    return results;\n  }\n\n  async setMultiple<T>(entries: Array<[string, T]>, options?: StorageOptions): Promise<void> {\n    for (const [key, value] of entries) {\n      await this.set(key, value, options);\n    }\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nfunction isStorageAvailable(type: 'localStorage' | 'sessionStorage'): boolean {\n  if (typeof window === 'undefined') return false;\n\n  try {\n    const storage = window[type];\n    const testKey = '__storage_test__';\n    storage.setItem(testKey, testKey);\n    storage.removeItem(testKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isIndexedDBAvailable(): boolean {\n  if (typeof window === 'undefined') return false;\n  return typeof indexedDB !== 'undefined';\n}\n\nexport function createStorageAdapter(options: StorageManagerOptions = {}): StorageAdapter {\n  const { type = 'memory', namespace = '', fallback = 'memory' } = options;\n\n  const createAdapter = (storageType: StorageType): StorageAdapter | null => {\n    switch (storageType) {\n      case 'local':\n        if (isStorageAvailable('localStorage')) {\n          return new WebStorageAdapter(localStorage, namespace);\n        }\n        return null;\n\n      case 'session':\n        if (isStorageAvailable('sessionStorage')) {\n          return new WebStorageAdapter(sessionStorage, namespace);\n        }\n        return null;\n\n      case 'indexeddb':\n        if (isIndexedDBAvailable()) {\n          return new IndexedDBAdapter('b0ase-storage', 'keyvalue', namespace);\n        }\n        return null;\n\n      case 'memory':\n      default:\n        return new MemoryStorageAdapter(namespace);\n    }\n  };\n\n  const adapter = createAdapter(type);\n  if (adapter) return adapter;\n\n  const fallbackAdapter = createAdapter(fallback);\n  if (fallbackAdapter) return fallbackAdapter;\n\n  return new MemoryStorageAdapter(namespace);\n}\n\nexport function createStorageManager(options?: StorageManagerOptions): StorageManager {\n  return new StorageManager(options);\n}\n\n// ============================================================================\n// Singleton Instances\n// ============================================================================\n\nlet defaultStorage: StorageManager | null = null;\n\nexport function getStorage(options?: StorageManagerOptions): StorageManager {\n  if (!defaultStorage) {\n    defaultStorage = createStorageManager(options);\n  }\n  return defaultStorage;\n}\n\nexport function resetStorage(): void {\n  defaultStorage = null;\n}\n"],"mappings":"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","names":[]}