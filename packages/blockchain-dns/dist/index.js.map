{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/blockchain-dns\n *\n * Decentralized domain resolver with blockchain-based DNS records.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** DNS record types */\nexport type RecordType = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'MX' | 'NS' | 'SOA' | 'SRV' | 'CAA' | 'ALIAS' | 'BSVALIAS';\n\n/** DNS record */\nexport interface DNSRecord {\n  type: RecordType;\n  name: string;\n  value: string;\n  ttl: number;\n  priority?: number;\n  weight?: number;\n  port?: number;\n}\n\n/** Domain info */\nexport interface Domain {\n  name: string;\n  owner: string;\n  registeredAt: number;\n  expiresAt: number;\n  records: DNSRecord[];\n  metadata?: DomainMetadata;\n  txid?: string;\n}\n\n/** Domain metadata */\nexport interface DomainMetadata {\n  title?: string;\n  description?: string;\n  avatar?: string;\n  website?: string;\n  social?: Record<string, string>;\n  custom?: Record<string, string>;\n}\n\n/** Resolution result */\nexport interface ResolutionResult {\n  domain: string;\n  records: DNSRecord[];\n  resolved: boolean;\n  source: 'blockchain' | 'cache' | 'traditional';\n  ttl: number;\n  timestamp: number;\n}\n\n/** Resolver options */\nexport interface ResolverOptions {\n  cacheEnabled?: boolean;\n  cacheTtl?: number;\n  fallbackEnabled?: boolean;\n  traditionalDns?: string;\n  timeout?: number;\n}\n\n/** Registration params */\nexport interface RegisterParams {\n  name: string;\n  owner: string;\n  years?: number;\n  records?: DNSRecord[];\n  metadata?: DomainMetadata;\n}\n\n/** TLD info */\nexport interface TLD {\n  name: string;\n  registrationFee: number;\n  renewalFee: number;\n  minLength: number;\n  maxLength: number;\n  allowedChars: string;\n  reserved: string[];\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Supported blockchain TLDs */\nexport const BLOCKCHAIN_TLDS: TLD[] = [\n  {\n    name: '.bit',\n    registrationFee: 10000, // satoshis\n    renewalFee: 5000,\n    minLength: 3,\n    maxLength: 63,\n    allowedChars: 'a-z0-9-',\n    reserved: ['www', 'mail', 'ftp', 'api'],\n  },\n  {\n    name: '.bsv',\n    registrationFee: 50000,\n    renewalFee: 25000,\n    minLength: 3,\n    maxLength: 63,\n    allowedChars: 'a-z0-9-',\n    reserved: ['satoshi', 'bitcoin', 'bsv'],\n  },\n  {\n    name: '.sats',\n    registrationFee: 21000,\n    renewalFee: 10000,\n    minLength: 1,\n    maxLength: 63,\n    allowedChars: 'a-z0-9-',\n    reserved: [],\n  },\n];\n\n/** Default resolver options */\nexport const DEFAULT_OPTIONS: Required<ResolverOptions> = {\n  cacheEnabled: true,\n  cacheTtl: 3600000, // 1 hour\n  fallbackEnabled: true,\n  traditionalDns: '8.8.8.8',\n  timeout: 10000,\n};\n\n// ============================================================================\n// DNS Cache\n// ============================================================================\n\ninterface CacheEntry {\n  result: ResolutionResult;\n  expiresAt: number;\n}\n\nexport class DNSCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private defaultTtl: number;\n\n  constructor(defaultTtl: number = 3600000) {\n    this.defaultTtl = defaultTtl;\n  }\n\n  get(key: string): ResolutionResult | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.result;\n  }\n\n  set(key: string, result: ResolutionResult, ttl?: number): void {\n    this.cache.set(key, {\n      result,\n      expiresAt: Date.now() + (ttl || this.defaultTtl),\n    });\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  prune(): number {\n    const now = Date.now();\n    let pruned = 0;\n\n    for (const [key, entry] of this.cache) {\n      if (now > entry.expiresAt) {\n        this.cache.delete(key);\n        pruned++;\n      }\n    }\n\n    return pruned;\n  }\n}\n\n// ============================================================================\n// Blockchain DNS Resolver\n// ============================================================================\n\nexport class BlockchainDNS {\n  private options: Required<ResolverOptions>;\n  private cache: DNSCache;\n  private domains: Map<string, Domain> = new Map();\n  private listeners: Map<string, Set<(domain: Domain) => void>> = new Map();\n\n  constructor(options: ResolverOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = new DNSCache(this.options.cacheTtl);\n  }\n\n  // ==========================================================================\n  // Resolution\n  // ==========================================================================\n\n  async resolve(name: string, type?: RecordType): Promise<ResolutionResult> {\n    const normalizedName = this.normalizeName(name);\n    const cacheKey = `${normalizedName}:${type || 'ALL'}`;\n\n    // Check cache\n    if (this.options.cacheEnabled) {\n      const cached = this.cache.get(cacheKey);\n      if (cached) {\n        return { ...cached, source: 'cache' };\n      }\n    }\n\n    // Try blockchain resolution\n    const domain = await this.lookupBlockchain(normalizedName);\n\n    if (domain) {\n      const records = type\n        ? domain.records.filter((r) => r.type === type)\n        : domain.records;\n\n      const result: ResolutionResult = {\n        domain: normalizedName,\n        records,\n        resolved: records.length > 0,\n        source: 'blockchain',\n        ttl: Math.min(...records.map((r) => r.ttl), 3600),\n        timestamp: Date.now(),\n      };\n\n      if (this.options.cacheEnabled) {\n        this.cache.set(cacheKey, result, result.ttl * 1000);\n      }\n\n      return result;\n    }\n\n    // Fallback to traditional DNS\n    if (this.options.fallbackEnabled && !this.isBlockchainTld(normalizedName)) {\n      return this.resolveTraditional(normalizedName, type);\n    }\n\n    return {\n      domain: normalizedName,\n      records: [],\n      resolved: false,\n      source: 'blockchain',\n      ttl: 0,\n      timestamp: Date.now(),\n    };\n  }\n\n  async resolveIP(name: string): Promise<string | null> {\n    const result = await this.resolve(name, 'A');\n    return result.records[0]?.value || null;\n  }\n\n  async resolveTXT(name: string): Promise<string[]> {\n    const result = await this.resolve(name, 'TXT');\n    return result.records.map((r) => r.value);\n  }\n\n  async resolveBSVAlias(name: string): Promise<string | null> {\n    const result = await this.resolve(name, 'BSVALIAS');\n    return result.records[0]?.value || null;\n  }\n\n  private async lookupBlockchain(name: string): Promise<Domain | null> {\n    // In production, this would query the blockchain\n    // For now, use local registry\n    return this.domains.get(name) || null;\n  }\n\n  private async resolveTraditional(name: string, type?: RecordType): Promise<ResolutionResult> {\n    // In browser, use DNS-over-HTTPS\n    try {\n      const url = `https://dns.google/resolve?name=${encodeURIComponent(name)}${type ? `&type=${type}` : ''}`;\n      const response = await fetch(url);\n      const data = await response.json();\n\n      const records: DNSRecord[] = (data.Answer || []).map((answer: { type: number; name: string; data: string; TTL: number }) => ({\n        type: this.numericToRecordType(answer.type),\n        name: answer.name,\n        value: answer.data,\n        ttl: answer.TTL,\n      }));\n\n      return {\n        domain: name,\n        records,\n        resolved: records.length > 0,\n        source: 'traditional',\n        ttl: Math.min(...records.map((r) => r.ttl), 3600),\n        timestamp: Date.now(),\n      };\n    } catch {\n      return {\n        domain: name,\n        records: [],\n        resolved: false,\n        source: 'traditional',\n        ttl: 0,\n        timestamp: Date.now(),\n      };\n    }\n  }\n\n  // ==========================================================================\n  // Domain Registration\n  // ==========================================================================\n\n  async register(params: RegisterParams): Promise<Domain> {\n    const name = this.normalizeName(params.name);\n\n    if (this.domains.has(name)) {\n      throw new Error('Domain already registered');\n    }\n\n    this.validateDomainName(name);\n\n    const domain: Domain = {\n      name,\n      owner: params.owner,\n      registeredAt: Date.now(),\n      expiresAt: Date.now() + (params.years || 1) * 365 * 24 * 60 * 60 * 1000,\n      records: params.records || [],\n      metadata: params.metadata,\n    };\n\n    this.domains.set(name, domain);\n    this.emit(name, domain);\n\n    return domain;\n  }\n\n  async renew(name: string, years: number = 1): Promise<Domain> {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) {\n      throw new Error('Domain not found');\n    }\n\n    domain.expiresAt += years * 365 * 24 * 60 * 60 * 1000;\n    this.emit(normalizedName, domain);\n\n    return domain;\n  }\n\n  async transfer(name: string, newOwner: string): Promise<Domain> {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) {\n      throw new Error('Domain not found');\n    }\n\n    domain.owner = newOwner;\n    this.emit(normalizedName, domain);\n\n    return domain;\n  }\n\n  // ==========================================================================\n  // Record Management\n  // ==========================================================================\n\n  async addRecord(name: string, record: DNSRecord): Promise<Domain> {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) {\n      throw new Error('Domain not found');\n    }\n\n    domain.records.push(record);\n    this.cache.delete(`${normalizedName}:${record.type}`);\n    this.cache.delete(`${normalizedName}:ALL`);\n    this.emit(normalizedName, domain);\n\n    return domain;\n  }\n\n  async removeRecord(name: string, recordType: RecordType, value?: string): Promise<Domain> {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) {\n      throw new Error('Domain not found');\n    }\n\n    domain.records = domain.records.filter((r) => {\n      if (r.type !== recordType) return true;\n      if (value && r.value !== value) return true;\n      return false;\n    });\n\n    this.cache.delete(`${normalizedName}:${recordType}`);\n    this.cache.delete(`${normalizedName}:ALL`);\n    this.emit(normalizedName, domain);\n\n    return domain;\n  }\n\n  async updateMetadata(name: string, metadata: Partial<DomainMetadata>): Promise<Domain> {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) {\n      throw new Error('Domain not found');\n    }\n\n    domain.metadata = { ...domain.metadata, ...metadata };\n    this.emit(normalizedName, domain);\n\n    return domain;\n  }\n\n  // ==========================================================================\n  // Queries\n  // ==========================================================================\n\n  getDomain(name: string): Domain | undefined {\n    return this.domains.get(this.normalizeName(name));\n  }\n\n  getDomainsByOwner(owner: string): Domain[] {\n    return Array.from(this.domains.values()).filter((d) => d.owner === owner);\n  }\n\n  isAvailable(name: string): boolean {\n    const normalizedName = this.normalizeName(name);\n    const domain = this.domains.get(normalizedName);\n\n    if (!domain) return true;\n    return Date.now() > domain.expiresAt;\n  }\n\n  // ==========================================================================\n  // Events\n  // ==========================================================================\n\n  on(name: string, callback: (domain: Domain) => void): () => void {\n    const normalizedName = this.normalizeName(name);\n    if (!this.listeners.has(normalizedName)) {\n      this.listeners.set(normalizedName, new Set());\n    }\n    this.listeners.get(normalizedName)!.add(callback);\n    return () => this.off(normalizedName, callback);\n  }\n\n  off(name: string, callback: (domain: Domain) => void): void {\n    this.listeners.get(name)?.delete(callback);\n  }\n\n  private emit(name: string, domain: Domain): void {\n    const callbacks = this.listeners.get(name);\n    if (callbacks) {\n      for (const callback of callbacks) {\n        callback(domain);\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Helpers\n  // ==========================================================================\n\n  private normalizeName(name: string): string {\n    return name.toLowerCase().trim();\n  }\n\n  private isBlockchainTld(name: string): boolean {\n    return BLOCKCHAIN_TLDS.some((tld) => name.endsWith(tld.name));\n  }\n\n  private validateDomainName(name: string): void {\n    const tld = BLOCKCHAIN_TLDS.find((t) => name.endsWith(t.name));\n    if (!tld) {\n      throw new Error('Unsupported TLD');\n    }\n\n    const label = name.replace(tld.name, '');\n    if (label.length < tld.minLength || label.length > tld.maxLength) {\n      throw new Error(`Domain name must be ${tld.minLength}-${tld.maxLength} characters`);\n    }\n\n    if (tld.reserved.includes(label)) {\n      throw new Error('Domain name is reserved');\n    }\n\n    const allowedRegex = new RegExp(`^[${tld.allowedChars}]+$`);\n    if (!allowedRegex.test(label)) {\n      throw new Error('Domain name contains invalid characters');\n    }\n  }\n\n  private numericToRecordType(num: number): RecordType {\n    const types: Record<number, RecordType> = {\n      1: 'A',\n      5: 'CNAME',\n      15: 'MX',\n      16: 'TXT',\n      28: 'AAAA',\n      33: 'SRV',\n    };\n    return types[num] || 'TXT';\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createBlockchainDNS(options?: ResolverOptions): BlockchainDNS {\n  return new BlockchainDNS(options);\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Parse domain into labels\n */\nexport function parseDomain(domain: string): { labels: string[]; tld: string } {\n  const parts = domain.split('.');\n  const tld = '.' + parts.pop();\n  return { labels: parts, tld };\n}\n\n/**\n * Check if domain is valid\n */\nexport function isValidDomain(domain: string): boolean {\n  const regex = /^[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z]{2,})+$/i;\n  return regex.test(domain);\n}\n\n/**\n * Create A record\n */\nexport function createARecord(name: string, ip: string, ttl: number = 3600): DNSRecord {\n  return { type: 'A', name, value: ip, ttl };\n}\n\n/**\n * Create TXT record\n */\nexport function createTXTRecord(name: string, text: string, ttl: number = 3600): DNSRecord {\n  return { type: 'TXT', name, value: text, ttl };\n}\n\n/**\n * Create BSVALIAS record (paymail)\n */\nexport function createBSVAliasRecord(name: string, paymail: string, ttl: number = 3600): DNSRecord {\n  return { type: 'BSVALIAS', name, value: paymail, ttl };\n}\n"],"mappings":"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","names":[]}