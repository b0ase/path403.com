{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/token-distributor\n *\n * Batch token distribution and airdrop management.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Distribution type */\nexport type DistributionType =\n  | 'equal'\n  | 'proportional'\n  | 'fixed'\n  | 'weighted'\n  | 'random'\n  | 'tiered';\n\n/** Distribution status */\nexport type DistributionStatus =\n  | 'draft'\n  | 'scheduled'\n  | 'processing'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n\n/** Recipient status */\nexport type RecipientStatus =\n  | 'pending'\n  | 'processing'\n  | 'sent'\n  | 'confirmed'\n  | 'failed';\n\n/** Recipient */\nexport interface Recipient {\n  id: string;\n  address: string;\n  email?: string;\n  name?: string;\n  amount: bigint;\n  weight?: number;\n  tier?: string;\n  status: RecipientStatus;\n  txid?: string;\n  error?: string;\n  processedAt?: Date;\n  metadata?: Record<string, unknown>;\n}\n\n/** Distribution */\nexport interface Distribution {\n  id: string;\n  name: string;\n  description?: string;\n  tokenId: string;\n  tokenSymbol: string;\n  totalAmount: bigint;\n  distributedAmount: bigint;\n  type: DistributionType;\n  status: DistributionStatus;\n  recipients: Recipient[];\n  scheduledAt?: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  createdBy: string;\n  createdAt: Date;\n  updatedAt: Date;\n  settings: DistributionSettings;\n  metadata?: Record<string, unknown>;\n}\n\n/** Distribution settings */\nexport interface DistributionSettings {\n  batchSize: number;\n  retryAttempts: number;\n  retryDelay: number;\n  minConfirmations?: number;\n  allowDuplicates: boolean;\n  validateAddresses: boolean;\n  notifyRecipients: boolean;\n  expiresAt?: Date;\n}\n\n/** Tier definition */\nexport interface TierDefinition {\n  name: string;\n  minAmount?: bigint;\n  maxAmount?: bigint;\n  percentage?: number;\n  fixedAmount?: bigint;\n}\n\n/** Distribution config */\nexport interface DistributionConfig {\n  name: string;\n  tokenId: string;\n  tokenSymbol: string;\n  type: DistributionType;\n  totalAmount: bigint;\n  recipients: RecipientInput[];\n  settings?: Partial<DistributionSettings>;\n  tiers?: TierDefinition[];\n  scheduledAt?: Date;\n}\n\n/** Recipient input */\nexport interface RecipientInput {\n  address: string;\n  email?: string;\n  name?: string;\n  amount?: bigint;\n  weight?: number;\n  tier?: string;\n}\n\n/** Distribution progress */\nexport interface DistributionProgress {\n  total: number;\n  pending: number;\n  processing: number;\n  sent: number;\n  confirmed: number;\n  failed: number;\n  percentage: number;\n}\n\n/** Batch result */\nexport interface BatchResult {\n  batchIndex: number;\n  recipients: Recipient[];\n  successCount: number;\n  failCount: number;\n  txids: string[];\n}\n\n/** Distribution summary */\nexport interface DistributionSummary {\n  id: string;\n  name: string;\n  status: DistributionStatus;\n  tokenSymbol: string;\n  totalAmount: string;\n  recipientCount: number;\n  progress: DistributionProgress;\n  createdAt: Date;\n  completedAt?: Date;\n}\n\n// ============================================================================\n// Default Settings\n// ============================================================================\n\nexport const DEFAULT_SETTINGS: DistributionSettings = {\n  batchSize: 100,\n  retryAttempts: 3,\n  retryDelay: 5000,\n  minConfirmations: 1,\n  allowDuplicates: false,\n  validateAddresses: true,\n  notifyRecipients: false,\n};\n\n// ============================================================================\n// Token Distributor\n// ============================================================================\n\nexport class TokenDistributor {\n  private distributions: Map<string, Distribution> = new Map();\n  private sendCallback?: (recipient: Recipient, tokenId: string) => Promise<string>;\n\n  /**\n   * Set the send callback for executing transfers\n   */\n  setSendCallback(callback: (recipient: Recipient, tokenId: string) => Promise<string>): void {\n    this.sendCallback = callback;\n  }\n\n  /**\n   * Create a new distribution\n   */\n  createDistribution(config: DistributionConfig, createdBy: string): Distribution {\n    const id = this.generateId('dist');\n    const settings = { ...DEFAULT_SETTINGS, ...config.settings };\n\n    // Calculate amounts based on distribution type\n    const recipients = this.calculateAmounts(\n      config.recipients,\n      config.type,\n      config.totalAmount,\n      config.tiers\n    );\n\n    const distribution: Distribution = {\n      id,\n      name: config.name,\n      tokenId: config.tokenId,\n      tokenSymbol: config.tokenSymbol,\n      totalAmount: config.totalAmount,\n      distributedAmount: BigInt(0),\n      type: config.type,\n      status: config.scheduledAt ? 'scheduled' : 'draft',\n      recipients,\n      scheduledAt: config.scheduledAt,\n      createdBy,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      settings,\n    };\n\n    this.distributions.set(id, distribution);\n    return distribution;\n  }\n\n  /**\n   * Calculate amounts for each recipient\n   */\n  private calculateAmounts(\n    inputs: RecipientInput[],\n    type: DistributionType,\n    totalAmount: bigint,\n    tiers?: TierDefinition[]\n  ): Recipient[] {\n    const recipients: Recipient[] = inputs.map(input => ({\n      id: this.generateId('rcpt'),\n      address: input.address,\n      email: input.email,\n      name: input.name,\n      amount: BigInt(0),\n      weight: input.weight,\n      tier: input.tier,\n      status: 'pending',\n    }));\n\n    switch (type) {\n      case 'equal': {\n        const equalAmount = totalAmount / BigInt(recipients.length);\n        for (const r of recipients) {\n          r.amount = equalAmount;\n        }\n        break;\n      }\n\n      case 'fixed': {\n        for (let i = 0; i < recipients.length; i++) {\n          recipients[i].amount = inputs[i].amount || BigInt(0);\n        }\n        break;\n      }\n\n      case 'weighted': {\n        const totalWeight = inputs.reduce((sum, i) => sum + (i.weight || 1), 0);\n        for (let i = 0; i < recipients.length; i++) {\n          const weight = inputs[i].weight || 1;\n          recipients[i].amount = (totalAmount * BigInt(Math.floor(weight * 1000))) /\n            BigInt(Math.floor(totalWeight * 1000));\n        }\n        break;\n      }\n\n      case 'proportional': {\n        const totalInputAmount = inputs.reduce(\n          (sum, i) => sum + (i.amount || BigInt(0)),\n          BigInt(0)\n        );\n        if (totalInputAmount > BigInt(0)) {\n          for (let i = 0; i < recipients.length; i++) {\n            const inputAmount = inputs[i].amount || BigInt(0);\n            recipients[i].amount = (totalAmount * inputAmount) / totalInputAmount;\n          }\n        }\n        break;\n      }\n\n      case 'tiered': {\n        if (!tiers) break;\n        for (let i = 0; i < recipients.length; i++) {\n          const tierName = inputs[i].tier;\n          const tier = tiers.find(t => t.name === tierName);\n          if (tier) {\n            if (tier.fixedAmount) {\n              recipients[i].amount = tier.fixedAmount;\n            } else if (tier.percentage) {\n              recipients[i].amount = (totalAmount * BigInt(Math.floor(tier.percentage * 100))) / BigInt(10000);\n            }\n          }\n        }\n        break;\n      }\n\n      case 'random': {\n        let remaining = totalAmount;\n        const shuffled = [...recipients].sort(() => Math.random() - 0.5);\n        for (let i = 0; i < shuffled.length - 1; i++) {\n          const maxAmount = remaining / BigInt(shuffled.length - i);\n          const randomAmount = BigInt(Math.floor(Math.random() * Number(maxAmount * BigInt(2))));\n          shuffled[i].amount = randomAmount > remaining ? remaining : randomAmount;\n          remaining -= shuffled[i].amount;\n        }\n        shuffled[shuffled.length - 1].amount = remaining;\n        break;\n      }\n    }\n\n    return recipients;\n  }\n\n  /**\n   * Start a distribution\n   */\n  async startDistribution(distributionId: string): Promise<void> {\n    const distribution = this.distributions.get(distributionId);\n    if (!distribution) {\n      throw new Error(`Distribution not found: ${distributionId}`);\n    }\n\n    if (distribution.status !== 'draft' && distribution.status !== 'scheduled') {\n      throw new Error(`Cannot start distribution with status: ${distribution.status}`);\n    }\n\n    if (!this.sendCallback) {\n      throw new Error('Send callback not configured');\n    }\n\n    distribution.status = 'processing';\n    distribution.startedAt = new Date();\n    distribution.updatedAt = new Date();\n\n    await this.processDistribution(distribution);\n  }\n\n  /**\n   * Process distribution in batches\n   */\n  private async processDistribution(distribution: Distribution): Promise<void> {\n    const { recipients, settings, tokenId } = distribution;\n    const batches = this.createBatches(recipients, settings.batchSize);\n\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      await this.processBatch(distribution, batch, i);\n\n      // Check if cancelled\n      if (distribution.status === 'cancelled') {\n        break;\n      }\n    }\n\n    // Update final status\n    const failedCount = recipients.filter(r => r.status === 'failed').length;\n    distribution.status = failedCount === recipients.length ? 'failed' : 'completed';\n    distribution.completedAt = new Date();\n    distribution.updatedAt = new Date();\n    distribution.distributedAmount = recipients\n      .filter(r => r.status === 'confirmed' || r.status === 'sent')\n      .reduce((sum, r) => sum + r.amount, BigInt(0));\n  }\n\n  /**\n   * Process a single batch\n   */\n  private async processBatch(\n    distribution: Distribution,\n    batch: Recipient[],\n    batchIndex: number\n  ): Promise<BatchResult> {\n    const result: BatchResult = {\n      batchIndex,\n      recipients: batch,\n      successCount: 0,\n      failCount: 0,\n      txids: [],\n    };\n\n    for (const recipient of batch) {\n      recipient.status = 'processing';\n\n      for (let attempt = 0; attempt < distribution.settings.retryAttempts; attempt++) {\n        try {\n          const txid = await this.sendCallback!(recipient, distribution.tokenId);\n          recipient.txid = txid;\n          recipient.status = 'sent';\n          recipient.processedAt = new Date();\n          result.successCount++;\n          result.txids.push(txid);\n          break;\n        } catch (error) {\n          if (attempt === distribution.settings.retryAttempts - 1) {\n            recipient.status = 'failed';\n            recipient.error = error instanceof Error ? error.message : 'Unknown error';\n            recipient.processedAt = new Date();\n            result.failCount++;\n          } else {\n            await this.delay(distribution.settings.retryDelay);\n          }\n        }\n      }\n    }\n\n    distribution.updatedAt = new Date();\n    return result;\n  }\n\n  /**\n   * Cancel a distribution\n   */\n  cancelDistribution(distributionId: string): void {\n    const distribution = this.distributions.get(distributionId);\n    if (!distribution) {\n      throw new Error(`Distribution not found: ${distributionId}`);\n    }\n\n    if (distribution.status === 'completed' || distribution.status === 'failed') {\n      throw new Error('Cannot cancel completed distribution');\n    }\n\n    distribution.status = 'cancelled';\n    distribution.updatedAt = new Date();\n  }\n\n  /**\n   * Get distribution by ID\n   */\n  getDistribution(distributionId: string): Distribution | undefined {\n    return this.distributions.get(distributionId);\n  }\n\n  /**\n   * Get distribution progress\n   */\n  getProgress(distributionId: string): DistributionProgress | undefined {\n    const distribution = this.distributions.get(distributionId);\n    if (!distribution) return undefined;\n\n    const { recipients } = distribution;\n    const total = recipients.length;\n    const pending = recipients.filter(r => r.status === 'pending').length;\n    const processing = recipients.filter(r => r.status === 'processing').length;\n    const sent = recipients.filter(r => r.status === 'sent').length;\n    const confirmed = recipients.filter(r => r.status === 'confirmed').length;\n    const failed = recipients.filter(r => r.status === 'failed').length;\n    const completed = sent + confirmed;\n    const percentage = total > 0 ? (completed / total) * 100 : 0;\n\n    return { total, pending, processing, sent, confirmed, failed, percentage };\n  }\n\n  /**\n   * Get all distributions\n   */\n  getAllDistributions(): Distribution[] {\n    return Array.from(this.distributions.values());\n  }\n\n  /**\n   * Get distribution summary\n   */\n  getSummary(distributionId: string): DistributionSummary | undefined {\n    const distribution = this.distributions.get(distributionId);\n    if (!distribution) return undefined;\n\n    const progress = this.getProgress(distributionId)!;\n\n    return {\n      id: distribution.id,\n      name: distribution.name,\n      status: distribution.status,\n      tokenSymbol: distribution.tokenSymbol,\n      totalAmount: distribution.totalAmount.toString(),\n      recipientCount: distribution.recipients.length,\n      progress,\n      createdAt: distribution.createdAt,\n      completedAt: distribution.completedAt,\n    };\n  }\n\n  /**\n   * Create batches from recipients\n   */\n  private createBatches(recipients: Recipient[], batchSize: number): Recipient[][] {\n    const batches: Recipient[][] = [];\n    for (let i = 0; i < recipients.length; i += batchSize) {\n      batches.push(recipients.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  /**\n   * Delay helper\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Generate unique ID\n   */\n  private generateId(prefix: string): string {\n    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createTokenDistributor(): TokenDistributor {\n  return new TokenDistributor();\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function validateAddress(address: string, blockchain?: string): boolean {\n  // Basic validation - real implementation would be blockchain-specific\n  if (!address || address.length < 10) return false;\n\n  if (blockchain === 'bsv' || blockchain === 'bitcoin') {\n    return /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(address);\n  }\n\n  if (blockchain === 'ethereum' || blockchain === 'evm') {\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n  }\n\n  if (blockchain === 'solana') {\n    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);\n  }\n\n  return true;\n}\n\nexport function formatDistributionAmount(amount: bigint, decimals: number = 8): string {\n  const divisor = BigInt(10 ** decimals);\n  const whole = amount / divisor;\n  const fraction = amount % divisor;\n\n  if (fraction === BigInt(0)) {\n    return whole.toString();\n  }\n\n  const fractionStr = fraction.toString().padStart(decimals, '0');\n  return `${whole}.${fractionStr.replace(/0+$/, '')}`;\n}\n\nexport function parseCSVRecipients(csv: string): RecipientInput[] {\n  const lines = csv.trim().split('\\n');\n  const recipients: RecipientInput[] = [];\n\n  for (const line of lines) {\n    const parts = line.split(',').map(p => p.trim());\n    if (parts.length >= 1 && parts[0]) {\n      recipients.push({\n        address: parts[0],\n        amount: parts[1] ? BigInt(parts[1]) : undefined,\n        email: parts[2] || undefined,\n        name: parts[3] || undefined,\n      });\n    }\n  }\n\n  return recipients;\n}\n\nexport function exportRecipientsCSV(recipients: Recipient[]): string {\n  const header = 'address,amount,status,txid,error';\n  const lines = recipients.map(r =>\n    `${r.address},${r.amount.toString()},${r.status},${r.txid || ''},${r.error || ''}`\n  );\n  return [header, ...lines].join('\\n');\n}\n"],"mappings":"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","names":[]}