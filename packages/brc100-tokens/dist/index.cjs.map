{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/brc100-tokens\n *\n * BRC-100 token standard implementation for programmable tokens on Bitcoin.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** BRC-100 operation type */\nexport type BRC100Operation =\n  | 'deploy'\n  | 'mint'\n  | 'transfer'\n  | 'burn'\n  | 'inscribe'\n  | 'swap'\n  | 'stake'\n  | 'unstake';\n\n/** Token state */\nexport type TokenState = 'deploying' | 'active' | 'paused' | 'completed';\n\n/** BRC-100 protocol identifier */\nexport const BRC100_PROTOCOL = 'brc-100';\n\n/** BRC-100 token deployment */\nexport interface BRC100Deploy {\n  p: typeof BRC100_PROTOCOL;\n  op: 'deploy';\n  tick: string;\n  max: string;\n  lim?: string;\n  dec?: string;\n  self?: string;\n  desc?: string;\n  icon?: string;\n  attr?: TokenAttributes;\n}\n\n/** BRC-100 mint operation */\nexport interface BRC100Mint {\n  p: typeof BRC100_PROTOCOL;\n  op: 'mint';\n  tick: string;\n  amt: string;\n}\n\n/** BRC-100 transfer operation */\nexport interface BRC100Transfer {\n  p: typeof BRC100_PROTOCOL;\n  op: 'transfer';\n  tick: string;\n  amt: string;\n  to?: string;\n}\n\n/** BRC-100 burn operation */\nexport interface BRC100Burn {\n  p: typeof BRC100_PROTOCOL;\n  op: 'burn';\n  tick: string;\n  amt: string;\n}\n\n/** Token attributes */\nexport interface TokenAttributes {\n  mintable?: boolean;\n  burnable?: boolean;\n  transferable?: boolean;\n  pausable?: boolean;\n  upgradeable?: boolean;\n  maxHolders?: number;\n  minBalance?: string;\n  maxBalance?: string;\n  whitelistOnly?: boolean;\n  blacklist?: string[];\n}\n\n/** BRC-100 token */\nexport interface BRC100Token {\n  tick: string;\n  name?: string;\n  max: bigint;\n  lim: bigint;\n  dec: number;\n  minted: bigint;\n  burned: bigint;\n  holders: number;\n  state: TokenState;\n  deployInscription: string;\n  deployer: string;\n  deployHeight: number;\n  selfMint: bigint;\n  description?: string;\n  icon?: string;\n  attributes: TokenAttributes;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n/** Token balance */\nexport interface BRC100Balance {\n  tick: string;\n  address: string;\n  available: bigint;\n  transferable: bigint;\n  total: bigint;\n  lastUpdated: Date;\n}\n\n/** Transfer inscription */\nexport interface TransferInscription {\n  inscriptionId: string;\n  tick: string;\n  amount: bigint;\n  from: string;\n  to?: string;\n  status: 'inscribed' | 'transferred' | 'burned';\n  inscribedAt: Date;\n  transferredAt?: Date;\n}\n\n/** Token event */\nexport interface TokenEvent {\n  type: BRC100Operation;\n  tick: string;\n  amount: bigint;\n  from?: string;\n  to?: string;\n  inscriptionId: string;\n  txid: string;\n  blockHeight: number;\n  timestamp: Date;\n}\n\n/** Deployment options */\nexport interface DeployOptions {\n  tick: string;\n  max: bigint;\n  lim?: bigint;\n  dec?: number;\n  selfMint?: bigint;\n  description?: string;\n  icon?: string;\n  attributes?: Partial<TokenAttributes>;\n}\n\n// ============================================================================\n// BRC-100 Builder\n// ============================================================================\n\nexport class BRC100Builder {\n  /**\n   * Create a deploy inscription\n   */\n  static deploy(options: DeployOptions): BRC100Deploy {\n    const inscription: BRC100Deploy = {\n      p: BRC100_PROTOCOL,\n      op: 'deploy',\n      tick: options.tick.toLowerCase(),\n      max: options.max.toString(),\n    };\n\n    if (options.lim !== undefined) {\n      inscription.lim = options.lim.toString();\n    }\n\n    if (options.dec !== undefined) {\n      inscription.dec = options.dec.toString();\n    }\n\n    if (options.selfMint !== undefined && options.selfMint > BigInt(0)) {\n      inscription.self = options.selfMint.toString();\n    }\n\n    if (options.description) {\n      inscription.desc = options.description;\n    }\n\n    if (options.icon) {\n      inscription.icon = options.icon;\n    }\n\n    if (options.attributes) {\n      inscription.attr = options.attributes as TokenAttributes;\n    }\n\n    return inscription;\n  }\n\n  /**\n   * Create a mint inscription\n   */\n  static mint(tick: string, amount: bigint): BRC100Mint {\n    return {\n      p: BRC100_PROTOCOL,\n      op: 'mint',\n      tick: tick.toLowerCase(),\n      amt: amount.toString(),\n    };\n  }\n\n  /**\n   * Create a transfer inscription\n   */\n  static transfer(tick: string, amount: bigint, to?: string): BRC100Transfer {\n    const inscription: BRC100Transfer = {\n      p: BRC100_PROTOCOL,\n      op: 'transfer',\n      tick: tick.toLowerCase(),\n      amt: amount.toString(),\n    };\n\n    if (to) {\n      inscription.to = to;\n    }\n\n    return inscription;\n  }\n\n  /**\n   * Create a burn inscription\n   */\n  static burn(tick: string, amount: bigint): BRC100Burn {\n    return {\n      p: BRC100_PROTOCOL,\n      op: 'burn',\n      tick: tick.toLowerCase(),\n      amt: amount.toString(),\n    };\n  }\n\n  /**\n   * Serialize inscription to JSON\n   */\n  static serialize(inscription: BRC100Deploy | BRC100Mint | BRC100Transfer | BRC100Burn): string {\n    return JSON.stringify(inscription);\n  }\n\n  /**\n   * Parse inscription from JSON\n   */\n  static parse(json: string): BRC100Deploy | BRC100Mint | BRC100Transfer | BRC100Burn | null {\n    try {\n      const data = JSON.parse(json);\n      if (data.p !== BRC100_PROTOCOL) {\n        return null;\n      }\n      return data;\n    } catch {\n      return null;\n    }\n  }\n}\n\n// ============================================================================\n// BRC-100 Token Manager\n// ============================================================================\n\nexport class BRC100TokenManager {\n  private tokens: Map<string, BRC100Token> = new Map();\n  private balances: Map<string, Map<string, BRC100Balance>> = new Map();\n  private transfers: Map<string, TransferInscription> = new Map();\n  private events: TokenEvent[] = [];\n\n  /**\n   * Deploy a new token\n   */\n  deployToken(\n    inscription: BRC100Deploy,\n    inscriptionId: string,\n    deployer: string,\n    blockHeight: number\n  ): BRC100Token | null {\n    const tick = inscription.tick.toLowerCase();\n\n    // Check if token already exists\n    if (this.tokens.has(tick)) {\n      return null;\n    }\n\n    // Validate tick length (4-5 characters for BRC-100)\n    if (tick.length < 4 || tick.length > 5) {\n      return null;\n    }\n\n    const max = BigInt(inscription.max);\n    const lim = inscription.lim ? BigInt(inscription.lim) : max;\n    const dec = inscription.dec ? parseInt(inscription.dec) : 18;\n    const selfMint = inscription.self ? BigInt(inscription.self) : BigInt(0);\n\n    if (selfMint > max) {\n      return null;\n    }\n\n    const token: BRC100Token = {\n      tick,\n      max,\n      lim,\n      dec,\n      minted: selfMint,\n      burned: BigInt(0),\n      holders: selfMint > BigInt(0) ? 1 : 0,\n      state: 'active',\n      deployInscription: inscriptionId,\n      deployer,\n      deployHeight: blockHeight,\n      selfMint,\n      description: inscription.desc,\n      icon: inscription.icon,\n      attributes: inscription.attr || {\n        mintable: true,\n        burnable: true,\n        transferable: true,\n      },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.tokens.set(tick, token);\n\n    // Handle self-mint\n    if (selfMint > BigInt(0)) {\n      this.updateBalance(tick, deployer, selfMint, BigInt(0));\n    }\n\n    return token;\n  }\n\n  /**\n   * Mint tokens\n   */\n  mint(\n    inscription: BRC100Mint,\n    inscriptionId: string,\n    minter: string,\n    blockHeight: number,\n    txid: string\n  ): boolean {\n    const tick = inscription.tick.toLowerCase();\n    const token = this.tokens.get(tick);\n\n    if (!token) return false;\n    if (token.state !== 'active') return false;\n    if (!token.attributes.mintable) return false;\n\n    const amount = BigInt(inscription.amt);\n\n    // Check mint limit\n    if (amount > token.lim) return false;\n\n    // Check max supply\n    if (token.minted + amount > token.max) return false;\n\n    // Update token state\n    token.minted += amount;\n    token.updatedAt = new Date();\n\n    // Check if minting is complete\n    if (token.minted >= token.max) {\n      token.state = 'completed';\n    }\n\n    // Update balance\n    this.updateBalance(tick, minter, amount, BigInt(0));\n\n    // Record event\n    this.events.push({\n      type: 'mint',\n      tick,\n      amount,\n      to: minter,\n      inscriptionId,\n      txid,\n      blockHeight,\n      timestamp: new Date(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Create a transfer inscription\n   */\n  inscribeTransfer(\n    inscription: BRC100Transfer,\n    inscriptionId: string,\n    owner: string\n  ): TransferInscription | null {\n    const tick = inscription.tick.toLowerCase();\n    const token = this.tokens.get(tick);\n\n    if (!token) return null;\n    if (!token.attributes.transferable) return null;\n\n    const amount = BigInt(inscription.amt);\n    const balance = this.getBalance(tick, owner);\n\n    if (!balance || balance.available < amount) return null;\n\n    // Move from available to transferable\n    balance.available -= amount;\n    balance.transferable += amount;\n    balance.lastUpdated = new Date();\n\n    const transfer: TransferInscription = {\n      inscriptionId,\n      tick,\n      amount,\n      from: owner,\n      to: inscription.to,\n      status: 'inscribed',\n      inscribedAt: new Date(),\n    };\n\n    this.transfers.set(inscriptionId, transfer);\n    return transfer;\n  }\n\n  /**\n   * Execute a transfer\n   */\n  executeTransfer(inscriptionId: string, recipient: string, txid: string, blockHeight: number): boolean {\n    const transfer = this.transfers.get(inscriptionId);\n    if (!transfer) return false;\n    if (transfer.status !== 'inscribed') return false;\n\n    const finalRecipient = transfer.to || recipient;\n\n    // Update sender balance\n    const senderBalance = this.getBalance(transfer.tick, transfer.from);\n    if (senderBalance) {\n      senderBalance.transferable -= transfer.amount;\n      senderBalance.total -= transfer.amount;\n      senderBalance.lastUpdated = new Date();\n    }\n\n    // Update recipient balance\n    this.updateBalance(transfer.tick, finalRecipient, transfer.amount, BigInt(0));\n\n    // Update transfer status\n    transfer.status = 'transferred';\n    transfer.to = finalRecipient;\n    transfer.transferredAt = new Date();\n\n    // Record event\n    this.events.push({\n      type: 'transfer',\n      tick: transfer.tick,\n      amount: transfer.amount,\n      from: transfer.from,\n      to: finalRecipient,\n      inscriptionId,\n      txid,\n      blockHeight,\n      timestamp: new Date(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Burn tokens\n   */\n  burn(\n    inscription: BRC100Burn,\n    inscriptionId: string,\n    owner: string,\n    txid: string,\n    blockHeight: number\n  ): boolean {\n    const tick = inscription.tick.toLowerCase();\n    const token = this.tokens.get(tick);\n\n    if (!token) return false;\n    if (!token.attributes.burnable) return false;\n\n    const amount = BigInt(inscription.amt);\n    const balance = this.getBalance(tick, owner);\n\n    if (!balance || balance.available < amount) return false;\n\n    // Update balance\n    balance.available -= amount;\n    balance.total -= amount;\n    balance.lastUpdated = new Date();\n\n    // Update token state\n    token.burned += amount;\n    token.updatedAt = new Date();\n\n    // Record event\n    this.events.push({\n      type: 'burn',\n      tick,\n      amount,\n      from: owner,\n      inscriptionId,\n      txid,\n      blockHeight,\n      timestamp: new Date(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Get token info\n   */\n  getToken(tick: string): BRC100Token | undefined {\n    return this.tokens.get(tick.toLowerCase());\n  }\n\n  /**\n   * Get all tokens\n   */\n  getAllTokens(): BRC100Token[] {\n    return Array.from(this.tokens.values());\n  }\n\n  /**\n   * Get balance for an address\n   */\n  getBalance(tick: string, address: string): BRC100Balance | undefined {\n    return this.balances.get(tick.toLowerCase())?.get(address);\n  }\n\n  /**\n   * Get all balances for an address\n   */\n  getBalances(address: string): BRC100Balance[] {\n    const balances: BRC100Balance[] = [];\n    for (const tickBalances of this.balances.values()) {\n      const balance = tickBalances.get(address);\n      if (balance && balance.total > BigInt(0)) {\n        balances.push(balance);\n      }\n    }\n    return balances;\n  }\n\n  /**\n   * Get token events\n   */\n  getEvents(tick?: string, limit?: number): TokenEvent[] {\n    let events = this.events;\n    if (tick) {\n      events = events.filter(e => e.tick === tick.toLowerCase());\n    }\n    events = events.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    if (limit) {\n      events = events.slice(0, limit);\n    }\n    return events;\n  }\n\n  /**\n   * Get transfer inscription\n   */\n  getTransfer(inscriptionId: string): TransferInscription | undefined {\n    return this.transfers.get(inscriptionId);\n  }\n\n  /**\n   * Update balance helper\n   */\n  private updateBalance(tick: string, address: string, available: bigint, transferable: bigint): void {\n    if (!this.balances.has(tick)) {\n      this.balances.set(tick, new Map());\n    }\n\n    const tickBalances = this.balances.get(tick)!;\n    const existing = tickBalances.get(address);\n\n    if (existing) {\n      existing.available += available;\n      existing.transferable += transferable;\n      existing.total = existing.available + existing.transferable;\n      existing.lastUpdated = new Date();\n    } else {\n      tickBalances.set(address, {\n        tick,\n        address,\n        available,\n        transferable,\n        total: available + transferable,\n        lastUpdated: new Date(),\n      });\n\n      // Update holder count\n      const token = this.tokens.get(tick);\n      if (token) {\n        token.holders++;\n      }\n    }\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createBRC100Manager(): BRC100TokenManager {\n  return new BRC100TokenManager();\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function validateTick(tick: string): { valid: boolean; error?: string } {\n  if (tick.length < 4) {\n    return { valid: false, error: 'Tick must be at least 4 characters' };\n  }\n  if (tick.length > 5) {\n    return { valid: false, error: 'Tick must be at most 5 characters' };\n  }\n  if (!/^[a-zA-Z0-9]+$/.test(tick)) {\n    return { valid: false, error: 'Tick must be alphanumeric' };\n  }\n  return { valid: true };\n}\n\nexport function formatBRC100Amount(amount: bigint, decimals: number): string {\n  const divisor = BigInt(10 ** decimals);\n  const whole = amount / divisor;\n  const fraction = amount % divisor;\n\n  if (fraction === BigInt(0)) {\n    return whole.toString();\n  }\n\n  const fractionStr = fraction.toString().padStart(decimals, '0');\n  return `${whole}.${fractionStr.replace(/0+$/, '')}`;\n}\n\nexport function parseBRC100Amount(amount: string, decimals: number): bigint {\n  const [whole, fraction = ''] = amount.split('.');\n  const paddedFraction = fraction.padEnd(decimals, '0').slice(0, decimals);\n  return BigInt(whole + paddedFraction);\n}\n\nexport function calculateMintProgress(token: BRC100Token): number {\n  if (token.max === BigInt(0)) return 100;\n  return Number((token.minted * BigInt(10000)) / token.max) / 100;\n}\n\nexport function getCirculatingSupply(token: BRC100Token): bigint {\n  return token.minted - token.burned;\n}\n"],"mappings":"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","names":[]}