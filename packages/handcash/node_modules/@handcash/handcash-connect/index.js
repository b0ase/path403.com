import { PrivateKey as y, PublicKey as v, ECIES as E, ECIESCiphertext as m } from "bsv-wasm";
import f from "axios";
import { nanoid as w } from "nanoid";
class T extends Error {
  httpStatusCode;
  info;
  constructor(e, t, s) {
    super(), this.httpStatusCode = e, this.message = t, this.info = s;
  }
  toString() {
    return JSON.stringify(this);
  }
}
class r {
  httpRequestFactory;
  constructor(e) {
    this.httpRequestFactory = e;
  }
  async getCurrentProfile() {
    const e = this.httpRequestFactory.getCurrentProfileRequest();
    return r.handleRequest(e);
  }
  async getPublicProfilesByHandle(e) {
    const t = this.httpRequestFactory.getPublicProfilesByHandleRequest(e);
    return r.handleRequest(t);
  }
  async getUserPermissions() {
    const e = this.httpRequestFactory.getUserPermissionsRequest();
    return r.handleRequest(e);
  }
  async getEncryptionKeypair(e) {
    const t = this.httpRequestFactory.getEncryptionKeypairRequest(e);
    return r.handleRequest(t);
  }
  async signData(e) {
    const t = this.httpRequestFactory.getDataSignatureRequest(e);
    return r.handleRequest(t);
  }
  async getUserFriends() {
    const e = this.httpRequestFactory.getUserFriendsRequest();
    return r.handleRequest(e);
  }
  async getSpendableBalance(e) {
    const t = this.httpRequestFactory.getSpendableBalanceRequest(e);
    return r.handleRequest(t);
  }
  async getTotalBalance() {
    const e = this.httpRequestFactory.getTotalBalanceRequest();
    return r.handleRequest(e);
  }
  async pay(e) {
    const t = this.httpRequestFactory.getPayRequest(e);
    return r.handleRequest(t);
  }
  async getPayment(e) {
    const t = this.httpRequestFactory.getPaymentRequest({ transactionId: e });
    return r.handleRequest(t);
  }
  async getExchangeRate(e) {
    const t = this.httpRequestFactory.getExchangeRateRequest(e);
    return r.handleRequest(t);
  }
  async pursePay(e, t) {
    const s = this.httpRequestFactory.getPursePayRequest(e, t);
    return r.handleRequest(s);
  }
  async purseBroadcast(e) {
    const t = this.httpRequestFactory.getPurseBroadcastRequest(e);
    return r.handleRequest(t);
  }
  async ownerNextAddress(e) {
    const t = this.httpRequestFactory.getOwnerNextAddressRequest(e);
    return r.handleRequest(t);
  }
  async ownerSign(e, t, s) {
    const n = this.httpRequestFactory.getOwnerSignRequest(e, t, s);
    return r.handleRequest(n);
  }
  async getNftLocations() {
    const e = this.httpRequestFactory.getNftLocationsRequest();
    return r.handleRequest(e);
  }
  async requestEmailCode(e) {
    const t = this.httpRequestFactory.requestEmailCodeRequest(e);
    return (await r.handleRequest(t)).requestId.requestId;
  }
  async verifyEmailCode(e, t, s) {
    const n = this.httpRequestFactory.verifyEmailCodeRequest(
      e,
      t,
      s
    );
    return r.handleRequest(n);
  }
  async createNewAccount(e, t, s) {
    const n = this.httpRequestFactory.createNewAccountRequest(
      e,
      t,
      s
    );
    return r.handleRequest(n);
  }
  static async handleRequest(e) {
    return f(e).then((t) => t.data).catch(r.handleApiError);
  }
  static handleApiError(e) {
    return !e.response || !e.response.status ? Promise.reject(e) : Promise.reject(
      new T(
        e.response.status,
        e.response.data.message,
        e.response.data.info
      )
    );
  }
}
const h = "/v1/connect/profile", P = "/v1/connect/account", p = "/v1/connect/wallet", d = "/v1/connect/runExtension";
class i {
  privateKey;
  appSecret;
  appId;
  baseApiEndpoint;
  baseTrustholderEndpoint;
  constructor({ authToken: e, appSecret: t, appId: s, baseApiEndpoint: n, baseTrustholderEndpoint: a }) {
    if (e)
      try {
        this.privateKey = y.from_hex(e);
      } catch {
        throw Error("Invalid authToken");
      }
    if (!t)
      throw Error("Missing appSecret");
    if (!s)
      throw Error("Missing appId");
    this.appSecret = t, this.appId = s, this.baseApiEndpoint = n, this.baseTrustholderEndpoint = a;
  }
  getRequest(e, t, s = {}, n = {}) {
    const a = new Date().toISOString(), o = w(), c = JSON.stringify(s) === "{}" ? "" : JSON.stringify(s), l = i.getEncodedEndpoint(t, n), u = {
      "app-id": this.appId,
      "app-secret": this.appSecret,
      accept: "application/json"
    };
    if (c.length > 0 && (u["content-type"] = "application/json"), this.privateKey) {
      const b = this.privateKey.to_public_key();
      u["oauth-publickey"] = b.to_hex(), u["oauth-timestamp"] = a.toString(), u["oauth-nonce"] = o, u["oauth-signature"] = i.getRequestSignature(
        e,
        l,
        c,
        a,
        this.privateKey,
        o
      );
    }
    return {
      baseURL: this.baseApiEndpoint,
      url: l,
      method: e,
      headers: u,
      data: c,
      responseType: "json"
    };
  }
  getTrustholderRequest(e, t, s, n = {}) {
    const a = i.getEncodedEndpoint(t, n);
    return {
      baseURL: this.baseTrustholderEndpoint,
      url: a,
      method: e,
      headers: {},
      data: s,
      responseType: "json"
    };
  }
  static getEncodedEndpoint(e, t) {
    return f.getUri({
      url: e,
      params: t
    });
  }
  static getRequestSignature(e, t, s, n, a, o) {
    const c = i.getRequestSignaturePayload(
      e,
      t,
      s,
      n,
      o
    );
    return a.sign_message(Buffer.from(c)).to_hex();
  }
  static getRequestSignaturePayload(e, t, s, n, a) {
    return `${e}
${t}
${n}
${s}${a ? `
${a}` : ""}`;
  }
  getCurrentProfileRequest() {
    return this.getRequest("GET", `${h}/currentUserProfile`);
  }
  getPublicProfilesByHandleRequest(e) {
    const t = e.map((s, n) => [`aliases[${n}]`, s]);
    return this.getRequest(
      "GET",
      `${h}/publicUserProfiles`,
      {},
      {
        ...Object.fromEntries(t)
      }
    );
  }
  requestEmailCodeRequest = (e) => this.getRequest("POST", `${P}/requestEmailCode`, { email: e });
  verifyEmailCodeRequest = (e, t, s) => this.getTrustholderRequest("POST", "/auth/verifyCode", { requestId: e, verificationCode: t, publicKey: s });
  createNewAccountRequest = (e, t, s) => this.getRequest("POST", `${P}`, { accessPublicKey: e, email: t, referrerAlias: s });
  getUserFriendsRequest() {
    return this.getRequest("GET", `${h}/friends`);
  }
  getUserPermissionsRequest() {
    return this.getRequest("GET", `${h}/permissions`);
  }
  getEncryptionKeypairRequest(e) {
    return this.getRequest(
      "GET",
      `${h}/encryptionKeypair`,
      {},
      {
        encryptionPublicKey: e
      }
    );
  }
  getDataSignatureRequest(e) {
    return this.getRequest("POST", `${h}/signData`, {
      format: e.format,
      value: e.value
    });
  }
  getSpendableBalanceRequest(e) {
    return this.getRequest("GET", `${p}/spendableBalance`, {}, e ? { currencyCode: e } : {});
  }
  getTotalBalanceRequest() {
    return this.getRequest("GET", `${p}/balance`);
  }
  getPayRequest(e) {
    return this.getRequest("POST", `${p}/pay`, {
      description: e.description,
      appAction: e.appAction,
      receivers: e.payments,
      attachment: e.attachment
    });
  }
  getPaymentRequest(e) {
    return this.getRequest("GET", `${p}/payment`, {}, e);
  }
  getExchangeRateRequest(e) {
    return this.getRequest("GET", `${p}/exchangeRate/${e}`, {});
  }
  getPursePayRequest(e, t) {
    return this.getRequest("POST", `${d}/purse/pay`, {
      rawTransaction: e,
      inputParents: t
    });
  }
  getPurseBroadcastRequest(e) {
    return this.getRequest("POST", `${d}/purse/broadcast`, {
      rawTransaction: e
    });
  }
  getOwnerNextAddressRequest(e) {
    return this.getRequest(
      "GET",
      `${d}/owner/next`,
      {},
      {
        alias: e
      }
    );
  }
  getOwnerSignRequest(e, t, s) {
    return this.getRequest("POST", `${d}/owner/sign`, {
      rawTransaction: e,
      inputParents: t,
      locks: s
    });
  }
  getNftLocationsRequest() {
    return this.getRequest("GET", `${d}/owner/nftLocations`, {});
  }
}
class A {
  handCashConnectService;
  constructor(e) {
    this.handCashConnectService = e;
  }
  async getSpendableBalance(e) {
    return this.handCashConnectService.getSpendableBalance(e);
  }
  async getTotalBalance() {
    return this.handCashConnectService.getTotalBalance();
  }
  async pay(e) {
    return this.handCashConnectService.pay(e);
  }
  async getPayment(e) {
    return this.handCashConnectService.getPayment(e);
  }
  async getExchangeRate(e) {
    return this.handCashConnectService.getExchangeRate(e);
  }
}
class $ {
  handCashConnectService;
  constructor(e) {
    this.handCashConnectService = e;
  }
  async getCurrentProfile() {
    return this.handCashConnectService.getCurrentProfile();
  }
  async getPublicProfilesByHandle(e) {
    return this.handCashConnectService.getPublicProfilesByHandle(e).then((t) => t.items);
  }
  async getFriends() {
    return this.handCashConnectService.getUserFriends().then((e) => e.items);
  }
  async getPermissions() {
    return this.handCashConnectService.getUserPermissions().then((e) => e.items);
  }
  async getPermissionsInfo() {
    return this.handCashConnectService.getUserPermissions().then((e) => e);
  }
  async getEncryptionKeypair() {
    const e = y.from_random(), t = await this.handCashConnectService.getEncryptionKeypair(
      e.to_public_key().to_hex()
    ), s = v.from_hex(t.senderPublicKeyHex);
    return {
      publicKey: Buffer.from(
        E.decrypt(
          m.from_bytes(Buffer.from(t.encryptedPublicKeyHex, "hex"), !0),
          e,
          s
        )
      ).toString(),
      privateKey: Buffer.from(
        E.decrypt(
          m.from_bytes(Buffer.from(t.encryptedPrivateKeyHex, "hex"), !0),
          e,
          s
        )
      ).toString()
    };
  }
  async signData(e) {
    return this.handCashConnectService.signData(e);
  }
}
class q {
  wallet;
  profile;
  constructor(e, t) {
    this.wallet = e, this.profile = t;
  }
  static fromAuthToken({ authToken: e, appSecret: t, appId: s, baseApiEndpoint: n, baseTrustholderEndpoint: a }) {
    const o = new r(
      new i({
        authToken: e,
        baseApiEndpoint: n,
        baseTrustholderEndpoint: a,
        appSecret: t,
        appId: s
      })
    ), c = new A(o), l = new $(o);
    return new q(c, l);
  }
}
const R = {
  prod: {
    apiEndpoint: "https://cloud.handcash.io",
    clientUrl: "https://app.handcash.io",
    trustholderEndpoint: "https://trust.hastearcade.com"
  },
  beta: {
    apiEndpoint: "https://beta-cloud.handcash.io",
    clientUrl: "https://beta-app.handcash.io",
    trustholderEndpoint: "https://trust.dev.hastearcade.com"
  },
  iae: {
    apiEndpoint: "https://iae.cloud.handcash.io",
    clientUrl: "https://iae-app.handcash.io",
    trustholderEndpoint: "http://trustholder-service-iae.us-east-1.elasticbeanstalk.com"
  }
};
class U {
  appId;
  appSecret;
  handCashConnectService;
  env;
  constructor({ appId: e, appSecret: t, env: s = R.prod }) {
    this.appId = e, this.appSecret = t, this.env = s, this.handCashConnectService = new r(
      new i({
        appId: this.appId,
        appSecret: this.appSecret,
        baseApiEndpoint: this.env.apiEndpoint,
        baseTrustholderEndpoint: this.env.trustholderEndpoint
      })
    );
  }
  getRedirectionUrl(e = {}) {
    e.appId = this.appId;
    const t = Object.entries(e).map(([s, n]) => `${encodeURIComponent(s)}=${encodeURIComponent(n.toString())}`).join("&");
    return `${this.env.clientUrl}/#/authorizeApp?${t}`;
  }
  getChangeSpendLimitsUrl(e) {
    return `${this.env.clientUrl}/#/settings/spendLimits` + (e ? `?redirectUrl=${e}` : "");
  }
  generateAuthenticationKeyPair = () => {
    const e = y.from_random(), t = e.to_public_key();
    return {
      privateKey: e.to_hex(),
      publicKey: t.to_hex()
    };
  };
  requestEmailCode(e) {
    return this.handCashConnectService.requestEmailCode(e);
  }
  verifyEmailCode(e, t, s) {
    return this.handCashConnectService.verifyEmailCode(e, t, s);
  }
  createNewAccount(e, t, s) {
    return this.handCashConnectService.createNewAccount(e, t, s);
  }
  getAccountFromAuthToken(e) {
    return q.fromAuthToken({
      authToken: e,
      appSecret: this.appSecret,
      appId: this.appId,
      baseApiEndpoint: this.env.apiEndpoint,
      baseTrustholderEndpoint: this.env.trustholderEndpoint
    });
  }
}
class S {
  handCashConnectService;
  constructor(e) {
    this.handCashConnectService = e;
  }
  static fromAuthToken(e, t = R.prod, s = "", n = "") {
    const a = new r(
      new i({
        authToken: e,
        baseApiEndpoint: t.apiEndpoint,
        baseTrustholderEndpoint: t.trustholderEndpoint,
        appSecret: s,
        appId: n
      })
    );
    return new S(a);
  }
  async pay(e, t) {
    return (await this.handCashConnectService.pursePay(e, t)).partiallySignedTx;
  }
  async broadcast(e) {
    await this.handCashConnectService.purseBroadcast(e);
  }
}
class C {
  handCashConnectService;
  constructor(e) {
    this.handCashConnectService = e;
  }
  static fromAuthToken(e, t = R.prod, s = "", n = "") {
    const a = new r(
      new i({
        authToken: e,
        baseApiEndpoint: t.apiEndpoint,
        baseTrustholderEndpoint: t.trustholderEndpoint,
        appSecret: s,
        appId: n
      })
    );
    return new C(a);
  }
  async nextOwner(e) {
    return (await this.handCashConnectService.ownerNextAddress(e)).ownerAddress;
  }
  async sign(e, t, s) {
    return (await this.handCashConnectService.ownerSign(e, t, s)).signedTransaction;
  }
  async getNftLocations() {
    return (await this.handCashConnectService.getNftLocations()).nftLocations;
  }
}
const I = {
  Pay: "PAY",
  UserPublicProfile: "USER_PUBLIC_PROFILE",
  UserPrivateProfile: "USER_PRIVATE_PROFILE",
  Friends: "FRIENDS",
  Decryption: "DECRYPTION",
  SignData: "SIGN_DATA",
  ReadBalance: "READ_BALANCE"
};
export {
  R as Environments,
  U as HandCashConnect,
  T as HandCashConnectApiError,
  C as HandCashOwner,
  S as HandCashPurse,
  I as Permissions
};
