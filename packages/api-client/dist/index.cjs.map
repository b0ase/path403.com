{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/api-client\n *\n * Unified API client with retry, caching, and error handling.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** HTTP method */\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS';\n\n/** Request body */\nexport type RequestBody = Record<string, unknown> | FormData | string | Uint8Array | null;\n\n/** Request headers */\nexport type RequestHeaders = Record<string, string>;\n\n/** Query params */\nexport type QueryParams = Record<string, string | number | boolean | string[] | undefined>;\n\n/** Response type */\nexport type ResponseType = 'json' | 'text' | 'blob' | 'arrayBuffer' | 'formData';\n\n/** Request options */\nexport interface RequestOptions {\n  method?: HttpMethod;\n  headers?: RequestHeaders;\n  body?: RequestBody;\n  params?: QueryParams;\n  responseType?: ResponseType;\n  timeout?: number;\n  retry?: RetryOptions;\n  cache?: CacheOptions;\n  signal?: AbortSignal;\n  credentials?: RequestCredentials;\n}\n\n/** Retry options */\nexport interface RetryOptions {\n  maxRetries?: number;\n  retryDelay?: number;\n  retryOn?: number[];\n  exponentialBackoff?: boolean;\n  maxDelay?: number;\n}\n\n/** Cache options */\nexport interface CacheOptions {\n  enabled?: boolean;\n  ttl?: number;\n  key?: string;\n  staleWhileRevalidate?: boolean;\n}\n\n/** API response */\nexport interface ApiResponse<T = unknown> {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: Record<string, string>;\n  ok: boolean;\n  cached?: boolean;\n  retries?: number;\n}\n\n/** API error */\nexport interface ApiError {\n  message: string;\n  status?: number;\n  statusText?: string;\n  code?: string;\n  data?: unknown;\n  retries?: number;\n}\n\n/** Interceptor */\nexport interface Interceptor {\n  request?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;\n  response?: <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;\n  error?: (error: ApiError) => ApiError | Promise<ApiError>;\n}\n\n/** Request config */\nexport interface RequestConfig {\n  url: string;\n  method: HttpMethod;\n  headers: RequestHeaders;\n  body?: RequestBody;\n  params?: QueryParams;\n  timeout: number;\n  retry: Required<RetryOptions>;\n  cache: Required<CacheOptions>;\n  responseType: ResponseType;\n}\n\n/** Client config */\nexport interface ClientConfig {\n  baseUrl?: string;\n  headers?: RequestHeaders;\n  timeout?: number;\n  retry?: RetryOptions;\n  cache?: CacheOptions;\n  credentials?: RequestCredentials;\n  interceptors?: Interceptor[];\n}\n\n/** Cache entry */\ninterface CacheEntry<T> {\n  data: T;\n  expiresAt: number;\n  stale?: boolean;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxRetries: 3,\n  retryDelay: 1000,\n  retryOn: [408, 429, 500, 502, 503, 504],\n  exponentialBackoff: true,\n  maxDelay: 30000,\n};\n\nexport const DEFAULT_CACHE_OPTIONS: Required<CacheOptions> = {\n  enabled: false,\n  ttl: 60000, // 1 minute\n  key: '',\n  staleWhileRevalidate: false,\n};\n\nexport const DEFAULT_TIMEOUT = 30000; // 30 seconds\n\n// ============================================================================\n// API Client\n// ============================================================================\n\nexport class ApiClient {\n  private baseUrl: string;\n  private defaultHeaders: RequestHeaders;\n  private defaultTimeout: number;\n  private defaultRetry: Required<RetryOptions>;\n  private defaultCache: Required<CacheOptions>;\n  private credentials: RequestCredentials;\n  private interceptors: Interceptor[] = [];\n  private cache: Map<string, CacheEntry<unknown>> = new Map();\n\n  constructor(config: ClientConfig = {}) {\n    this.baseUrl = config.baseUrl || '';\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.headers,\n    };\n    this.defaultTimeout = config.timeout || DEFAULT_TIMEOUT;\n    this.defaultRetry = { ...DEFAULT_RETRY_OPTIONS, ...config.retry };\n    this.defaultCache = { ...DEFAULT_CACHE_OPTIONS, ...config.cache };\n    this.credentials = config.credentials || 'same-origin';\n    this.interceptors = config.interceptors || [];\n  }\n\n  // ==========================================================================\n  // HTTP Methods\n  // ==========================================================================\n\n  async get<T = unknown>(url: string, options?: RequestOptions): Promise<ApiResponse<T>> {\n    return this.request<T>(url, { ...options, method: 'GET' });\n  }\n\n  async post<T = unknown>(url: string, body?: RequestBody, options?: RequestOptions): Promise<ApiResponse<T>> {\n    return this.request<T>(url, { ...options, method: 'POST', body });\n  }\n\n  async put<T = unknown>(url: string, body?: RequestBody, options?: RequestOptions): Promise<ApiResponse<T>> {\n    return this.request<T>(url, { ...options, method: 'PUT', body });\n  }\n\n  async patch<T = unknown>(url: string, body?: RequestBody, options?: RequestOptions): Promise<ApiResponse<T>> {\n    return this.request<T>(url, { ...options, method: 'PATCH', body });\n  }\n\n  async delete<T = unknown>(url: string, options?: RequestOptions): Promise<ApiResponse<T>> {\n    return this.request<T>(url, { ...options, method: 'DELETE' });\n  }\n\n  async head(url: string, options?: RequestOptions): Promise<ApiResponse<void>> {\n    return this.request<void>(url, { ...options, method: 'HEAD' });\n  }\n\n  // ==========================================================================\n  // Core Request\n  // ==========================================================================\n\n  async request<T = unknown>(url: string, options: RequestOptions = {}): Promise<ApiResponse<T>> {\n    let config = this.buildConfig(url, options);\n\n    // Run request interceptors\n    for (const interceptor of this.interceptors) {\n      if (interceptor.request) {\n        config = await interceptor.request(config);\n      }\n    }\n\n    // Check cache\n    if (config.cache.enabled && config.method === 'GET') {\n      const cacheKey = config.cache.key || this.getCacheKey(config);\n      const cached = this.getFromCache<T>(cacheKey);\n\n      if (cached) {\n        if (!cached.stale) {\n          return {\n            data: cached.data,\n            status: 200,\n            statusText: 'OK',\n            headers: {},\n            ok: true,\n            cached: true,\n          };\n        }\n\n        // Stale-while-revalidate: return stale data and refresh in background\n        if (config.cache.staleWhileRevalidate) {\n          this.executeRequest<T>(config).then(response => {\n            this.setCache(cacheKey, response.data, config.cache.ttl);\n          });\n\n          return {\n            data: cached.data,\n            status: 200,\n            statusText: 'OK',\n            headers: {},\n            ok: true,\n            cached: true,\n          };\n        }\n      }\n    }\n\n    // Execute request with retry\n    let lastError: ApiError | null = null;\n    let retries = 0;\n\n    while (retries <= config.retry.maxRetries) {\n      try {\n        const response = await this.executeRequest<T>(config);\n\n        // Run response interceptors\n        let processedResponse = response;\n        for (const interceptor of this.interceptors) {\n          if (interceptor.response) {\n            processedResponse = await interceptor.response(processedResponse);\n          }\n        }\n\n        // Cache successful GET responses\n        if (config.cache.enabled && config.method === 'GET' && processedResponse.ok) {\n          const cacheKey = config.cache.key || this.getCacheKey(config);\n          this.setCache(cacheKey, processedResponse.data, config.cache.ttl);\n        }\n\n        processedResponse.retries = retries;\n        return processedResponse;\n      } catch (error) {\n        lastError = this.normalizeError(error);\n        lastError.retries = retries;\n\n        // Run error interceptors\n        for (const interceptor of this.interceptors) {\n          if (interceptor.error) {\n            lastError = await interceptor.error(lastError);\n          }\n        }\n\n        // Check if should retry\n        if (\n          retries < config.retry.maxRetries &&\n          lastError.status &&\n          config.retry.retryOn.includes(lastError.status)\n        ) {\n          const delay = this.calculateRetryDelay(retries, config.retry);\n          await this.sleep(delay);\n          retries++;\n          continue;\n        }\n\n        throw lastError;\n      }\n    }\n\n    throw lastError || new Error('Request failed');\n  }\n\n  private buildConfig(url: string, options: RequestOptions): RequestConfig {\n    const fullUrl = url.startsWith('http') ? url : `${this.baseUrl}${url}`;\n\n    return {\n      url: fullUrl,\n      method: options.method || 'GET',\n      headers: { ...this.defaultHeaders, ...options.headers },\n      body: options.body,\n      params: options.params,\n      timeout: options.timeout || this.defaultTimeout,\n      retry: { ...this.defaultRetry, ...options.retry },\n      cache: { ...this.defaultCache, ...options.cache },\n      responseType: options.responseType || 'json',\n    };\n  }\n\n  private async executeRequest<T>(config: RequestConfig): Promise<ApiResponse<T>> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), config.timeout);\n\n    try {\n      // Build URL with params\n      let finalUrl = config.url;\n      if (config.params) {\n        const searchParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(config.params)) {\n          if (value !== undefined) {\n            if (Array.isArray(value)) {\n              value.forEach(v => searchParams.append(key, String(v)));\n            } else {\n              searchParams.append(key, String(value));\n            }\n          }\n        }\n        const queryString = searchParams.toString();\n        if (queryString) {\n          finalUrl += (finalUrl.includes('?') ? '&' : '?') + queryString;\n        }\n      }\n\n      // Prepare body\n      let body: BodyInit | undefined;\n      if (config.body) {\n        if (config.body instanceof FormData || typeof config.body === 'string') {\n          body = config.body;\n        } else if (config.body instanceof Uint8Array) {\n          body = config.body.buffer.slice(\n            config.body.byteOffset,\n            config.body.byteOffset + config.body.byteLength\n          ) as ArrayBuffer;\n        } else {\n          body = JSON.stringify(config.body);\n        }\n      }\n\n      const response = await fetch(finalUrl, {\n        method: config.method,\n        headers: config.headers,\n        body,\n        signal: controller.signal,\n        credentials: this.credentials,\n      });\n\n      // Parse response\n      let data: T;\n      switch (config.responseType) {\n        case 'text':\n          data = await response.text() as T;\n          break;\n        case 'blob':\n          data = await response.blob() as T;\n          break;\n        case 'arrayBuffer':\n          data = await response.arrayBuffer() as T;\n          break;\n        case 'formData':\n          data = await response.formData() as T;\n          break;\n        default:\n          const text = await response.text();\n          try {\n            data = text ? JSON.parse(text) : null;\n          } catch {\n            data = text as T;\n          }\n      }\n\n      // Parse headers\n      const headers: Record<string, string> = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      if (!response.ok) {\n        const error: ApiError = {\n          message: response.statusText || 'Request failed',\n          status: response.status,\n          statusText: response.statusText,\n          data,\n        };\n        throw error;\n      }\n\n      return {\n        data,\n        status: response.status,\n        statusText: response.statusText,\n        headers,\n        ok: response.ok,\n      };\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  // ==========================================================================\n  // Cache\n  // ==========================================================================\n\n  private getCacheKey(config: RequestConfig): string {\n    const params = config.params ? JSON.stringify(config.params) : '';\n    return `${config.method}:${config.url}:${params}`;\n  }\n\n  private getFromCache<T>(key: string): CacheEntry<T> | null {\n    const entry = this.cache.get(key) as CacheEntry<T> | undefined;\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      return { ...entry, stale: true };\n    }\n\n    return entry;\n  }\n\n  private setCache<T>(key: string, data: T, ttl: number): void {\n    this.cache.set(key, {\n      data,\n      expiresAt: Date.now() + ttl,\n    });\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  invalidateCache(pattern?: string | RegExp): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    for (const key of this.cache.keys()) {\n      if (typeof pattern === 'string') {\n        if (key.includes(pattern)) {\n          this.cache.delete(key);\n        }\n      } else {\n        if (pattern.test(key)) {\n          this.cache.delete(key);\n        }\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Interceptors\n  // ==========================================================================\n\n  addInterceptor(interceptor: Interceptor): () => void {\n    this.interceptors.push(interceptor);\n    return () => {\n      const index = this.interceptors.indexOf(interceptor);\n      if (index >= 0) {\n        this.interceptors.splice(index, 1);\n      }\n    };\n  }\n\n  // ==========================================================================\n  // Utilities\n  // ==========================================================================\n\n  private calculateRetryDelay(attempt: number, options: Required<RetryOptions>): number {\n    if (!options.exponentialBackoff) {\n      return options.retryDelay;\n    }\n\n    const delay = options.retryDelay * Math.pow(2, attempt);\n    return Math.min(delay, options.maxDelay);\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private normalizeError(error: unknown): ApiError {\n    if (typeof error === 'object' && error !== null) {\n      const e = error as Record<string, unknown>;\n      return {\n        message: String(e.message || 'Request failed'),\n        status: typeof e.status === 'number' ? e.status : undefined,\n        statusText: typeof e.statusText === 'string' ? e.statusText : undefined,\n        code: typeof e.code === 'string' ? e.code : undefined,\n        data: e.data,\n      };\n    }\n    return { message: String(error) };\n  }\n\n  setHeader(name: string, value: string): void {\n    this.defaultHeaders[name] = value;\n  }\n\n  removeHeader(name: string): void {\n    delete this.defaultHeaders[name];\n  }\n\n  setBaseUrl(url: string): void {\n    this.baseUrl = url;\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createApiClient(config?: ClientConfig): ApiClient {\n  return new ApiClient(config);\n}\n\n// ============================================================================\n// Common Interceptors\n// ============================================================================\n\nexport function createAuthInterceptor(getToken: () => string | null | Promise<string | null>): Interceptor {\n  return {\n    request: async (config) => {\n      const token = await getToken();\n      if (token) {\n        config.headers['Authorization'] = `Bearer ${token}`;\n      }\n      return config;\n    },\n  };\n}\n\nexport function createLoggingInterceptor(\n  logger: { log: (...args: unknown[]) => void } = console\n): Interceptor {\n  return {\n    request: (config) => {\n      logger.log(`[API] ${config.method} ${config.url}`);\n      return config;\n    },\n    response: (response) => {\n      logger.log(`[API] ${response.status} ${response.statusText}`);\n      return response;\n    },\n    error: (error) => {\n      logger.log(`[API] Error: ${error.message}`);\n      return error;\n    },\n  };\n}\n\nexport function createRetryInterceptor(options?: Partial<RetryOptions>): Interceptor {\n  return {\n    request: (config) => {\n      config.retry = { ...config.retry, ...options };\n      return config;\n    },\n  };\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function isApiError(error: unknown): error is ApiError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof (error as ApiError).message === 'string'\n  );\n}\n\nexport function getErrorMessage(error: unknown): string {\n  if (isApiError(error)) {\n    return error.message;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return String(error);\n}\n\nexport function buildQueryString(params: QueryParams): string {\n  const searchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined) {\n      if (Array.isArray(value)) {\n        value.forEach(v => searchParams.append(key, v));\n      } else {\n        searchParams.append(key, String(value));\n      }\n    }\n  }\n  return searchParams.toString();\n}\n\nexport function parseQueryString(query: string): QueryParams {\n  const params: QueryParams = {};\n  const searchParams = new URLSearchParams(query);\n  for (const [key, value] of searchParams.entries()) {\n    if (key in params) {\n      const existing = params[key];\n      if (Array.isArray(existing)) {\n        existing.push(value);\n      } else {\n        params[key] = [String(existing), value];\n      }\n    } else {\n      params[key] = value;\n    }\n  }\n  return params;\n}\n\nexport function joinUrl(...parts: string[]): string {\n  return parts\n    .map((part, index) => {\n      if (index === 0) {\n        return part.replace(/\\/+$/, '');\n      }\n      return part.replace(/^\\/+/, '').replace(/\\/+$/, '');\n    })\n    .filter(Boolean)\n    .join('/');\n}\n"],"mappings":"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","names":[]}