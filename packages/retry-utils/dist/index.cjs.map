{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/retry-utils\n *\n * Retry utilities with exponential backoff and circuit breaker.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Retry options */\nexport interface RetryOptions {\n  maxAttempts?: number;\n  baseDelay?: number;\n  maxDelay?: number;\n  factor?: number;\n  jitter?: boolean;\n  retryIf?: (error: Error, attempt: number) => boolean;\n  onRetry?: (error: Error, attempt: number, delay: number) => void;\n  timeout?: number;\n}\n\n/** Retry result */\nexport interface RetryResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n  attempts: number;\n  totalTime: number;\n}\n\n/** Circuit breaker options */\nexport interface CircuitBreakerOptions {\n  failureThreshold?: number;\n  successThreshold?: number;\n  timeout?: number;\n  halfOpenLimit?: number;\n  onStateChange?: (from: CircuitState, to: CircuitState) => void;\n}\n\n/** Circuit breaker state */\nexport type CircuitState = 'closed' | 'open' | 'half-open';\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULT_RETRY_OPTIONS: Required<Omit<RetryOptions, 'retryIf' | 'onRetry' | 'timeout'>> = {\n  maxAttempts: 3,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  factor: 2,\n  jitter: true,\n};\n\nexport const DEFAULT_CIRCUIT_BREAKER_OPTIONS: Required<Omit<CircuitBreakerOptions, 'onStateChange'>> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 60000,\n  halfOpenLimit: 1,\n};\n\n// ============================================================================\n// Delay Utilities\n// ============================================================================\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction calculateDelay(\n  attempt: number,\n  baseDelay: number,\n  maxDelay: number,\n  factor: number,\n  jitter: boolean\n): number {\n  let delay = Math.min(baseDelay * Math.pow(factor, attempt - 1), maxDelay);\n\n  if (jitter) {\n    delay = delay * (0.5 + Math.random());\n  }\n\n  return Math.round(delay);\n}\n\n// ============================================================================\n// Retry Functions\n// ============================================================================\n\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const config = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  let lastError: Error | undefined;\n\n  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n    try {\n      if (config.timeout) {\n        return await withTimeout(fn(), config.timeout);\n      }\n      return await fn();\n    } catch (err) {\n      lastError = err instanceof Error ? err : new Error(String(err));\n\n      if (attempt === config.maxAttempts) {\n        break;\n      }\n\n      if (config.retryIf && !config.retryIf(lastError, attempt)) {\n        break;\n      }\n\n      const delay = calculateDelay(\n        attempt,\n        config.baseDelay,\n        config.maxDelay,\n        config.factor,\n        config.jitter\n      );\n\n      if (config.onRetry) {\n        config.onRetry(lastError, attempt, delay);\n      }\n\n      await sleep(delay);\n    }\n  }\n\n  throw lastError;\n}\n\nexport async function retryWithResult<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<RetryResult<T>> {\n  const config = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  const startTime = Date.now();\n  let lastError: Error | undefined;\n\n  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n    try {\n      const data = config.timeout ? await withTimeout(fn(), config.timeout) : await fn();\n      return {\n        success: true,\n        data,\n        attempts: attempt,\n        totalTime: Date.now() - startTime,\n      };\n    } catch (err) {\n      lastError = err instanceof Error ? err : new Error(String(err));\n\n      if (attempt === config.maxAttempts) {\n        break;\n      }\n\n      if (config.retryIf && !config.retryIf(lastError, attempt)) {\n        break;\n      }\n\n      const delay = calculateDelay(\n        attempt,\n        config.baseDelay,\n        config.maxDelay,\n        config.factor,\n        config.jitter\n      );\n\n      if (config.onRetry) {\n        config.onRetry(lastError, attempt, delay);\n      }\n\n      await sleep(delay);\n    }\n  }\n\n  return {\n    success: false,\n    error: lastError,\n    attempts: config.maxAttempts,\n    totalTime: Date.now() - startTime,\n  };\n}\n\n// ============================================================================\n// Timeout Utilities\n// ============================================================================\n\nexport class TimeoutError extends Error {\n  constructor(ms: number) {\n    super(`Operation timed out after ${ms}ms`);\n    this.name = 'TimeoutError';\n  }\n}\n\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  ms: number\n): Promise<T> {\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = setTimeout(() => reject(new TimeoutError(ms)), ms);\n  });\n\n  try {\n    return await Promise.race([promise, timeoutPromise]);\n  } finally {\n    clearTimeout(timeoutId!);\n  }\n}\n\n// ============================================================================\n// Circuit Breaker\n// ============================================================================\n\nexport class CircuitBreaker {\n  private state: CircuitState = 'closed';\n  private failures = 0;\n  private successes = 0;\n  private lastFailure?: number;\n  private halfOpenCalls = 0;\n  private options: Required<Omit<CircuitBreakerOptions, 'onStateChange'>> & Pick<CircuitBreakerOptions, 'onStateChange'>;\n\n  constructor(options: CircuitBreakerOptions = {}) {\n    this.options = { ...DEFAULT_CIRCUIT_BREAKER_OPTIONS, ...options };\n  }\n\n  // ==========================================================================\n  // State Management\n  // ==========================================================================\n\n  getState(): CircuitState {\n    if (this.state === 'open' && this.shouldTransitionToHalfOpen()) {\n      this.transitionTo('half-open');\n    }\n    return this.state;\n  }\n\n  isOpen(): boolean {\n    return this.getState() === 'open';\n  }\n\n  isClosed(): boolean {\n    return this.getState() === 'closed';\n  }\n\n  isHalfOpen(): boolean {\n    return this.getState() === 'half-open';\n  }\n\n  private shouldTransitionToHalfOpen(): boolean {\n    return (\n      this.state === 'open' &&\n      this.lastFailure !== undefined &&\n      Date.now() - this.lastFailure >= this.options.timeout\n    );\n  }\n\n  private transitionTo(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    if (newState === 'closed') {\n      this.failures = 0;\n      this.successes = 0;\n    } else if (newState === 'half-open') {\n      this.halfOpenCalls = 0;\n      this.successes = 0;\n    }\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(oldState, newState);\n    }\n  }\n\n  // ==========================================================================\n  // Execution\n  // ==========================================================================\n\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    const state = this.getState();\n\n    if (state === 'open') {\n      throw new CircuitBreakerError('Circuit breaker is open');\n    }\n\n    if (state === 'half-open' && this.halfOpenCalls >= this.options.halfOpenLimit) {\n      throw new CircuitBreakerError('Circuit breaker half-open limit reached');\n    }\n\n    if (state === 'half-open') {\n      this.halfOpenCalls++;\n    }\n\n    try {\n      const result = await fn();\n      this.recordSuccess();\n      return result;\n    } catch (error) {\n      this.recordFailure();\n      throw error;\n    }\n  }\n\n  private recordSuccess(): void {\n    if (this.state === 'half-open') {\n      this.successes++;\n      if (this.successes >= this.options.successThreshold) {\n        this.transitionTo('closed');\n      }\n    } else if (this.state === 'closed') {\n      this.failures = 0; // Reset on success\n    }\n  }\n\n  private recordFailure(): void {\n    if (this.state === 'half-open') {\n      this.transitionTo('open');\n      this.lastFailure = Date.now();\n    } else if (this.state === 'closed') {\n      this.failures++;\n      if (this.failures >= this.options.failureThreshold) {\n        this.transitionTo('open');\n        this.lastFailure = Date.now();\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Manual Control\n  // ==========================================================================\n\n  reset(): void {\n    this.transitionTo('closed');\n    this.lastFailure = undefined;\n  }\n\n  trip(): void {\n    this.transitionTo('open');\n    this.lastFailure = Date.now();\n  }\n\n  // ==========================================================================\n  // Stats\n  // ==========================================================================\n\n  getStats(): {\n    state: CircuitState;\n    failures: number;\n    successes: number;\n    lastFailure?: number;\n  } {\n    return {\n      state: this.getState(),\n      failures: this.failures,\n      successes: this.successes,\n      lastFailure: this.lastFailure,\n    };\n  }\n}\n\nexport class CircuitBreakerError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CircuitBreakerError';\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createCircuitBreaker(options?: CircuitBreakerOptions): CircuitBreaker {\n  return new CircuitBreaker(options);\n}\n\nexport function withRetry<T extends (...args: unknown[]) => Promise<unknown>>(\n  fn: T,\n  options?: RetryOptions\n): T {\n  return ((...args: unknown[]) => retry(() => fn(...args), options)) as T;\n}\n\nexport function withCircuitBreaker<T extends (...args: unknown[]) => Promise<unknown>>(\n  fn: T,\n  breaker: CircuitBreaker\n): T {\n  return ((...args: unknown[]) => breaker.execute(() => fn(...args))) as T;\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nexport function isRetryableError(error: Error): boolean {\n  // Network errors\n  if (error.name === 'TypeError' && error.message.includes('fetch')) {\n    return true;\n  }\n\n  // Timeout errors\n  if (error instanceof TimeoutError) {\n    return true;\n  }\n\n  // Common retryable error messages\n  const retryableMessages = [\n    'ECONNRESET',\n    'ECONNREFUSED',\n    'ETIMEDOUT',\n    'ENOTFOUND',\n    'rate limit',\n    '429',\n    '503',\n    '502',\n    '504',\n  ];\n\n  return retryableMessages.some((msg) =>\n    error.message.toLowerCase().includes(msg.toLowerCase())\n  );\n}\n\nexport function createRetryableFunction<T>(\n  fn: () => Promise<T>,\n  options?: RetryOptions\n): () => Promise<RetryResult<T>> {\n  return () => retryWithResult(fn, options);\n}\n"],"mappings":"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","names":[]}