{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/dividend-engine\n *\n * Token holder dividend distribution engine.\n * Calculates pro-rata distributions, handles thresholds, and tracks payouts.\n *\n * The \"irrigation\" pattern: Revenue flows upward to token holders.\n *\n * @example\n * ```typescript\n * import { DividendEngine } from '@b0ase/dividend-engine';\n *\n * const engine = new DividendEngine();\n *\n * // Calculate distribution\n * const distribution = engine.calculateDistribution({\n *   totalAmount: 10000,\n *   currency: 'USD',\n *   holders: [\n *     { userId: 'alice', balance: 1000n, paymentHandle: '$alice' },\n *     { userId: 'bob', balance: 500n, paymentHandle: '$bob' },\n *   ],\n * });\n *\n * // Execute payments (via your payment provider)\n * for (const payment of distribution.payments) {\n *   await paymentProvider.send(payment.paymentHandle, payment.amount);\n * }\n * ```\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Token holder for distribution */\nexport interface Holder {\n  /** Unique user identifier */\n  userId: string;\n  /** Token balance */\n  balance: bigint;\n  /** Payment handle (e.g., HandCash handle, wallet address) */\n  paymentHandle?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/** Distribution calculation input */\nexport interface DistributionInput {\n  /** Total amount to distribute */\n  totalAmount: number;\n  /** Currency code */\n  currency?: string;\n  /** List of token holders */\n  holders: Holder[];\n  /** Minimum payment amount (skip smaller payments) */\n  minPayment?: number;\n  /** Distribution source/reason */\n  source?: string;\n  /** Token ID being distributed for */\n  tokenId?: string;\n}\n\n/** Individual payment in a distribution */\nexport interface DistributionPayment {\n  /** User ID */\n  userId: string;\n  /** Payment handle */\n  paymentHandle: string;\n  /** Token balance at time of distribution */\n  balance: bigint;\n  /** Share percentage (0-100) */\n  sharePercent: number;\n  /** Payment amount */\n  amount: number;\n  /** Currency */\n  currency: string;\n}\n\n/** Distribution calculation result */\nexport interface Distribution {\n  /** Unique distribution ID */\n  id: string;\n  /** Total amount distributed */\n  totalAmount: number;\n  /** Amount actually paid out (after minimums) */\n  totalDistributed: number;\n  /** Amount below minimum threshold (not distributed) */\n  belowThreshold: number;\n  /** Currency */\n  currency: string;\n  /** Source/reason */\n  source?: string;\n  /** Token ID */\n  tokenId?: string;\n  /** Total tokens across all holders */\n  totalTokens: bigint;\n  /** Per-token amount */\n  perTokenAmount: number;\n  /** Number of eligible holders */\n  eligibleHolders: number;\n  /** Number of holders below minimum */\n  belowMinimumHolders: number;\n  /** Individual payments */\n  payments: DistributionPayment[];\n  /** Timestamp */\n  calculatedAt: Date;\n}\n\n/** Waterfall tier for multi-tier distributions */\nexport interface WaterfallTier {\n  /** Tier name */\n  name: string;\n  /** Percentage of distribution (0-100) */\n  percentage: number;\n  /** Holders in this tier */\n  holders: Holder[];\n}\n\n/** Waterfall distribution input */\nexport interface WaterfallInput {\n  /** Total amount to distribute */\n  totalAmount: number;\n  /** Currency code */\n  currency?: string;\n  /** Waterfall tiers (must sum to 100%) */\n  tiers: WaterfallTier[];\n  /** Minimum payment amount */\n  minPayment?: number;\n  /** Distribution source */\n  source?: string;\n}\n\n/** Threshold trigger for automatic distributions */\nexport interface DistributionTrigger {\n  /** Trigger type */\n  type: 'amount' | 'time' | 'manual';\n  /** Threshold amount (for 'amount' type) */\n  thresholdAmount?: number;\n  /** Interval in ms (for 'time' type) */\n  intervalMs?: number;\n}\n\n/** Distribution configuration */\nexport interface DistributionConfig {\n  /** Minimum payment amount */\n  minPayment: number;\n  /** Default currency */\n  currency: string;\n  /** Distribution trigger */\n  trigger?: DistributionTrigger;\n  /** Whether to include holders without payment handles */\n  includeWithoutHandles: boolean;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nconst DEFAULT_CONFIG: DistributionConfig = {\n  minPayment: 0.01,\n  currency: 'USD',\n  includeWithoutHandles: false,\n};\n\n// ============================================================================\n// Dividend Engine Class\n// ============================================================================\n\n/**\n * Dividend Distribution Engine\n *\n * Calculates and manages pro-rata distributions to token holders.\n */\nexport class DividendEngine {\n  readonly config: DistributionConfig;\n\n  constructor(config: Partial<DistributionConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Generate unique distribution ID\n   */\n  private generateId(): string {\n    return `dist-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Calculate pro-rata distribution\n   */\n  calculateDistribution(input: DistributionInput): Distribution {\n    const {\n      totalAmount,\n      currency = this.config.currency,\n      holders,\n      minPayment = this.config.minPayment,\n      source,\n      tokenId,\n    } = input;\n\n    // Filter holders with balance > 0\n    const activeHolders = holders.filter((h) => h.balance > BigInt(0));\n\n    // Calculate total tokens\n    const totalTokens = activeHolders.reduce(\n      (sum, h) => sum + h.balance,\n      BigInt(0)\n    );\n\n    if (totalTokens === BigInt(0)) {\n      return {\n        id: this.generateId(),\n        totalAmount,\n        totalDistributed: 0,\n        belowThreshold: totalAmount,\n        currency,\n        source,\n        tokenId,\n        totalTokens: BigInt(0),\n        perTokenAmount: 0,\n        eligibleHolders: 0,\n        belowMinimumHolders: 0,\n        payments: [],\n        calculatedAt: new Date(),\n      };\n    }\n\n    // Calculate per-token amount\n    const perTokenAmount = totalAmount / Number(totalTokens);\n\n    // Calculate individual payments\n    const payments: DistributionPayment[] = [];\n    let totalDistributed = 0;\n    let belowThreshold = 0;\n    let belowMinimumHolders = 0;\n\n    for (const holder of activeHolders) {\n      // Skip holders without payment handles if configured\n      if (!this.config.includeWithoutHandles && !holder.paymentHandle) {\n        continue;\n      }\n\n      const sharePercent =\n        (Number(holder.balance) / Number(totalTokens)) * 100;\n      const amount = Number(holder.balance) * perTokenAmount;\n\n      // Round to cents\n      const roundedAmount = Math.round(amount * 100) / 100;\n\n      if (roundedAmount >= minPayment) {\n        payments.push({\n          userId: holder.userId,\n          paymentHandle: holder.paymentHandle || holder.userId,\n          balance: holder.balance,\n          sharePercent,\n          amount: roundedAmount,\n          currency,\n        });\n        totalDistributed += roundedAmount;\n      } else {\n        belowThreshold += roundedAmount;\n        belowMinimumHolders++;\n      }\n    }\n\n    return {\n      id: this.generateId(),\n      totalAmount,\n      totalDistributed,\n      belowThreshold,\n      currency,\n      source,\n      tokenId,\n      totalTokens,\n      perTokenAmount,\n      eligibleHolders: payments.length,\n      belowMinimumHolders,\n      payments,\n      calculatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Calculate waterfall distribution (multi-tier)\n   */\n  calculateWaterfall(input: WaterfallInput): Distribution[] {\n    const {\n      totalAmount,\n      currency = this.config.currency,\n      tiers,\n      minPayment = this.config.minPayment,\n      source,\n    } = input;\n\n    // Validate tiers sum to 100%\n    const tierSum = tiers.reduce((sum, t) => sum + t.percentage, 0);\n    if (Math.abs(tierSum - 100) > 0.01) {\n      throw new Error(`Waterfall tiers must sum to 100%, got ${tierSum}%`);\n    }\n\n    // Calculate distribution for each tier\n    return tiers.map((tier) => {\n      const tierAmount = (totalAmount * tier.percentage) / 100;\n      return this.calculateDistribution({\n        totalAmount: tierAmount,\n        currency,\n        holders: tier.holders,\n        minPayment,\n        source: source ? `${source} - ${tier.name}` : tier.name,\n      });\n    });\n  }\n\n  /**\n   * Calculate distribution with fixed splits (e.g., 70% to holders, 30% to treasury)\n   */\n  calculateSplit(input: {\n    totalAmount: number;\n    currency?: string;\n    splits: Array<{\n      name: string;\n      percentage: number;\n      destination: 'holders' | 'fixed';\n      holders?: Holder[];\n      fixedAddress?: string;\n    }>;\n    minPayment?: number;\n    source?: string;\n  }): {\n    distributions: Distribution[];\n    fixedPayments: Array<{ name: string; address: string; amount: number }>;\n  } {\n    const distributions: Distribution[] = [];\n    const fixedPayments: Array<{ name: string; address: string; amount: number }> = [];\n\n    for (const split of input.splits) {\n      const amount = (input.totalAmount * split.percentage) / 100;\n\n      if (split.destination === 'holders' && split.holders) {\n        distributions.push(\n          this.calculateDistribution({\n            totalAmount: amount,\n            currency: input.currency,\n            holders: split.holders,\n            minPayment: input.minPayment,\n            source: input.source ? `${input.source} - ${split.name}` : split.name,\n          })\n        );\n      } else if (split.destination === 'fixed' && split.fixedAddress) {\n        fixedPayments.push({\n          name: split.name,\n          address: split.fixedAddress,\n          amount,\n        });\n      }\n    }\n\n    return { distributions, fixedPayments };\n  }\n\n  /**\n   * Simulate distribution without executing\n   */\n  simulate(input: DistributionInput): {\n    distribution: Distribution;\n    summary: {\n      totalHolders: number;\n      eligibleHolders: number;\n      largestPayment: number;\n      smallestPayment: number;\n      medianPayment: number;\n      averagePayment: number;\n    };\n  } {\n    const distribution = this.calculateDistribution(input);\n    const amounts = distribution.payments.map((p) => p.amount).sort((a, b) => a - b);\n\n    return {\n      distribution,\n      summary: {\n        totalHolders: input.holders.length,\n        eligibleHolders: distribution.eligibleHolders,\n        largestPayment: amounts[amounts.length - 1] || 0,\n        smallestPayment: amounts[0] || 0,\n        medianPayment: amounts[Math.floor(amounts.length / 2)] || 0,\n        averagePayment:\n          distribution.eligibleHolders > 0\n            ? distribution.totalDistributed / distribution.eligibleHolders\n            : 0,\n      },\n    };\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a dividend engine with custom configuration\n */\nexport function createDividendEngine(\n  config: Partial<DistributionConfig> = {}\n): DividendEngine {\n  return new DividendEngine(config);\n}\n\n/**\n * Quick calculation without creating an engine instance\n */\nexport function calculateProRata(\n  totalAmount: number,\n  holders: Holder[],\n  options: { minPayment?: number; currency?: string } = {}\n): Distribution {\n  const engine = new DividendEngine(options);\n  return engine.calculateDistribution({\n    totalAmount,\n    holders,\n    ...options,\n  });\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Calculate share percentage for a holder\n */\nexport function calculateSharePercent(\n  balance: bigint,\n  totalSupply: bigint\n): number {\n  if (totalSupply === BigInt(0)) return 0;\n  return (Number(balance) / Number(totalSupply)) * 100;\n}\n\n/**\n * Format payment amount for display\n */\nexport function formatPaymentAmount(\n  amount: number,\n  currency: string = 'USD'\n): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  }).format(amount);\n}\n\n/**\n * Group payments by amount range for analysis\n */\nexport function groupPaymentsByRange(\n  payments: DistributionPayment[]\n): Record<string, DistributionPayment[]> {\n  const ranges: Record<string, DistributionPayment[]> = {\n    'micro (<$1)': [],\n    'small ($1-$10)': [],\n    'medium ($10-$100)': [],\n    'large ($100-$1000)': [],\n    'whale (>$1000)': [],\n  };\n\n  for (const payment of payments) {\n    if (payment.amount < 1) {\n      ranges['micro (<$1)'].push(payment);\n    } else if (payment.amount < 10) {\n      ranges['small ($1-$10)'].push(payment);\n    } else if (payment.amount < 100) {\n      ranges['medium ($10-$100)'].push(payment);\n    } else if (payment.amount < 1000) {\n      ranges['large ($100-$1000)'].push(payment);\n    } else {\n      ranges['whale (>$1000)'].push(payment);\n    }\n  }\n\n  return ranges;\n}\n"],"mappings":"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","names":[]}