{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/bonding-curve\n *\n * Generalized bonding curve implementation for token fair launches.\n * Supports exponential, linear, and sigmoid curve types.\n *\n * @example\n * ```typescript\n * import { BondingCurve, CURVE_PRESETS } from '@b0ase/bonding-curve';\n *\n * // Create a pump.fun style curve\n * const curve = new BondingCurve(CURVE_PRESETS.pumpFun);\n *\n * // Get current price\n * const tokensSold = BigInt(1_000_000);\n * const price = curve.getCurrentPrice(tokensSold);\n *\n * // Calculate tokens for a $100 purchase\n * const tokens = curve.getTokensForPayment(tokensSold, 100);\n *\n * // Get visualization data\n * const points = curve.getCurvePoints(100);\n * ```\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Supported curve types */\nexport type CurveType = 'exponential' | 'linear' | 'sigmoid';\n\n/** Bonding curve configuration */\nexport interface BondingCurveConfig {\n  /** Token name */\n  name: string;\n  /** Token symbol */\n  symbol: string;\n  /** Total token supply */\n  totalSupply: bigint;\n  /** Minimum price (first token) */\n  minPrice: number;\n  /** Maximum price (last token) */\n  maxPrice: number;\n  /** Curve type */\n  curveType: CurveType;\n  /** Sigmoid steepness (only for sigmoid curve) */\n  sigmoidK?: number;\n}\n\n/** Curve data point for visualization */\nexport interface CurvePoint {\n  tokenIndex: number;\n  tokensSold: number;\n  price: number;\n  percentSold: number;\n}\n\n/** Milestone on the curve */\nexport interface Milestone {\n  label: string;\n  tokenIndex: number;\n  price: number;\n  percentSold: number;\n}\n\n/** Purchase quote */\nexport interface PurchaseQuote {\n  tokensReceived: bigint;\n  totalCost: number;\n  averagePrice: number;\n  newPrice: number;\n  priceImpact: number;\n}\n\n/** Sale quote */\nexport interface SaleQuote {\n  tokensToSell: bigint;\n  totalReceived: number;\n  averagePrice: number;\n  newPrice: number;\n  priceImpact: number;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\n/**\n * Default configuration for a \"fair launch\" style curve\n * Similar to Pump.fun - massive early advantage, premium for late buyers\n */\nexport const DEFAULT_CONFIG: BondingCurveConfig = {\n  name: 'Token',\n  symbol: 'TOKEN',\n  totalSupply: BigInt(1_000_000_000), // 1 billion tokens\n  minPrice: 0.0000001, // $0.0000001 (one ten-millionth)\n  maxPrice: 1_000_000, // $1,000,000\n  curveType: 'exponential',\n};\n\n/**\n * Preset configurations for different use cases\n */\nexport const CURVE_PRESETS = {\n  /** Pump.fun style - 13 orders of magnitude */\n  pumpFun: {\n    ...DEFAULT_CONFIG,\n    name: 'Fair Launch Token',\n    symbol: 'PUMP',\n  } as BondingCurveConfig,\n\n  /** More conservative - 6 orders of magnitude */\n  conservative: {\n    ...DEFAULT_CONFIG,\n    name: 'Conservative Token',\n    symbol: 'SAFE',\n    minPrice: 0.001,\n    maxPrice: 1000,\n  } as BondingCurveConfig,\n\n  /** Linear curve - predictable pricing */\n  linear: {\n    ...DEFAULT_CONFIG,\n    name: 'Linear Token',\n    symbol: 'LINE',\n    minPrice: 0.01,\n    maxPrice: 100,\n    curveType: 'linear' as CurveType,\n  } as BondingCurveConfig,\n\n  /** Sigmoid curve - S-shaped, slower start and end */\n  sigmoid: {\n    ...DEFAULT_CONFIG,\n    name: 'Sigmoid Token',\n    symbol: 'SIG',\n    minPrice: 0.001,\n    maxPrice: 1000,\n    curveType: 'sigmoid' as CurveType,\n    sigmoidK: 0.00000001,\n  } as BondingCurveConfig,\n\n  /** Small community token - 1M supply */\n  community: {\n    ...DEFAULT_CONFIG,\n    name: 'Community Token',\n    symbol: 'COMM',\n    totalSupply: BigInt(1_000_000),\n    minPrice: 0.01,\n    maxPrice: 100,\n  } as BondingCurveConfig,\n\n  /** Micro cap - 10K supply, high value */\n  microCap: {\n    ...DEFAULT_CONFIG,\n    name: 'Micro Token',\n    symbol: 'MICRO',\n    totalSupply: BigInt(10_000),\n    minPrice: 1,\n    maxPrice: 10_000,\n  } as BondingCurveConfig,\n};\n\n// ============================================================================\n// Bonding Curve Class\n// ============================================================================\n\n/**\n * Bonding Curve Calculator\n *\n * Handles all price calculations for token bonding curves.\n */\nexport class BondingCurve {\n  readonly config: BondingCurveConfig;\n  readonly logMin: number;\n  readonly logMax: number;\n  readonly logRange: number;\n\n  constructor(config: Partial<BondingCurveConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.logMin = Math.log10(this.config.minPrice);\n    this.logMax = Math.log10(this.config.maxPrice);\n    this.logRange = this.logMax - this.logMin;\n  }\n\n  /**\n   * Get the price at a specific token index (0-indexed)\n   */\n  getPriceAtToken(tokenIndex: number): number {\n    const total = Number(this.config.totalSupply) - 1;\n\n    if (tokenIndex <= 0) return this.config.minPrice;\n    if (tokenIndex >= total) return this.config.maxPrice;\n\n    const n = tokenIndex;\n    const { minPrice, maxPrice, curveType, sigmoidK } = this.config;\n\n    switch (curveType) {\n      case 'exponential': {\n        const logPrice = this.logMin + (this.logRange * n) / total;\n        return Math.pow(10, logPrice);\n      }\n\n      case 'linear': {\n        return minPrice + ((maxPrice - minPrice) * n) / total;\n      }\n\n      case 'sigmoid': {\n        const k = sigmoidK || 0.00000001;\n        const midpoint = total / 2;\n        const sigmoid = 1 / (1 + Math.exp(-k * (n - midpoint)));\n        return minPrice + (maxPrice - minPrice) * sigmoid;\n      }\n\n      default:\n        return minPrice;\n    }\n  }\n\n  /**\n   * Get the current price based on tokens already sold\n   */\n  getCurrentPrice(tokensSold: bigint): number {\n    return this.getPriceAtToken(Number(tokensSold));\n  }\n\n  /**\n   * Get the token index at a specific price (inverse of getPriceAtToken)\n   */\n  getTokenAtPrice(price: number): number {\n    const total = Number(this.config.totalSupply) - 1;\n    const { minPrice, maxPrice, curveType, sigmoidK } = this.config;\n\n    if (price <= minPrice) return 0;\n    if (price >= maxPrice) return total;\n\n    switch (curveType) {\n      case 'exponential': {\n        const logPrice = Math.log10(price);\n        return Math.floor(((logPrice - this.logMin) / this.logRange) * total);\n      }\n\n      case 'linear': {\n        return Math.floor(((price - minPrice) / (maxPrice - minPrice)) * total);\n      }\n\n      case 'sigmoid': {\n        const k = sigmoidK || 0.00000001;\n        const midpoint = total / 2;\n        const normalizedPrice = (price - minPrice) / (maxPrice - minPrice);\n        if (normalizedPrice <= 0 || normalizedPrice >= 1) return midpoint;\n        return Math.floor(\n          -Math.log((1 - normalizedPrice) / normalizedPrice) / k + midpoint\n        );\n      }\n\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Calculate how many tokens a user gets for a given payment\n   */\n  getTokensForPayment(tokensSold: bigint, paymentUSD: number): bigint {\n    if (paymentUSD <= 0) return BigInt(0);\n\n    const startIndex = Number(tokensSold);\n    const total = Number(this.config.totalSupply);\n    let remaining = paymentUSD;\n    let tokensReceived = 0;\n\n    const step = Math.max(1, Math.floor(total / 10000));\n\n    for (let i = startIndex; i < total && remaining > 0; i += step) {\n      const price = this.getPriceAtToken(i);\n      const maxTokensAtPrice = Math.min(step, total - i);\n      const costForStep = price * maxTokensAtPrice;\n\n      if (costForStep <= remaining) {\n        remaining -= costForStep;\n        tokensReceived += maxTokensAtPrice;\n      } else {\n        const tokensBuyable = Math.floor(remaining / price);\n        tokensReceived += tokensBuyable;\n        break;\n      }\n    }\n\n    const maxTokens = total - startIndex;\n    return BigInt(Math.min(tokensReceived, maxTokens));\n  }\n\n  /**\n   * Calculate the cost to buy a specific number of tokens\n   */\n  getCostForTokens(tokensSold: bigint, tokensToBuy: bigint): number {\n    if (tokensToBuy <= BigInt(0)) return 0;\n\n    const startIndex = Number(tokensSold);\n    const endIndex = Math.min(\n      startIndex + Number(tokensToBuy),\n      Number(this.config.totalSupply) - 1\n    );\n\n    if (Number(tokensToBuy) < 1000) {\n      const startPrice = this.getPriceAtToken(startIndex);\n      const endPrice = this.getPriceAtToken(endIndex);\n      return ((startPrice + endPrice) / 2) * Number(tokensToBuy);\n    }\n\n    let totalCost = 0;\n    const numSteps = 100;\n    const stepSize = (endIndex - startIndex) / numSteps;\n\n    for (let i = 0; i < numSteps; i++) {\n      const idx1 = startIndex + i * stepSize;\n      const idx2 = startIndex + (i + 1) * stepSize;\n      const p1 = this.getPriceAtToken(Math.floor(idx1));\n      const p2 = this.getPriceAtToken(Math.floor(idx2));\n      totalCost += ((p1 + p2) / 2) * stepSize;\n    }\n\n    return totalCost;\n  }\n\n  /**\n   * Get a full purchase quote with price impact\n   */\n  getPurchaseQuote(tokensSold: bigint, paymentUSD: number): PurchaseQuote {\n    const currentPrice = this.getCurrentPrice(tokensSold);\n    const tokensReceived = this.getTokensForPayment(tokensSold, paymentUSD);\n    const totalCost = this.getCostForTokens(tokensSold, tokensReceived);\n    const newTokensSold = tokensSold + tokensReceived;\n    const newPrice = this.getCurrentPrice(newTokensSold);\n\n    return {\n      tokensReceived,\n      totalCost,\n      averagePrice: Number(tokensReceived) > 0 ? totalCost / Number(tokensReceived) : 0,\n      newPrice,\n      priceImpact: currentPrice > 0 ? ((newPrice - currentPrice) / currentPrice) * 100 : 0,\n    };\n  }\n\n  /**\n   * Get market cap at current supply level\n   */\n  getMarketCap(tokensSold: bigint): number {\n    const currentPrice = this.getCurrentPrice(tokensSold);\n    return currentPrice * Number(tokensSold);\n  }\n\n  /**\n   * Get fully diluted valuation\n   */\n  getFDV(tokensSold: bigint): number {\n    const currentPrice = this.getCurrentPrice(tokensSold);\n    return currentPrice * Number(this.config.totalSupply);\n  }\n\n  /**\n   * Get progress percentage (0-100)\n   */\n  getProgress(tokensSold: bigint): number {\n    return (Number(tokensSold) / Number(this.config.totalSupply)) * 100;\n  }\n\n  /**\n   * Get remaining supply\n   */\n  getRemainingSupply(tokensSold: bigint): bigint {\n    return this.config.totalSupply - tokensSold;\n  }\n\n  /**\n   * Generate curve data points for visualization\n   */\n  getCurvePoints(numPoints: number = 100): CurvePoint[] {\n    const total = Number(this.config.totalSupply);\n    const points: CurvePoint[] = [];\n\n    for (let i = 0; i <= numPoints; i++) {\n      const tokenIndex = Math.floor((i / numPoints) * (total - 1));\n      const price = this.getPriceAtToken(tokenIndex);\n      points.push({\n        tokenIndex,\n        tokensSold: tokenIndex + 1,\n        price,\n        percentSold: ((tokenIndex + 1) / total) * 100,\n      });\n    }\n\n    return points;\n  }\n\n  /**\n   * Get key milestones with prices\n   */\n  getMilestones(): Milestone[] {\n    const total = Number(this.config.totalSupply);\n    const milestonePercents = [0, 0.1, 1, 10, 25, 50, 75, 90, 99, 99.9, 100];\n\n    return milestonePercents.map((percent) => {\n      const tokenIndex = Math.floor((percent / 100) * (total - 1));\n      return {\n        label:\n          percent === 0\n            ? 'First token'\n            : percent === 100\n              ? 'Last token'\n              : `${percent}% sold`,\n        tokenIndex,\n        price: this.getPriceAtToken(tokenIndex),\n        percentSold: percent,\n      };\n    });\n  }\n}\n\n// ============================================================================\n// Formatting Utilities\n// ============================================================================\n\n/**\n * Format price for display - always readable, never scientific notation\n */\nexport function formatPrice(price: number): string {\n  if (price >= 1_000_000) return `$${(price / 1_000_000).toFixed(1)}M`;\n  if (price >= 1_000) return `$${(price / 1_000).toFixed(1)}K`;\n  if (price >= 1) return `$${price.toFixed(2)}`;\n  if (price >= 0.01) return `$${price.toFixed(2)}`;\n  if (price >= 0.001) return `$${price.toFixed(3)}`;\n  if (price >= 0.0001) return `$${price.toFixed(4)}`;\n  if (price >= 0.00001) return `$${price.toFixed(5)}`;\n  if (price >= 0.000001) return `$${price.toFixed(6)}`;\n  if (price >= 0.0000001) return `$${price.toFixed(7)}`;\n  if (price >= 0.00000001) return `$${price.toFixed(8)}`;\n  if (price >= 0.000000001) return `$${price.toFixed(9)}`;\n  return `$${price.toFixed(10)}`;\n}\n\n/**\n * Format large numbers with K/M/B suffixes\n */\nexport function formatNumber(n: bigint | number): string {\n  const num = typeof n === 'bigint' ? Number(n) : n;\n  if (num >= 1_000_000_000) return `${(num / 1_000_000_000).toFixed(2)}B`;\n  if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(1)}M`;\n  if (num >= 1_000) return `${(num / 1_000).toFixed(1)}K`;\n  return num.toLocaleString();\n}\n\n/**\n * Format currency with proper symbols\n */\nexport function formatCurrency(amount: number, currency: string = 'USD'): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  }).format(amount);\n}\n\n/**\n * Create a new bonding curve with custom configuration\n */\nexport function createBondingCurve(\n  config: Partial<BondingCurveConfig> = {}\n): BondingCurve {\n  return new BondingCurve(config);\n}\n"],"mappings":"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","names":[]}