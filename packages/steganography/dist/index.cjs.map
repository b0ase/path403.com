{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/steganography\n *\n * Hide and extract data in images using steganography techniques.\n * Supports LSB (Least Significant Bit) encoding with optional encryption.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Encoding method */\nexport type EncodingMethod = 'lsb' | 'lsb-rgb' | 'lsb-rgba' | 'dct';\n\n/** Encryption type */\nexport type EncryptionType = 'none' | 'xor' | 'aes';\n\n/** Color channel */\nexport type Channel = 'r' | 'g' | 'b' | 'a';\n\n/** Encode options */\nexport interface EncodeOptions {\n  method?: EncodingMethod;\n  channels?: Channel[];\n  bitsPerChannel?: number;\n  encryption?: EncryptionType;\n  password?: string;\n  spread?: boolean;\n  seed?: number;\n}\n\n/** Decode options */\nexport interface DecodeOptions {\n  method?: EncodingMethod;\n  channels?: Channel[];\n  bitsPerChannel?: number;\n  encryption?: EncryptionType;\n  password?: string;\n  spread?: boolean;\n  seed?: number;\n}\n\n/** Image data wrapper */\nexport interface ImageData {\n  width: number;\n  height: number;\n  data: Uint8ClampedArray;\n}\n\n/** Encode result */\nexport interface EncodeResult {\n  imageData: ImageData;\n  bytesEncoded: number;\n  capacity: number;\n  usedCapacity: number;\n}\n\n/** Decode result */\nexport interface DecodeResult {\n  data: Uint8Array;\n  text?: string;\n  bytesDecoded: number;\n}\n\n/** Capacity analysis */\nexport interface CapacityAnalysis {\n  totalBytes: number;\n  usableBytes: number;\n  maxMessageLength: number;\n  bitsPerPixel: number;\n  pixelCount: number;\n}\n\n/** Detection result */\nexport interface DetectionResult {\n  hasHiddenData: boolean;\n  confidence: number;\n  method?: EncodingMethod;\n  estimatedSize?: number;\n  indicators: string[];\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nexport const MAGIC_HEADER = new Uint8Array([0x53, 0x54, 0x45, 0x47]); // \"STEG\"\nexport const HEADER_SIZE = 12; // Magic (4) + Length (4) + Options (4)\nexport const DEFAULT_OPTIONS: Required<EncodeOptions> = {\n  method: 'lsb',\n  channels: ['r', 'g', 'b'],\n  bitsPerChannel: 1,\n  encryption: 'none',\n  password: '',\n  spread: false,\n  seed: 0,\n};\n\n// ============================================================================\n// Steganography Engine\n// ============================================================================\n\nexport class SteganographyEngine {\n  private options: Required<EncodeOptions>;\n\n  constructor(options: EncodeOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  // ==========================================================================\n  // Encoding\n  // ==========================================================================\n\n  encode(imageData: ImageData, message: string | Uint8Array): EncodeResult {\n    const data = typeof message === 'string' ? this.stringToBytes(message) : message;\n\n    // Check capacity\n    const capacity = this.calculateCapacity(imageData);\n    if (data.length + HEADER_SIZE > capacity.usableBytes) {\n      throw new Error(\n        `Message too large. Max: ${capacity.usableBytes - HEADER_SIZE} bytes, Got: ${data.length} bytes`\n      );\n    }\n\n    // Prepare payload with header\n    const payload = this.preparePayload(data);\n\n    // Optionally encrypt\n    const finalPayload =\n      this.options.encryption !== 'none' ? this.encrypt(payload, this.options.password) : payload;\n\n    // Encode into image\n    const result = this.encodePayload(imageData, finalPayload);\n\n    return {\n      imageData: result,\n      bytesEncoded: data.length,\n      capacity: capacity.usableBytes,\n      usedCapacity: (finalPayload.length / capacity.usableBytes) * 100,\n    };\n  }\n\n  encodeText(imageData: ImageData, text: string): EncodeResult {\n    return this.encode(imageData, text);\n  }\n\n  encodeFile(imageData: ImageData, fileData: Uint8Array, filename: string): EncodeResult {\n    // Prepend filename to data\n    const filenameBytes = this.stringToBytes(filename);\n    const combined = new Uint8Array(2 + filenameBytes.length + fileData.length);\n    combined[0] = (filenameBytes.length >> 8) & 0xff;\n    combined[1] = filenameBytes.length & 0xff;\n    combined.set(filenameBytes, 2);\n    combined.set(fileData, 2 + filenameBytes.length);\n\n    return this.encode(imageData, combined);\n  }\n\n  // ==========================================================================\n  // Decoding\n  // ==========================================================================\n\n  decode(imageData: ImageData, options?: DecodeOptions): DecodeResult {\n    const opts = { ...this.options, ...options };\n\n    // Extract payload from image\n    const payload = this.extractPayload(imageData, opts);\n\n    // Optionally decrypt\n    const decrypted = opts.encryption !== 'none' ? this.decrypt(payload, opts.password!) : payload;\n\n    // Validate and parse header\n    const { data, length } = this.parsePayload(decrypted);\n\n    return {\n      data,\n      text: this.bytesToString(data),\n      bytesDecoded: length,\n    };\n  }\n\n  decodeText(imageData: ImageData, options?: DecodeOptions): string {\n    const result = this.decode(imageData, options);\n    return result.text || '';\n  }\n\n  decodeFile(\n    imageData: ImageData,\n    options?: DecodeOptions\n  ): { filename: string; data: Uint8Array } {\n    const result = this.decode(imageData, options);\n\n    // Parse filename from data\n    const filenameLength = (result.data[0] << 8) | result.data[1];\n    const filename = this.bytesToString(result.data.slice(2, 2 + filenameLength));\n    const fileData = result.data.slice(2 + filenameLength);\n\n    return { filename, data: fileData };\n  }\n\n  // ==========================================================================\n  // Analysis\n  // ==========================================================================\n\n  calculateCapacity(imageData: ImageData): CapacityAnalysis {\n    const pixelCount = imageData.width * imageData.height;\n    const bitsPerPixel = this.options.channels.length * this.options.bitsPerChannel;\n    const totalBits = pixelCount * bitsPerPixel;\n    const totalBytes = Math.floor(totalBits / 8);\n    const usableBytes = totalBytes - HEADER_SIZE;\n\n    return {\n      totalBytes,\n      usableBytes: Math.max(0, usableBytes),\n      maxMessageLength: Math.max(0, usableBytes),\n      bitsPerPixel,\n      pixelCount,\n    };\n  }\n\n  detect(imageData: ImageData): DetectionResult {\n    const indicators: string[] = [];\n    let confidence = 0;\n\n    // Check for magic header\n    try {\n      const firstBytes = this.extractBits(imageData, HEADER_SIZE * 8);\n      const hasMagic = this.checkMagicHeader(this.bitsToBytes(firstBytes));\n      if (hasMagic) {\n        indicators.push('Magic header detected');\n        confidence += 50;\n      }\n    } catch {\n      // Ignore extraction errors\n    }\n\n    // Statistical analysis - check LSB distribution\n    const lsbStats = this.analyzeLSB(imageData);\n    if (lsbStats.anomalyScore > 0.3) {\n      indicators.push('LSB distribution anomaly');\n      confidence += 20;\n    }\n\n    // Check for patterns in LSB\n    if (lsbStats.hasPatterns) {\n      indicators.push('Repeating patterns in LSB');\n      confidence += 15;\n    }\n\n    // Check chi-square test\n    if (lsbStats.chiSquare > 0.05) {\n      indicators.push('Chi-square test indicates hidden data');\n      confidence += 15;\n    }\n\n    return {\n      hasHiddenData: confidence >= 50,\n      confidence: Math.min(100, confidence),\n      method: confidence >= 50 ? 'lsb' : undefined,\n      estimatedSize: confidence >= 50 ? this.estimateHiddenSize(imageData) : undefined,\n      indicators,\n    };\n  }\n\n  // ==========================================================================\n  // Private Methods - Encoding\n  // ==========================================================================\n\n  private preparePayload(data: Uint8Array): Uint8Array {\n    const payload = new Uint8Array(HEADER_SIZE + data.length);\n\n    // Magic header\n    payload.set(MAGIC_HEADER, 0);\n\n    // Length (4 bytes, big endian)\n    payload[4] = (data.length >> 24) & 0xff;\n    payload[5] = (data.length >> 16) & 0xff;\n    payload[6] = (data.length >> 8) & 0xff;\n    payload[7] = data.length & 0xff;\n\n    // Options flags (4 bytes)\n    payload[8] = this.options.method === 'lsb' ? 0 : 1;\n    payload[9] = this.options.bitsPerChannel;\n    payload[10] = this.encodeChannels(this.options.channels);\n    payload[11] = this.options.spread ? 1 : 0;\n\n    // Data\n    payload.set(data, HEADER_SIZE);\n\n    return payload;\n  }\n\n  private encodePayload(imageData: ImageData, payload: Uint8Array): ImageData {\n    const result: ImageData = {\n      width: imageData.width,\n      height: imageData.height,\n      data: new Uint8ClampedArray(imageData.data),\n    };\n\n    const bits = this.bytesToBits(payload);\n    let bitIndex = 0;\n\n    if (this.options.spread) {\n      // Spread encoding using PRNG\n      const positions = this.generatePositions(\n        bits.length,\n        imageData.width * imageData.height,\n        this.options.seed\n      );\n\n      for (const pos of positions) {\n        if (bitIndex >= bits.length) break;\n\n        const pixelIndex = pos * 4;\n        for (const channel of this.options.channels) {\n          if (bitIndex >= bits.length) break;\n\n          const channelOffset = this.getChannelOffset(channel);\n          result.data[pixelIndex + channelOffset] = this.setBit(\n            result.data[pixelIndex + channelOffset],\n            0,\n            bits[bitIndex++]\n          );\n        }\n      }\n    } else {\n      // Sequential encoding\n      for (let i = 0; i < result.data.length && bitIndex < bits.length; i += 4) {\n        for (const channel of this.options.channels) {\n          if (bitIndex >= bits.length) break;\n\n          const channelOffset = this.getChannelOffset(channel);\n          for (let bit = 0; bit < this.options.bitsPerChannel; bit++) {\n            if (bitIndex >= bits.length) break;\n            result.data[i + channelOffset] = this.setBit(\n              result.data[i + channelOffset],\n              bit,\n              bits[bitIndex++]\n            );\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // ==========================================================================\n  // Private Methods - Decoding\n  // ==========================================================================\n\n  private extractPayload(imageData: ImageData, options: Required<EncodeOptions>): Uint8Array {\n    // First extract header to get length\n    const headerBits = this.extractBits(imageData, HEADER_SIZE * 8, options);\n    const header = this.bitsToBytes(headerBits);\n\n    // Validate magic\n    if (!this.checkMagicHeader(header)) {\n      throw new Error('No hidden data found or invalid format');\n    }\n\n    // Get length\n    const length = (header[4] << 24) | (header[5] << 16) | (header[6] << 8) | header[7];\n\n    if (length <= 0 || length > this.calculateCapacity(imageData).usableBytes) {\n      throw new Error('Invalid data length');\n    }\n\n    // Extract full payload\n    const totalBits = (HEADER_SIZE + length) * 8;\n    const allBits = this.extractBits(imageData, totalBits, options);\n\n    return this.bitsToBytes(allBits);\n  }\n\n  private extractBits(\n    imageData: ImageData,\n    count: number,\n    options?: Required<EncodeOptions>\n  ): number[] {\n    const opts = options || this.options;\n    const bits: number[] = [];\n\n    if (opts.spread) {\n      const positions = this.generatePositions(\n        count,\n        imageData.width * imageData.height,\n        opts.seed\n      );\n\n      for (const pos of positions) {\n        if (bits.length >= count) break;\n\n        const pixelIndex = pos * 4;\n        for (const channel of opts.channels) {\n          if (bits.length >= count) break;\n\n          const channelOffset = this.getChannelOffset(channel);\n          bits.push(this.getBit(imageData.data[pixelIndex + channelOffset], 0));\n        }\n      }\n    } else {\n      for (let i = 0; i < imageData.data.length && bits.length < count; i += 4) {\n        for (const channel of opts.channels) {\n          if (bits.length >= count) break;\n\n          const channelOffset = this.getChannelOffset(channel);\n          for (let bit = 0; bit < opts.bitsPerChannel; bit++) {\n            if (bits.length >= count) break;\n            bits.push(this.getBit(imageData.data[i + channelOffset], bit));\n          }\n        }\n      }\n    }\n\n    return bits;\n  }\n\n  private parsePayload(payload: Uint8Array): { data: Uint8Array; length: number } {\n    if (!this.checkMagicHeader(payload)) {\n      throw new Error('Invalid payload format');\n    }\n\n    const length = (payload[4] << 24) | (payload[5] << 16) | (payload[6] << 8) | payload[7];\n    const data = payload.slice(HEADER_SIZE, HEADER_SIZE + length);\n\n    return { data, length };\n  }\n\n  // ==========================================================================\n  // Private Methods - Encryption\n  // ==========================================================================\n\n  private encrypt(data: Uint8Array, password: string): Uint8Array {\n    if (this.options.encryption === 'xor') {\n      return this.xorCipher(data, password);\n    }\n    // AES would require external library - simplified for now\n    return data;\n  }\n\n  private decrypt(data: Uint8Array, password: string): Uint8Array {\n    if (this.options.encryption === 'xor') {\n      return this.xorCipher(data, password);\n    }\n    return data;\n  }\n\n  private xorCipher(data: Uint8Array, key: string): Uint8Array {\n    const keyBytes = this.stringToBytes(key);\n    const result = new Uint8Array(data.length);\n\n    for (let i = 0; i < data.length; i++) {\n      result[i] = data[i] ^ keyBytes[i % keyBytes.length];\n    }\n\n    return result;\n  }\n\n  // ==========================================================================\n  // Private Methods - Analysis\n  // ==========================================================================\n\n  private analyzeLSB(imageData: ImageData): {\n    anomalyScore: number;\n    hasPatterns: boolean;\n    chiSquare: number;\n  } {\n    let zeros = 0;\n    let ones = 0;\n    const lsbSequence: number[] = [];\n\n    for (let i = 0; i < Math.min(imageData.data.length, 10000); i += 4) {\n      const lsb = imageData.data[i] & 1;\n      lsbSequence.push(lsb);\n      if (lsb === 0) zeros++;\n      else ones++;\n    }\n\n    // Calculate anomaly score (0-1, higher = more anomalous)\n    const total = zeros + ones;\n    const expectedHalf = total / 2;\n    const anomalyScore = Math.abs(zeros - expectedHalf) / expectedHalf;\n\n    // Check for patterns\n    let patternCount = 0;\n    for (let i = 0; i < lsbSequence.length - 8; i++) {\n      const pattern = lsbSequence.slice(i, i + 8).join('');\n      for (let j = i + 8; j < lsbSequence.length - 8; j++) {\n        if (lsbSequence.slice(j, j + 8).join('') === pattern) {\n          patternCount++;\n        }\n      }\n    }\n\n    const hasPatterns = patternCount > lsbSequence.length / 100;\n\n    // Simplified chi-square (would need proper implementation)\n    const chiSquare = anomalyScore > 0.1 ? 0.1 : 0;\n\n    return { anomalyScore, hasPatterns, chiSquare };\n  }\n\n  private estimateHiddenSize(imageData: ImageData): number {\n    try {\n      const headerBits = this.extractBits(imageData, HEADER_SIZE * 8);\n      const header = this.bitsToBytes(headerBits);\n\n      if (this.checkMagicHeader(header)) {\n        return (header[4] << 24) | (header[5] << 16) | (header[6] << 8) | header[7];\n      }\n    } catch {\n      // Ignore errors\n    }\n    return 0;\n  }\n\n  // ==========================================================================\n  // Private Methods - Utilities\n  // ==========================================================================\n\n  private checkMagicHeader(data: Uint8Array): boolean {\n    return (\n      data[0] === MAGIC_HEADER[0] &&\n      data[1] === MAGIC_HEADER[1] &&\n      data[2] === MAGIC_HEADER[2] &&\n      data[3] === MAGIC_HEADER[3]\n    );\n  }\n\n  private getChannelOffset(channel: Channel): number {\n    const offsets: Record<Channel, number> = { r: 0, g: 1, b: 2, a: 3 };\n    return offsets[channel];\n  }\n\n  private encodeChannels(channels: Channel[]): number {\n    let flags = 0;\n    if (channels.includes('r')) flags |= 1;\n    if (channels.includes('g')) flags |= 2;\n    if (channels.includes('b')) flags |= 4;\n    if (channels.includes('a')) flags |= 8;\n    return flags;\n  }\n\n  private getBit(byte: number, position: number): number {\n    return (byte >> position) & 1;\n  }\n\n  private setBit(byte: number, position: number, value: number): number {\n    if (value === 1) {\n      return byte | (1 << position);\n    } else {\n      return byte & ~(1 << position);\n    }\n  }\n\n  private bytesToBits(bytes: Uint8Array): number[] {\n    const bits: number[] = [];\n    for (const byte of bytes) {\n      for (let i = 7; i >= 0; i--) {\n        bits.push((byte >> i) & 1);\n      }\n    }\n    return bits;\n  }\n\n  private bitsToBytes(bits: number[]): Uint8Array {\n    const bytes = new Uint8Array(Math.ceil(bits.length / 8));\n    for (let i = 0; i < bits.length; i++) {\n      const byteIndex = Math.floor(i / 8);\n      const bitIndex = 7 - (i % 8);\n      bytes[byteIndex] |= bits[i] << bitIndex;\n    }\n    return bytes;\n  }\n\n  private stringToBytes(str: string): Uint8Array {\n    return new TextEncoder().encode(str);\n  }\n\n  private bytesToString(bytes: Uint8Array): string {\n    return new TextDecoder().decode(bytes);\n  }\n\n  private generatePositions(count: number, max: number, seed: number): number[] {\n    // Simple PRNG for position generation\n    const positions: number[] = [];\n    const used = new Set<number>();\n\n    let state = seed || 12345;\n    while (positions.length < count && positions.length < max) {\n      state = (state * 1103515245 + 12345) & 0x7fffffff;\n      const pos = state % max;\n\n      if (!used.has(pos)) {\n        used.add(pos);\n        positions.push(pos);\n      }\n    }\n\n    return positions;\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createSteganography(options?: EncodeOptions): SteganographyEngine {\n  return new SteganographyEngine(options);\n}\n\n// ============================================================================\n// Convenience Functions\n// ============================================================================\n\n/**\n * Encode text into image\n */\nexport function encodeText(\n  imageData: ImageData,\n  text: string,\n  options?: EncodeOptions\n): EncodeResult {\n  const engine = new SteganographyEngine(options);\n  return engine.encodeText(imageData, text);\n}\n\n/**\n * Decode text from image\n */\nexport function decodeText(imageData: ImageData, options?: DecodeOptions): string {\n  const engine = new SteganographyEngine(options);\n  return engine.decodeText(imageData, options);\n}\n\n/**\n * Check if image has hidden data\n */\nexport function detectHiddenData(imageData: ImageData): DetectionResult {\n  const engine = new SteganographyEngine();\n  return engine.detect(imageData);\n}\n\n/**\n * Calculate image capacity\n */\nexport function getCapacity(imageData: ImageData, options?: EncodeOptions): CapacityAnalysis {\n  const engine = new SteganographyEngine(options);\n  return engine.calculateCapacity(imageData);\n}\n\n/**\n * Create ImageData from canvas context\n */\nexport function imageDataFromCanvas(\n  ctx: CanvasRenderingContext2D,\n  x: number = 0,\n  y: number = 0,\n  width?: number,\n  height?: number\n): ImageData {\n  const w = width || ctx.canvas.width;\n  const h = height || ctx.canvas.height;\n  const data = ctx.getImageData(x, y, w, h);\n  return {\n    width: data.width,\n    height: data.height,\n    data: data.data,\n  };\n}\n\n/**\n * Apply ImageData to canvas context\n */\nexport function imageDataToCanvas(\n  ctx: CanvasRenderingContext2D,\n  imageData: ImageData,\n  x: number = 0,\n  y: number = 0\n): void {\n  const canvasImageData = ctx.createImageData(imageData.width, imageData.height);\n  canvasImageData.data.set(imageData.data);\n  ctx.putImageData(canvasImageData, x, y);\n}\n"],"mappings":"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","names":[]}