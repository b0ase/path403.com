{"version":3,"sources":["../src/types.ts","../src/provider.tsx","../src/server.ts"],"sourcesContent":["/**\n * Wallet Types\n *\n * Shared type definitions for multi-wallet authentication.\n */\n\n// ============================================================================\n// Provider Types\n// ============================================================================\n\n/** Supported wallet providers */\nexport type WalletProvider = 'handcash' | 'yours' | 'phantom' | 'metamask';\n\n/** Blockchain networks */\nexport type Chain = 'bsv' | 'ethereum' | 'solana';\n\n/** Provider to chain mapping */\nexport const PROVIDER_CHAINS: Record<WalletProvider, Chain> = {\n  handcash: 'bsv',\n  yours: 'bsv',\n  phantom: 'solana',\n  metamask: 'ethereum',\n};\n\n// ============================================================================\n// Wallet State Types\n// ============================================================================\n\n/** Connected wallet state */\nexport interface WalletState {\n  /** Whether any wallet is connected */\n  isConnected: boolean;\n  /** Currently connected provider */\n  provider: WalletProvider | null;\n  /** Wallet address (handle for HandCash, address for others) */\n  address: string | null;\n  /** Public key for signing/encryption (if available) */\n  publicKey: string | null;\n  /** Chain of connected wallet */\n  chain: Chain | null;\n  /** Whether connection is in progress */\n  isConnecting: boolean;\n  /** Error message if connection failed */\n  error: string | null;\n}\n\n/** Wallet context with actions */\nexport interface WalletContext extends WalletState {\n  /** Connect to a specific wallet */\n  connect: (provider: WalletProvider) => Promise<void>;\n  /** Disconnect current wallet */\n  disconnect: () => Promise<void>;\n  /** Sign a message (if supported) */\n  signMessage?: (message: string) => Promise<string>;\n}\n\n// ============================================================================\n// Provider-Specific Types\n// ============================================================================\n\n/** HandCash profile from OAuth */\nexport interface HandCashProfile {\n  id: string;\n  handle: string;\n  displayName: string;\n  avatarUrl?: string;\n}\n\n/** Yours wallet addresses */\nexport interface YoursAddresses {\n  bsvAddress: string;\n  ordAddress: string;\n  identityAddress: string;\n}\n\n/** Phantom wallet response */\nexport interface PhantomResponse {\n  publicKey: {\n    toString: () => string;\n  };\n}\n\n/** MetaMask accounts response */\nexport type MetaMaskAccounts = string[];\n\n// ============================================================================\n// Server Types\n// ============================================================================\n\n/** Wallet auth request body */\nexport interface WalletAuthRequest {\n  provider: WalletProvider;\n  address: string;\n  signature?: string;\n  message?: string;\n}\n\n/** Wallet auth response */\nexport interface WalletAuthResponse {\n  success: boolean;\n  unifiedUserId?: string;\n  error?: string;\n}\n\n/** Session data stored in cookies/tokens */\nexport interface WalletSession {\n  provider: WalletProvider;\n  address: string;\n  chain: Chain;\n  unifiedUserId?: string;\n}\n\n// ============================================================================\n// Window Augmentation\n// ============================================================================\n\ndeclare global {\n  interface Window {\n    /** Phantom wallet (Solana) */\n    solana?: {\n      isPhantom?: boolean;\n      connect: () => Promise<PhantomResponse>;\n      disconnect: () => Promise<void>;\n      on: (event: string, callback: (args: unknown) => void) => void;\n      off: (event: string, callback: (args: unknown) => void) => void;\n      signMessage: (message: Uint8Array, encoding: string) => Promise<{ signature: Uint8Array }>;\n    };\n\n    /** MetaMask wallet (Ethereum) */\n    ethereum?: {\n      isMetaMask?: boolean;\n      request: <T = unknown>(args: { method: string; params?: unknown[] }) => Promise<T>;\n      on: (event: string, callback: (args: unknown) => void) => void;\n      removeListener: (event: string, callback: (args: unknown) => void) => void;\n      selectedAddress?: string;\n      chainId?: string;\n    };\n\n    /** HandCash extension (if available) */\n    handcash?: {\n      connect: () => Promise<{ cashaddr: string; pubkey: string }>;\n      disconnect: () => Promise<void>;\n      on: (event: string, callback: (args: unknown) => void) => void;\n      off: (event: string, callback: (args: unknown) => void) => void;\n    };\n  }\n}\n\nexport {};\n","'use client';\n\n/**\n * Unified Wallet Provider\n *\n * React context that provides multi-wallet authentication\n * for HandCash, Yours, Phantom, and MetaMask.\n */\n\nimport React, {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  useCallback,\n  ReactNode,\n} from 'react';\nimport type {\n  WalletProvider as WalletProviderType,\n  WalletContext,\n  WalletState,\n  Chain,\n  PROVIDER_CHAINS,\n} from './types';\n\n// Re-export types\nexport type { WalletProviderType, WalletContext, WalletState, Chain };\n\n// ============================================================================\n// Context\n// ============================================================================\n\nconst defaultState: WalletContext = {\n  isConnected: false,\n  provider: null,\n  address: null,\n  publicKey: null,\n  chain: null,\n  isConnecting: false,\n  error: null,\n  connect: async () => {},\n  disconnect: async () => {},\n};\n\nconst WalletCtx = createContext<WalletContext>(defaultState);\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Use the wallet context\n *\n * @example\n * ```tsx\n * const { isConnected, address, connect, disconnect } = useWallet();\n *\n * if (isConnected) {\n *   return <div>Connected: {address}</div>;\n * }\n *\n * return <button onClick={() => connect('handcash')}>Connect</button>;\n * ```\n */\nexport function useWallet(): WalletContext {\n  const ctx = useContext(WalletCtx);\n  if (!ctx) {\n    throw new Error('useWallet must be used within MultiWalletProvider');\n  }\n  return ctx;\n}\n\n// ============================================================================\n// Provider Props\n// ============================================================================\n\nexport interface MultiWalletProviderProps {\n  children: ReactNode;\n  /** HandCash OAuth redirect URL (defaults to /api/auth/handcash) */\n  handcashAuthUrl?: string;\n  /** Whether to persist wallet selection to localStorage */\n  persistSelection?: boolean;\n  /** Storage key for persisted wallet */\n  storageKey?: string;\n  /** Callback when wallet connects */\n  onConnect?: (provider: WalletProviderType, address: string) => void;\n  /** Callback when wallet disconnects */\n  onDisconnect?: () => void;\n  /** Callback on connection error */\n  onError?: (error: Error) => void;\n}\n\n// ============================================================================\n// Provider Component\n// ============================================================================\n\n/**\n * Multi-Wallet Provider\n *\n * Wraps your app to provide unified wallet authentication.\n *\n * @example\n * ```tsx\n * import { MultiWalletProvider } from '@b0ase/multi-wallet-auth/provider';\n *\n * function App() {\n *   return (\n *     <MultiWalletProvider handcashAuthUrl=\"/api/auth/handcash\">\n *       <YourApp />\n *     </MultiWalletProvider>\n *   );\n * }\n * ```\n */\nexport function MultiWalletProvider({\n  children,\n  handcashAuthUrl = '/api/auth/handcash',\n  persistSelection = true,\n  storageKey = 'b0ase_wallet',\n  onConnect,\n  onDisconnect,\n  onError,\n}: MultiWalletProviderProps) {\n  const [state, setState] = useState<WalletState>({\n    isConnected: false,\n    provider: null,\n    address: null,\n    publicKey: null,\n    chain: null,\n    isConnecting: false,\n    error: null,\n  });\n\n  // Get chain for provider\n  const getChain = (provider: WalletProviderType): Chain => {\n    const chains: Record<WalletProviderType, Chain> = {\n      handcash: 'bsv',\n      yours: 'bsv',\n      phantom: 'solana',\n      metamask: 'ethereum',\n    };\n    return chains[provider];\n  };\n\n  // Check for HandCash session on mount\n  useEffect(() => {\n    const getCookie = (name: string): string | null => {\n      if (typeof document === 'undefined') return null;\n      const value = `; ${document.cookie}`;\n      const parts = value.split(`; ${name}=`);\n      if (parts.length === 2) return parts.pop()?.split(';').shift() || null;\n      return null;\n    };\n\n    const authToken = getCookie('b0ase_auth_token');\n    const handle = getCookie('b0ase_user_handle');\n\n    if (authToken && handle) {\n      setState((prev) => ({\n        ...prev,\n        isConnected: true,\n        provider: 'handcash',\n        address: handle,\n        chain: 'bsv',\n      }));\n    }\n  }, []);\n\n  // Restore persisted wallet selection\n  useEffect(() => {\n    if (!persistSelection || typeof window === 'undefined') return;\n\n    const stored = localStorage.getItem(storageKey);\n    if (stored) {\n      try {\n        const { provider, address } = JSON.parse(stored);\n        if (provider && address) {\n          setState((prev) => ({\n            ...prev,\n            isConnected: true,\n            provider,\n            address,\n            chain: getChain(provider),\n          }));\n        }\n      } catch {\n        localStorage.removeItem(storageKey);\n      }\n    }\n  }, [persistSelection, storageKey]);\n\n  // Connect to wallet\n  const connect = useCallback(\n    async (provider: WalletProviderType) => {\n      setState((prev) => ({ ...prev, isConnecting: true, error: null }));\n\n      try {\n        let address: string | null = null;\n        let publicKey: string | null = null;\n\n        switch (provider) {\n          case 'handcash': {\n            // Redirect to HandCash OAuth\n            const returnTo =\n              typeof window !== 'undefined' ? window.location.pathname : '/';\n            window.location.href = `${handcashAuthUrl}?returnTo=${encodeURIComponent(returnTo)}`;\n            return; // Page will redirect\n          }\n\n          case 'yours': {\n            // Yours wallet requires extension\n            if (typeof window === 'undefined') {\n              throw new Error('Yours wallet only works in browser');\n            }\n            // Yours integration typically done via their provider\n            // This is a simplified version - full integration uses YoursProvider\n            throw new Error(\n              'Yours wallet requires YoursWalletProvider wrapper'\n            );\n          }\n\n          case 'phantom': {\n            const solana = window.solana;\n            if (!solana?.isPhantom) {\n              window.open('https://phantom.app/', '_blank');\n              throw new Error('Phantom wallet not installed');\n            }\n            const resp = await solana.connect();\n            address = resp.publicKey.toString();\n            publicKey = address;\n            break;\n          }\n\n          case 'metamask': {\n            const ethereum = window.ethereum;\n            if (!ethereum?.isMetaMask) {\n              window.open('https://metamask.io/', '_blank');\n              throw new Error('MetaMask not installed');\n            }\n            const accounts = await ethereum.request<string[]>({\n              method: 'eth_requestAccounts',\n            });\n            address = accounts?.[0] || null;\n            break;\n          }\n        }\n\n        if (!address) {\n          throw new Error('Failed to get wallet address');\n        }\n\n        const chain = getChain(provider);\n\n        setState({\n          isConnected: true,\n          provider,\n          address,\n          publicKey,\n          chain,\n          isConnecting: false,\n          error: null,\n        });\n\n        // Persist selection\n        if (persistSelection && typeof window !== 'undefined') {\n          localStorage.setItem(storageKey, JSON.stringify({ provider, address }));\n        }\n\n        // Callback\n        onConnect?.(provider, address);\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n        setState((prev) => ({\n          ...prev,\n          isConnecting: false,\n          error: error.message,\n        }));\n        onError?.(error);\n      }\n    },\n    [handcashAuthUrl, persistSelection, storageKey, onConnect, onError]\n  );\n\n  // Disconnect wallet\n  const disconnect = useCallback(async () => {\n    try {\n      const { provider } = state;\n\n      if (provider === 'phantom' && window.solana) {\n        await window.solana.disconnect();\n      }\n      // MetaMask doesn't have a disconnect method\n      // HandCash requires clearing cookies (server-side)\n\n      setState({\n        isConnected: false,\n        provider: null,\n        address: null,\n        publicKey: null,\n        chain: null,\n        isConnecting: false,\n        error: null,\n      });\n\n      // Clear persisted selection\n      if (persistSelection && typeof window !== 'undefined') {\n        localStorage.removeItem(storageKey);\n      }\n\n      // Callback\n      onDisconnect?.();\n    } catch (err) {\n      console.error('Disconnect error:', err);\n    }\n  }, [state, persistSelection, storageKey, onDisconnect]);\n\n  // Sign message (for wallets that support it)\n  const signMessage = useCallback(\n    async (message: string): Promise<string> => {\n      const { provider } = state;\n\n      if (!provider) {\n        throw new Error('No wallet connected');\n      }\n\n      switch (provider) {\n        case 'phantom': {\n          if (!window.solana) throw new Error('Phantom not available');\n          const encodedMessage = new TextEncoder().encode(message);\n          const { signature } = await window.solana.signMessage(\n            encodedMessage,\n            'utf8'\n          );\n          return Buffer.from(signature).toString('hex');\n        }\n\n        case 'metamask': {\n          if (!window.ethereum) throw new Error('MetaMask not available');\n          const address = state.address;\n          if (!address) throw new Error('No address');\n          const signature = await window.ethereum.request<string>({\n            method: 'personal_sign',\n            params: [message, address],\n          });\n          return signature || '';\n        }\n\n        default:\n          throw new Error(`Signing not supported for ${provider}`);\n      }\n    },\n    [state]\n  );\n\n  const value: WalletContext = {\n    ...state,\n    connect,\n    disconnect,\n    signMessage,\n  };\n\n  return <WalletCtx.Provider value={value}>{children}</WalletCtx.Provider>;\n}\n\n// ============================================================================\n// Export default for convenience\n// ============================================================================\n\nexport default MultiWalletProvider;\n","/**\n * Server-Side Wallet Utilities\n *\n * Functions for validating wallet authentication on the server.\n */\n\nimport type {\n  WalletProvider,\n  WalletAuthRequest,\n  WalletAuthResponse,\n  WalletSession,\n  Chain,\n  PROVIDER_CHAINS,\n} from './types';\n\n// Re-export types\nexport type {\n  WalletProvider,\n  WalletAuthRequest,\n  WalletAuthResponse,\n  WalletSession,\n};\n\n// ============================================================================\n// Address Validation\n// ============================================================================\n\n/**\n * Validate Ethereum address format\n */\nexport function isValidEthereumAddress(address: string): boolean {\n  return /^0x[a-fA-F0-9]{40}$/.test(address);\n}\n\n/**\n * Validate Solana address format (base58, 32-44 chars)\n */\nexport function isValidSolanaAddress(address: string): boolean {\n  return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);\n}\n\n/**\n * Validate BSV address format (starts with 1 or m/n for testnet)\n */\nexport function isValidBsvAddress(address: string): boolean {\n  return /^[1mn][a-km-zA-HJ-NP-Z0-9]{25,34}$/.test(address);\n}\n\n/**\n * Validate HandCash handle format\n */\nexport function isValidHandCashHandle(handle: string): boolean {\n  return /^[a-zA-Z0-9_]{1,20}$/.test(handle);\n}\n\n/**\n * Validate address for a given provider\n */\nexport function validateAddress(\n  provider: WalletProvider,\n  address: string\n): boolean {\n  switch (provider) {\n    case 'handcash':\n      return isValidHandCashHandle(address);\n    case 'yours':\n      return isValidBsvAddress(address);\n    case 'phantom':\n      return isValidSolanaAddress(address);\n    case 'metamask':\n      return isValidEthereumAddress(address);\n    default:\n      return false;\n  }\n}\n\n// ============================================================================\n// Address Normalization\n// ============================================================================\n\n/**\n * Normalize address for consistent storage\n * - Ethereum addresses: lowercase\n * - Others: as-is\n */\nexport function normalizeAddress(\n  provider: WalletProvider,\n  address: string\n): string {\n  if (provider === 'metamask') {\n    return address.toLowerCase();\n  }\n  return address;\n}\n\n// ============================================================================\n// Session Utilities\n// ============================================================================\n\n/**\n * Parse wallet session from cookies\n */\nexport function parseWalletSession(\n  cookies: Record<string, string | undefined>\n): WalletSession | null {\n  const provider = cookies['b0ase_wallet_provider'] as WalletProvider;\n  const address = cookies['b0ase_wallet_address'];\n\n  if (!provider || !address) {\n    // Check for HandCash cookies\n    const authToken = cookies['b0ase_auth_token'];\n    const handle = cookies['b0ase_user_handle'];\n\n    if (authToken && handle) {\n      return {\n        provider: 'handcash',\n        address: handle,\n        chain: 'bsv',\n      };\n    }\n\n    return null;\n  }\n\n  const chains: Record<WalletProvider, Chain> = {\n    handcash: 'bsv',\n    yours: 'bsv',\n    phantom: 'solana',\n    metamask: 'ethereum',\n  };\n\n  return {\n    provider,\n    address,\n    chain: chains[provider],\n  };\n}\n\n/**\n * Create session cookies for wallet auth\n */\nexport function createSessionCookies(\n  provider: WalletProvider,\n  address: string,\n  maxAge = 2592000 // 30 days\n): string[] {\n  const options = `Path=/; Max-Age=${maxAge}; SameSite=Lax`;\n  return [\n    `b0ase_wallet_provider=${provider}; ${options}`,\n    `b0ase_wallet_address=${normalizeAddress(provider, address)}; ${options}`,\n  ];\n}\n\n/**\n * Create cookies to clear wallet session\n */\nexport function clearSessionCookies(): string[] {\n  const options = 'Path=/; Max-Age=0; SameSite=Lax';\n  return [\n    `b0ase_wallet_provider=; ${options}`,\n    `b0ase_wallet_address=; ${options}`,\n  ];\n}\n\n// ============================================================================\n// Auth Handler Helpers\n// ============================================================================\n\n/**\n * Validate wallet auth request\n */\nexport function validateAuthRequest(\n  body: unknown\n): { valid: true; data: WalletAuthRequest } | { valid: false; error: string } {\n  if (!body || typeof body !== 'object') {\n    return { valid: false, error: 'Invalid request body' };\n  }\n\n  const { provider, address } = body as Record<string, unknown>;\n\n  if (!provider || typeof provider !== 'string') {\n    return { valid: false, error: 'provider is required' };\n  }\n\n  if (!address || typeof address !== 'string') {\n    return { valid: false, error: 'address is required' };\n  }\n\n  const validProviders: WalletProvider[] = [\n    'handcash',\n    'yours',\n    'phantom',\n    'metamask',\n  ];\n  if (!validProviders.includes(provider as WalletProvider)) {\n    return {\n      valid: false,\n      error: `Invalid provider. Must be one of: ${validProviders.join(', ')}`,\n    };\n  }\n\n  if (!validateAddress(provider as WalletProvider, address)) {\n    return { valid: false, error: 'Invalid address format for provider' };\n  }\n\n  return {\n    valid: true,\n    data: {\n      provider: provider as WalletProvider,\n      address: normalizeAddress(provider as WalletProvider, address),\n    },\n  };\n}\n\n// ============================================================================\n// Display Name Generation\n// ============================================================================\n\n/**\n * Generate display name from wallet address\n */\nexport function generateDisplayName(\n  provider: WalletProvider,\n  address: string\n): string {\n  if (provider === 'handcash') {\n    return `$${address}`;\n  }\n\n  if (provider === 'metamask') {\n    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n  }\n\n  if (provider === 'phantom') {\n    return `${address.slice(0, 4)}...${address.slice(-4)}`;\n  }\n\n  // BSV addresses\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n}\n\n// ============================================================================\n// Chain Utilities\n// ============================================================================\n\n/**\n * Get chain for provider\n */\nexport function getChainForProvider(provider: WalletProvider): Chain {\n  const chains: Record<WalletProvider, Chain> = {\n    handcash: 'bsv',\n    yours: 'bsv',\n    phantom: 'solana',\n    metamask: 'ethereum',\n  };\n  return chains[provider];\n}\n\n/**\n * Get explorer URL for transaction\n */\nexport function getExplorerUrl(chain: Chain, txid: string): string {\n  switch (chain) {\n    case 'bsv':\n      return `https://whatsonchain.com/tx/${txid}`;\n    case 'ethereum':\n      return `https://etherscan.io/tx/${txid}`;\n    case 'solana':\n      return `https://solscan.io/tx/${txid}`;\n  }\n}\n\n/**\n * Get explorer URL for address\n */\nexport function getAddressExplorerUrl(chain: Chain, address: string): string {\n  switch (chain) {\n    case 'bsv':\n      return `https://whatsonchain.com/address/${address}`;\n    case 'ethereum':\n      return `https://etherscan.io/address/${address}`;\n    case 'solana':\n      return `https://solscan.io/account/${address}`;\n  }\n}\n"],"mappings":"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","names":["value"]}