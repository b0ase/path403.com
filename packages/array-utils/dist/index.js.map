{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/array-utils\n *\n * Array utilities: groupBy, chunk, unique, flatten, sort, and more.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Comparator function */\nexport type Comparator<T> = (a: T, b: T) => number;\n\n/** Key selector function */\nexport type KeySelector<T, K> = (item: T, index: number) => K;\n\n/** Predicate function */\nexport type Predicate<T> = (item: T, index: number) => boolean;\n\n// ============================================================================\n// Grouping\n// ============================================================================\n\n/**\n * Group array by key\n */\nexport function groupBy<T, K extends string | number>(\n  arr: T[],\n  keyFn: KeySelector<T, K>\n): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = keyFn(arr[i], i);\n    if (!(key in result)) {\n      result[key] = [];\n    }\n    result[key].push(arr[i]);\n  }\n\n  return result;\n}\n\n/**\n * Count items by key\n */\nexport function countBy<T, K extends string | number>(\n  arr: T[],\n  keyFn: KeySelector<T, K>\n): Record<K, number> {\n  const result = {} as Record<K, number>;\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = keyFn(arr[i], i);\n    result[key] = (result[key] || 0) + 1;\n  }\n\n  return result;\n}\n\n/**\n * Partition array into two based on predicate\n */\nexport function partition<T>(arr: T[], predicate: Predicate<T>): [T[], T[]] {\n  const pass: T[] = [];\n  const fail: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i)) {\n      pass.push(arr[i]);\n    } else {\n      fail.push(arr[i]);\n    }\n  }\n\n  return [pass, fail];\n}\n\n// ============================================================================\n// Chunking\n// ============================================================================\n\n/**\n * Split array into chunks of specified size\n */\nexport function chunk<T>(arr: T[], size: number): T[][] {\n  if (size <= 0) return [];\n\n  const result: T[][] = [];\n  for (let i = 0; i < arr.length; i += size) {\n    result.push(arr.slice(i, i + size));\n  }\n  return result;\n}\n\n/**\n * Split array into n equal parts\n */\nexport function splitInto<T>(arr: T[], n: number): T[][] {\n  if (n <= 0) return [];\n\n  const size = Math.ceil(arr.length / n);\n  return chunk(arr, size);\n}\n\n// ============================================================================\n// Uniqueness\n// ============================================================================\n\n/**\n * Get unique values\n */\nexport function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n\n/**\n * Get unique values by key\n */\nexport function uniqueBy<T, K>(arr: T[], keyFn: KeySelector<T, K>): T[] {\n  const seen = new Set<K>();\n  const result: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = keyFn(arr[i], i);\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get duplicate values\n */\nexport function duplicates<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const dupes = new Set<T>();\n\n  for (const item of arr) {\n    if (seen.has(item)) {\n      dupes.add(item);\n    } else {\n      seen.add(item);\n    }\n  }\n\n  return [...dupes];\n}\n\n// ============================================================================\n// Flattening\n// ============================================================================\n\n/**\n * Flatten nested arrays one level\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return arr.flat();\n}\n\n/**\n * Flatten nested arrays deeply\n */\nexport function flattenDeep<T>(arr: unknown[]): T[] {\n  return arr.flat(Infinity) as T[];\n}\n\n/**\n * Flatten and map in one pass\n */\nexport function flatMap<T, R>(arr: T[], fn: (item: T, index: number) => R[]): R[] {\n  return arr.flatMap(fn);\n}\n\n// ============================================================================\n// Sorting\n// ============================================================================\n\n/**\n * Sort array by key (ascending)\n */\nexport function sortBy<T, K>(arr: T[], keyFn: KeySelector<T, K>): T[] {\n  return [...arr].sort((a, b) => {\n    const keyA = keyFn(a, 0);\n    const keyB = keyFn(b, 0);\n    if (keyA < keyB) return -1;\n    if (keyA > keyB) return 1;\n    return 0;\n  });\n}\n\n/**\n * Sort array by key (descending)\n */\nexport function sortByDesc<T, K>(arr: T[], keyFn: KeySelector<T, K>): T[] {\n  return [...arr].sort((a, b) => {\n    const keyA = keyFn(a, 0);\n    const keyB = keyFn(b, 0);\n    if (keyA > keyB) return -1;\n    if (keyA < keyB) return 1;\n    return 0;\n  });\n}\n\n/**\n * Sort array by multiple keys\n */\nexport function sortByMultiple<T>(arr: T[], comparators: Comparator<T>[]): T[] {\n  return [...arr].sort((a, b) => {\n    for (const comparator of comparators) {\n      const result = comparator(a, b);\n      if (result !== 0) return result;\n    }\n    return 0;\n  });\n}\n\n/**\n * Reverse array (immutable)\n */\nexport function reverse<T>(arr: T[]): T[] {\n  return [...arr].reverse();\n}\n\n/**\n * Shuffle array\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  const result = [...arr];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\n\n// ============================================================================\n// Selection\n// ============================================================================\n\n/**\n * Get first n items\n */\nexport function take<T>(arr: T[], n: number): T[] {\n  return arr.slice(0, n);\n}\n\n/**\n * Get last n items\n */\nexport function takeLast<T>(arr: T[], n: number): T[] {\n  return arr.slice(-n);\n}\n\n/**\n * Skip first n items\n */\nexport function skip<T>(arr: T[], n: number): T[] {\n  return arr.slice(n);\n}\n\n/**\n * Skip last n items\n */\nexport function skipLast<T>(arr: T[], n: number): T[] {\n  return arr.slice(0, -n || undefined);\n}\n\n/**\n * Get first item or undefined\n */\nexport function first<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n/**\n * Get last item or undefined\n */\nexport function last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\n/**\n * Get item at index (supports negative indices)\n */\nexport function at<T>(arr: T[], index: number): T | undefined {\n  const i = index < 0 ? arr.length + index : index;\n  return arr[i];\n}\n\n/**\n * Get random item\n */\nexport function sample<T>(arr: T[]): T | undefined {\n  if (arr.length === 0) return undefined;\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Get n random items\n */\nexport function sampleSize<T>(arr: T[], n: number): T[] {\n  return shuffle(arr).slice(0, n);\n}\n\n// ============================================================================\n// Search\n// ============================================================================\n\n/**\n * Find item by predicate\n */\nexport function find<T>(arr: T[], predicate: Predicate<T>): T | undefined {\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i)) {\n      return arr[i];\n    }\n  }\n  return undefined;\n}\n\n/**\n * Find last item by predicate\n */\nexport function findLast<T>(arr: T[], predicate: Predicate<T>): T | undefined {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i)) {\n      return arr[i];\n    }\n  }\n  return undefined;\n}\n\n/**\n * Find index by predicate\n */\nexport function findIndex<T>(arr: T[], predicate: Predicate<T>): number {\n  for (let i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Find last index by predicate\n */\nexport function findLastIndex<T>(arr: T[], predicate: Predicate<T>): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Check if array includes item\n */\nexport function includes<T>(arr: T[], item: T): boolean {\n  return arr.includes(item);\n}\n\n/**\n * Check if any item matches predicate\n */\nexport function some<T>(arr: T[], predicate: Predicate<T>): boolean {\n  return arr.some((item, index) => predicate(item, index));\n}\n\n/**\n * Check if all items match predicate\n */\nexport function every<T>(arr: T[], predicate: Predicate<T>): boolean {\n  return arr.every((item, index) => predicate(item, index));\n}\n\n/**\n * Check if none match predicate\n */\nexport function none<T>(arr: T[], predicate: Predicate<T>): boolean {\n  return !some(arr, predicate);\n}\n\n// ============================================================================\n// Set Operations\n// ============================================================================\n\n/**\n * Get intersection of arrays\n */\nexport function intersection<T>(...arrays: T[][]): T[] {\n  if (arrays.length === 0) return [];\n  if (arrays.length === 1) return [...arrays[0]];\n\n  const [first, ...rest] = arrays;\n  const sets = rest.map((arr) => new Set(arr));\n\n  return first.filter((item) => sets.every((set) => set.has(item)));\n}\n\n/**\n * Get union of arrays\n */\nexport function union<T>(...arrays: T[][]): T[] {\n  return unique(arrays.flat());\n}\n\n/**\n * Get difference (items in first but not in second)\n */\nexport function difference<T>(arr: T[], exclude: T[]): T[] {\n  const excludeSet = new Set(exclude);\n  return arr.filter((item) => !excludeSet.has(item));\n}\n\n/**\n * Get symmetric difference (items in either but not both)\n */\nexport function symmetricDifference<T>(a: T[], b: T[]): T[] {\n  const setA = new Set(a);\n  const setB = new Set(b);\n  return [\n    ...a.filter((item) => !setB.has(item)),\n    ...b.filter((item) => !setA.has(item)),\n  ];\n}\n\n// ============================================================================\n// Transformation\n// ============================================================================\n\n/**\n * Compact array (remove falsy values)\n */\nexport function compact<T>(arr: (T | null | undefined | false | 0 | '')[]): T[] {\n  return arr.filter(Boolean) as T[];\n}\n\n/**\n * Zip multiple arrays together\n */\nexport function zip<T>(...arrays: T[][]): T[][] {\n  const maxLength = Math.max(...arrays.map((arr) => arr.length));\n  const result: T[][] = [];\n\n  for (let i = 0; i < maxLength; i++) {\n    result.push(arrays.map((arr) => arr[i]));\n  }\n\n  return result;\n}\n\n/**\n * Unzip array of tuples\n */\nexport function unzip<T>(arr: T[][]): T[][] {\n  if (arr.length === 0) return [];\n  const maxLength = Math.max(...arr.map((tuple) => tuple.length));\n  const result: T[][] = Array.from({ length: maxLength }, () => []);\n\n  for (const tuple of arr) {\n    for (let i = 0; i < maxLength; i++) {\n      result[i].push(tuple[i]);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Create object from key-value pairs\n */\nexport function keyBy<T, K extends string | number>(\n  arr: T[],\n  keyFn: KeySelector<T, K>\n): Record<K, T> {\n  const result = {} as Record<K, T>;\n  for (let i = 0; i < arr.length; i++) {\n    const key = keyFn(arr[i], i);\n    result[key] = arr[i];\n  }\n  return result;\n}\n\n// ============================================================================\n// Numeric Operations\n// ============================================================================\n\n/**\n * Sum array of numbers\n */\nexport function sum(arr: number[]): number {\n  return arr.reduce((acc, val) => acc + val, 0);\n}\n\n/**\n * Sum by key\n */\nexport function sumBy<T>(arr: T[], fn: (item: T) => number): number {\n  return arr.reduce((acc, item) => acc + fn(item), 0);\n}\n\n/**\n * Get average\n */\nexport function average(arr: number[]): number {\n  if (arr.length === 0) return 0;\n  return sum(arr) / arr.length;\n}\n\n/**\n * Get minimum value\n */\nexport function min(arr: number[]): number | undefined {\n  if (arr.length === 0) return undefined;\n  return Math.min(...arr);\n}\n\n/**\n * Get minimum by key\n */\nexport function minBy<T>(arr: T[], fn: (item: T) => number): T | undefined {\n  if (arr.length === 0) return undefined;\n  return arr.reduce((min, item) => (fn(item) < fn(min) ? item : min));\n}\n\n/**\n * Get maximum value\n */\nexport function max(arr: number[]): number | undefined {\n  if (arr.length === 0) return undefined;\n  return Math.max(...arr);\n}\n\n/**\n * Get maximum by key\n */\nexport function maxBy<T>(arr: T[], fn: (item: T) => number): T | undefined {\n  if (arr.length === 0) return undefined;\n  return arr.reduce((max, item) => (fn(item) > fn(max) ? item : max));\n}\n\n/**\n * Create range of numbers\n */\nexport function range(start: number, end: number, step: number = 1): number[] {\n  const result: number[] = [];\n  for (let i = start; i < end; i += step) {\n    result.push(i);\n  }\n  return result;\n}\n\n// ============================================================================\n// Insertion & Removal\n// ============================================================================\n\n/**\n * Insert item at index (immutable)\n */\nexport function insert<T>(arr: T[], index: number, item: T): T[] {\n  return [...arr.slice(0, index), item, ...arr.slice(index)];\n}\n\n/**\n * Remove item at index (immutable)\n */\nexport function removeAt<T>(arr: T[], index: number): T[] {\n  return [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\n\n/**\n * Remove first occurrence of item (immutable)\n */\nexport function remove<T>(arr: T[], item: T): T[] {\n  const index = arr.indexOf(item);\n  if (index === -1) return [...arr];\n  return removeAt(arr, index);\n}\n\n/**\n * Replace item at index (immutable)\n */\nexport function replaceAt<T>(arr: T[], index: number, item: T): T[] {\n  return [...arr.slice(0, index), item, ...arr.slice(index + 1)];\n}\n\n/**\n * Move item from one index to another (immutable)\n */\nexport function move<T>(arr: T[], from: number, to: number): T[] {\n  const result = [...arr];\n  const [item] = result.splice(from, 1);\n  result.splice(to, 0, item);\n  return result;\n}\n"],"mappings":";AA4BO,SAAS,QACd,KACA,OACgB;AAChB,QAAM,SAAS,CAAC;AAEhB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC;AAC3B,QAAI,EAAE,OAAO,SAAS;AACpB,aAAO,GAAG,IAAI,CAAC;AAAA,IACjB;AACA,WAAO,GAAG,EAAE,KAAK,IAAI,CAAC,CAAC;AAAA,EACzB;AAEA,SAAO;AACT;AAKO,SAAS,QACd,KACA,OACmB;AACnB,QAAM,SAAS,CAAC;AAEhB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC;AAC3B,WAAO,GAAG,KAAK,OAAO,GAAG,KAAK,KAAK;AAAA,EACrC;AAEA,SAAO;AACT;AAKO,SAAS,UAAa,KAAU,WAAqC;AAC1E,QAAM,OAAY,CAAC;AACnB,QAAM,OAAY,CAAC;AAEnB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG;AACxB,WAAK,KAAK,IAAI,CAAC,CAAC;AAAA,IAClB,OAAO;AACL,WAAK,KAAK,IAAI,CAAC,CAAC;AAAA,IAClB;AAAA,EACF;AAEA,SAAO,CAAC,MAAM,IAAI;AACpB;AASO,SAAS,MAAS,KAAU,MAAqB;AACtD,MAAI,QAAQ,EAAG,QAAO,CAAC;AAEvB,QAAM,SAAgB,CAAC;AACvB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,MAAM;AACzC,WAAO,KAAK,IAAI,MAAM,GAAG,IAAI,IAAI,CAAC;AAAA,EACpC;AACA,SAAO;AACT;AAKO,SAAS,UAAa,KAAU,GAAkB;AACvD,MAAI,KAAK,EAAG,QAAO,CAAC;AAEpB,QAAM,OAAO,KAAK,KAAK,IAAI,SAAS,CAAC;AACrC,SAAO,MAAM,KAAK,IAAI;AACxB;AASO,SAAS,OAAU,KAAe;AACvC,SAAO,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC;AACzB;AAKO,SAAS,SAAe,KAAU,OAA+B;AACtE,QAAM,OAAO,oBAAI,IAAO;AACxB,QAAM,SAAc,CAAC;AAErB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC;AAC3B,QAAI,CAAC,KAAK,IAAI,GAAG,GAAG;AAClB,WAAK,IAAI,GAAG;AACZ,aAAO,KAAK,IAAI,CAAC,CAAC;AAAA,IACpB;AAAA,EACF;AAEA,SAAO;AACT;AAKO,SAAS,WAAc,KAAe;AAC3C,QAAM,OAAO,oBAAI,IAAO;AACxB,QAAM,QAAQ,oBAAI,IAAO;AAEzB,aAAW,QAAQ,KAAK;AACtB,QAAI,KAAK,IAAI,IAAI,GAAG;AAClB,YAAM,IAAI,IAAI;AAAA,IAChB,OAAO;AACL,WAAK,IAAI,IAAI;AAAA,IACf;AAAA,EACF;AAEA,SAAO,CAAC,GAAG,KAAK;AAClB;AASO,SAAS,QAAW,KAAiB;AAC1C,SAAO,IAAI,KAAK;AAClB;AAKO,SAAS,YAAe,KAAqB;AAClD,SAAO,IAAI,KAAK,QAAQ;AAC1B;AAKO,SAAS,QAAc,KAAU,IAA0C;AAChF,SAAO,IAAI,QAAQ,EAAE;AACvB;AASO,SAAS,OAAa,KAAU,OAA+B;AACpE,SAAO,CAAC,GAAG,GAAG,EAAE,KAAK,CAAC,GAAG,MAAM;AAC7B,UAAM,OAAO,MAAM,GAAG,CAAC;AACvB,UAAM,OAAO,MAAM,GAAG,CAAC;AACvB,QAAI,OAAO,KAAM,QAAO;AACxB,QAAI,OAAO,KAAM,QAAO;AACxB,WAAO;AAAA,EACT,CAAC;AACH;AAKO,SAAS,WAAiB,KAAU,OAA+B;AACxE,SAAO,CAAC,GAAG,GAAG,EAAE,KAAK,CAAC,GAAG,MAAM;AAC7B,UAAM,OAAO,MAAM,GAAG,CAAC;AACvB,UAAM,OAAO,MAAM,GAAG,CAAC;AACvB,QAAI,OAAO,KAAM,QAAO;AACxB,QAAI,OAAO,KAAM,QAAO;AACxB,WAAO;AAAA,EACT,CAAC;AACH;AAKO,SAAS,eAAkB,KAAU,aAAmC;AAC7E,SAAO,CAAC,GAAG,GAAG,EAAE,KAAK,CAAC,GAAG,MAAM;AAC7B,eAAW,cAAc,aAAa;AACpC,YAAM,SAAS,WAAW,GAAG,CAAC;AAC9B,UAAI,WAAW,EAAG,QAAO;AAAA,IAC3B;AACA,WAAO;AAAA,EACT,CAAC;AACH;AAKO,SAAS,QAAW,KAAe;AACxC,SAAO,CAAC,GAAG,GAAG,EAAE,QAAQ;AAC1B;AAKO,SAAS,QAAW,KAAe;AACxC,QAAM,SAAS,CAAC,GAAG,GAAG;AACtB,WAAS,IAAI,OAAO,SAAS,GAAG,IAAI,GAAG,KAAK;AAC1C,UAAM,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,IAAI,EAAE;AAC5C,KAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,EAChD;AACA,SAAO;AACT;AASO,SAAS,KAAQ,KAAU,GAAgB;AAChD,SAAO,IAAI,MAAM,GAAG,CAAC;AACvB;AAKO,SAAS,SAAY,KAAU,GAAgB;AACpD,SAAO,IAAI,MAAM,CAAC,CAAC;AACrB;AAKO,SAAS,KAAQ,KAAU,GAAgB;AAChD,SAAO,IAAI,MAAM,CAAC;AACpB;AAKO,SAAS,SAAY,KAAU,GAAgB;AACpD,SAAO,IAAI,MAAM,GAAG,CAAC,KAAK,MAAS;AACrC;AAKO,SAAS,MAAS,KAAyB;AAChD,SAAO,IAAI,CAAC;AACd;AAKO,SAAS,KAAQ,KAAyB;AAC/C,SAAO,IAAI,IAAI,SAAS,CAAC;AAC3B;AAKO,SAAS,GAAM,KAAU,OAA8B;AAC5D,QAAM,IAAI,QAAQ,IAAI,IAAI,SAAS,QAAQ;AAC3C,SAAO,IAAI,CAAC;AACd;AAKO,SAAS,OAAU,KAAyB;AACjD,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,IAAI,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI,MAAM,CAAC;AACnD;AAKO,SAAS,WAAc,KAAU,GAAgB;AACtD,SAAO,QAAQ,GAAG,EAAE,MAAM,GAAG,CAAC;AAChC;AASO,SAAS,KAAQ,KAAU,WAAwC;AACxE,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG;AACxB,aAAO,IAAI,CAAC;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AAKO,SAAS,SAAY,KAAU,WAAwC;AAC5E,WAAS,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,KAAK;AACxC,QAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG;AACxB,aAAO,IAAI,CAAC;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AAKO,SAAS,UAAa,KAAU,WAAiC;AACtE,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG;AACxB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAKO,SAAS,cAAiB,KAAU,WAAiC;AAC1E,WAAS,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,KAAK;AACxC,QAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG;AACxB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAKO,SAAS,SAAY,KAAU,MAAkB;AACtD,SAAO,IAAI,SAAS,IAAI;AAC1B;AAKO,SAAS,KAAQ,KAAU,WAAkC;AAClE,SAAO,IAAI,KAAK,CAAC,MAAM,UAAU,UAAU,MAAM,KAAK,CAAC;AACzD;AAKO,SAAS,MAAS,KAAU,WAAkC;AACnE,SAAO,IAAI,MAAM,CAAC,MAAM,UAAU,UAAU,MAAM,KAAK,CAAC;AAC1D;AAKO,SAAS,KAAQ,KAAU,WAAkC;AAClE,SAAO,CAAC,KAAK,KAAK,SAAS;AAC7B;AASO,SAAS,gBAAmB,QAAoB;AACrD,MAAI,OAAO,WAAW,EAAG,QAAO,CAAC;AACjC,MAAI,OAAO,WAAW,EAAG,QAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAE7C,QAAM,CAACA,QAAO,GAAG,IAAI,IAAI;AACzB,QAAM,OAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI,GAAG,CAAC;AAE3C,SAAOA,OAAM,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC,QAAQ,IAAI,IAAI,IAAI,CAAC,CAAC;AAClE;AAKO,SAAS,SAAY,QAAoB;AAC9C,SAAO,OAAO,OAAO,KAAK,CAAC;AAC7B;AAKO,SAAS,WAAc,KAAU,SAAmB;AACzD,QAAM,aAAa,IAAI,IAAI,OAAO;AAClC,SAAO,IAAI,OAAO,CAAC,SAAS,CAAC,WAAW,IAAI,IAAI,CAAC;AACnD;AAKO,SAAS,oBAAuB,GAAQ,GAAa;AAC1D,QAAM,OAAO,IAAI,IAAI,CAAC;AACtB,QAAM,OAAO,IAAI,IAAI,CAAC;AACtB,SAAO;AAAA,IACL,GAAG,EAAE,OAAO,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC;AAAA,IACrC,GAAG,EAAE,OAAO,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC;AAAA,EACvC;AACF;AASO,SAAS,QAAW,KAAqD;AAC9E,SAAO,IAAI,OAAO,OAAO;AAC3B;AAKO,SAAS,OAAU,QAAsB;AAC9C,QAAM,YAAY,KAAK,IAAI,GAAG,OAAO,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC;AAC7D,QAAM,SAAgB,CAAC;AAEvB,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,WAAO,KAAK,OAAO,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC,CAAC;AAAA,EACzC;AAEA,SAAO;AACT;AAKO,SAAS,MAAS,KAAmB;AAC1C,MAAI,IAAI,WAAW,EAAG,QAAO,CAAC;AAC9B,QAAM,YAAY,KAAK,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,MAAM,MAAM,CAAC;AAC9D,QAAM,SAAgB,MAAM,KAAK,EAAE,QAAQ,UAAU,GAAG,MAAM,CAAC,CAAC;AAEhE,aAAW,SAAS,KAAK;AACvB,aAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,aAAO,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC;AAAA,IACzB;AAAA,EACF;AAEA,SAAO;AACT;AAKO,SAAS,MACd,KACA,OACc;AACd,QAAM,SAAS,CAAC;AAChB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC;AAC3B,WAAO,GAAG,IAAI,IAAI,CAAC;AAAA,EACrB;AACA,SAAO;AACT;AASO,SAAS,IAAI,KAAuB;AACzC,SAAO,IAAI,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;AAC9C;AAKO,SAAS,MAAS,KAAU,IAAiC;AAClE,SAAO,IAAI,OAAO,CAAC,KAAK,SAAS,MAAM,GAAG,IAAI,GAAG,CAAC;AACpD;AAKO,SAAS,QAAQ,KAAuB;AAC7C,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,IAAI,GAAG,IAAI,IAAI;AACxB;AAKO,SAAS,IAAI,KAAmC;AACrD,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,KAAK,IAAI,GAAG,GAAG;AACxB;AAKO,SAAS,MAAS,KAAU,IAAwC;AACzE,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,IAAI,OAAO,CAACC,MAAK,SAAU,GAAG,IAAI,IAAI,GAAGA,IAAG,IAAI,OAAOA,IAAI;AACpE;AAKO,SAAS,IAAI,KAAmC;AACrD,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,KAAK,IAAI,GAAG,GAAG;AACxB;AAKO,SAAS,MAAS,KAAU,IAAwC;AACzE,MAAI,IAAI,WAAW,EAAG,QAAO;AAC7B,SAAO,IAAI,OAAO,CAACC,MAAK,SAAU,GAAG,IAAI,IAAI,GAAGA,IAAG,IAAI,OAAOA,IAAI;AACpE;AAKO,SAAS,MAAM,OAAe,KAAa,OAAe,GAAa;AAC5E,QAAM,SAAmB,CAAC;AAC1B,WAAS,IAAI,OAAO,IAAI,KAAK,KAAK,MAAM;AACtC,WAAO,KAAK,CAAC;AAAA,EACf;AACA,SAAO;AACT;AASO,SAAS,OAAU,KAAU,OAAe,MAAc;AAC/D,SAAO,CAAC,GAAG,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,MAAM,KAAK,CAAC;AAC3D;AAKO,SAAS,SAAY,KAAU,OAAoB;AACxD,SAAO,CAAC,GAAG,IAAI,MAAM,GAAG,KAAK,GAAG,GAAG,IAAI,MAAM,QAAQ,CAAC,CAAC;AACzD;AAKO,SAAS,OAAU,KAAU,MAAc;AAChD,QAAM,QAAQ,IAAI,QAAQ,IAAI;AAC9B,MAAI,UAAU,GAAI,QAAO,CAAC,GAAG,GAAG;AAChC,SAAO,SAAS,KAAK,KAAK;AAC5B;AAKO,SAAS,UAAa,KAAU,OAAe,MAAc;AAClE,SAAO,CAAC,GAAG,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,MAAM,QAAQ,CAAC,CAAC;AAC/D;AAKO,SAAS,KAAQ,KAAU,MAAc,IAAiB;AAC/D,QAAM,SAAS,CAAC,GAAG,GAAG;AACtB,QAAM,CAAC,IAAI,IAAI,OAAO,OAAO,MAAM,CAAC;AACpC,SAAO,OAAO,IAAI,GAAG,IAAI;AACzB,SAAO;AACT;","names":["first","min","max"]}