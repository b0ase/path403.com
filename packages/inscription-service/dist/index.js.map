{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @b0ase/inscription-service\n *\n * Ordinals inscription service types and utilities.\n *\n * @packageDocumentation\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Blockchain network */\nexport type InscriptionNetwork = 'bsv' | 'bitcoin';\n\n/** Inscription status */\nexport type InscriptionStatus =\n  | 'pending'\n  | 'broadcasting'\n  | 'mempool'\n  | 'confirming'\n  | 'confirmed'\n  | 'failed';\n\n/** Content type */\nexport type ContentType =\n  | 'text/plain'\n  | 'text/html'\n  | 'text/css'\n  | 'text/javascript'\n  | 'application/json'\n  | 'application/javascript'\n  | 'image/png'\n  | 'image/jpeg'\n  | 'image/gif'\n  | 'image/webp'\n  | 'image/svg+xml'\n  | 'video/mp4'\n  | 'video/webm'\n  | 'audio/mpeg'\n  | 'audio/wav'\n  | 'model/gltf-binary'\n  | 'application/pdf';\n\n/** Inscription type */\nexport type InscriptionType =\n  | 'image'\n  | 'text'\n  | 'html'\n  | 'json'\n  | 'video'\n  | 'audio'\n  | '3d'\n  | 'document'\n  | 'code';\n\n/** Inscription envelope */\nexport interface InscriptionEnvelope {\n  contentType: ContentType;\n  content: Uint8Array;\n  pointer?: number;\n  parent?: string;\n  metadata?: InscriptionMetadata;\n  metaprotocol?: string;\n  delegate?: string;\n}\n\n/** Inscription metadata */\nexport interface InscriptionMetadata {\n  name?: string;\n  description?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n  }>;\n  collection?: string;\n  creator?: string;\n  [key: string]: unknown;\n}\n\n/** Inscription request */\nexport interface InscriptionRequest {\n  network: InscriptionNetwork;\n  envelope: InscriptionEnvelope;\n  feeRate: number;\n  destinationAddress: string;\n  changeAddress?: string;\n}\n\n/** Inscription result */\nexport interface InscriptionResult {\n  inscriptionId: string;\n  txid: string;\n  commitTxid?: string;\n  revealTxid?: string;\n  status: InscriptionStatus;\n  fee: bigint;\n  satpoint: string;\n  content: {\n    type: ContentType;\n    size: number;\n    hash: string;\n  };\n  explorerUrl: string;\n}\n\n/** Inscription info */\nexport interface InscriptionInfo {\n  id: string;\n  number?: number;\n  address: string;\n  outputValue: bigint;\n  satpoint: string;\n  contentType: ContentType;\n  contentLength: number;\n  genesisHeight: number;\n  genesisTimestamp: Date;\n  txid: string;\n  content?: Uint8Array;\n  metadata?: InscriptionMetadata;\n}\n\n/** Collection info */\nexport interface CollectionInfo {\n  id: string;\n  name: string;\n  description?: string;\n  creator: string;\n  totalSupply: number;\n  inscribed: number;\n  floorPrice?: bigint;\n  totalVolume?: bigint;\n}\n\n/** Ordinals UTXO */\nexport interface OrdinalsUTXO {\n  txid: string;\n  vout: number;\n  satoshis: bigint;\n  script: string;\n  inscriptions: InscriptionInfo[];\n  runes?: RuneBalance[];\n}\n\n/** Rune balance */\nexport interface RuneBalance {\n  runeId: string;\n  runeName: string;\n  amount: bigint;\n  divisibility: number;\n  symbol?: string;\n}\n\n/** Fee estimate */\nexport interface FeeEstimate {\n  commit: bigint;\n  reveal: bigint;\n  total: bigint;\n  feeRate: number;\n  size: {\n    commit: number;\n    reveal: number;\n  };\n}\n\n/** Batch inscription */\nexport interface BatchInscription {\n  id: string;\n  envelopes: InscriptionEnvelope[];\n  status: InscriptionStatus;\n  results: InscriptionResult[];\n  totalFee: bigint;\n  createdAt: Date;\n}\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULT_FEE_RATE = 1; // sat/vbyte\n\nexport const CONTENT_TYPE_MAP: Record<string, ContentType> = {\n  'txt': 'text/plain',\n  'html': 'text/html',\n  'css': 'text/css',\n  'js': 'text/javascript',\n  'json': 'application/json',\n  'png': 'image/png',\n  'jpg': 'image/jpeg',\n  'jpeg': 'image/jpeg',\n  'gif': 'image/gif',\n  'webp': 'image/webp',\n  'svg': 'image/svg+xml',\n  'mp4': 'video/mp4',\n  'webm': 'video/webm',\n  'mp3': 'audio/mpeg',\n  'wav': 'audio/wav',\n  'glb': 'model/gltf-binary',\n  'pdf': 'application/pdf',\n};\n\nexport const MAX_CONTENT_SIZE = 400 * 1024; // 400KB standard limit\n\n// ============================================================================\n// Inscription Service\n// ============================================================================\n\nexport class InscriptionService {\n  private network: InscriptionNetwork;\n  private apiUrl: string;\n  private inscriptions: Map<string, InscriptionInfo> = new Map();\n  private pendingRequests: Map<string, InscriptionRequest> = new Map();\n\n  constructor(network: InscriptionNetwork = 'bsv', apiUrl?: string) {\n    this.network = network;\n    this.apiUrl = apiUrl || this.getDefaultApiUrl(network);\n  }\n\n  private getDefaultApiUrl(network: InscriptionNetwork): string {\n    switch (network) {\n      case 'bsv':\n        return 'https://api.1satordinals.com';\n      case 'bitcoin':\n        return 'https://ordinals.com';\n    }\n  }\n\n  // ==========================================================================\n  // Inscription Creation\n  // ==========================================================================\n\n  createEnvelope(\n    content: Uint8Array | string,\n    contentType: ContentType,\n    metadata?: InscriptionMetadata\n  ): InscriptionEnvelope {\n    const contentBytes = typeof content === 'string'\n      ? new TextEncoder().encode(content)\n      : content;\n\n    return {\n      contentType,\n      content: contentBytes,\n      metadata,\n    };\n  }\n\n  async prepareInscription(request: InscriptionRequest): Promise<PreparedInscription> {\n    const { envelope, feeRate, destinationAddress, changeAddress } = request;\n\n    // Validate content size\n    if (envelope.content.length > MAX_CONTENT_SIZE) {\n      throw new Error(`Content exceeds maximum size of ${MAX_CONTENT_SIZE} bytes`);\n    }\n\n    // Calculate fees\n    const feeEstimate = this.estimateFees(envelope, feeRate);\n\n    // Build envelope script\n    const envelopeScript = this.buildEnvelopeScript(envelope);\n\n    const prepared: PreparedInscription = {\n      id: generateInscriptionId(),\n      envelope,\n      envelopeScript,\n      destinationAddress,\n      changeAddress: changeAddress || destinationAddress,\n      feeEstimate,\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    this.pendingRequests.set(prepared.id, request);\n    return prepared;\n  }\n\n  estimateFees(envelope: InscriptionEnvelope, feeRate: number): FeeEstimate {\n    // Envelope overhead: ~30 bytes\n    // Content: variable\n    // Script overhead: ~50 bytes\n    const envelopeSize = 30 + envelope.content.length + 50;\n\n    // Commit tx: ~150 bytes\n    const commitSize = 150;\n\n    // Reveal tx: envelope + ~150 bytes\n    const revealSize = envelopeSize + 150;\n\n    const commitFee = BigInt(Math.ceil(commitSize * feeRate));\n    const revealFee = BigInt(Math.ceil(revealSize * feeRate));\n\n    return {\n      commit: commitFee,\n      reveal: revealFee,\n      total: commitFee + revealFee,\n      feeRate,\n      size: { commit: commitSize, reveal: revealSize },\n    };\n  }\n\n  private buildEnvelopeScript(envelope: InscriptionEnvelope): string {\n    const parts: string[] = [];\n\n    // OP_FALSE OP_IF \"ord\"\n    parts.push('0063036f7264');\n\n    // Content type tag (01)\n    parts.push('01');\n    parts.push(this.pushData(new TextEncoder().encode(envelope.contentType)));\n\n    // Content (00)\n    parts.push('00');\n    parts.push(this.pushData(envelope.content));\n\n    // Pointer tag (02) if present\n    if (envelope.pointer !== undefined) {\n      parts.push('02');\n      parts.push(this.pushInt(envelope.pointer));\n    }\n\n    // Parent tag (03) if present\n    if (envelope.parent) {\n      parts.push('03');\n      parts.push(this.pushData(hexToBytes(envelope.parent)));\n    }\n\n    // Metadata tag (05) if present\n    if (envelope.metadata) {\n      parts.push('05');\n      const metadataJson = JSON.stringify(envelope.metadata);\n      parts.push(this.pushData(new TextEncoder().encode(metadataJson)));\n    }\n\n    // Metaprotocol tag (07) if present\n    if (envelope.metaprotocol) {\n      parts.push('07');\n      parts.push(this.pushData(new TextEncoder().encode(envelope.metaprotocol)));\n    }\n\n    // Delegate tag (0b) if present\n    if (envelope.delegate) {\n      parts.push('0b');\n      parts.push(this.pushData(hexToBytes(envelope.delegate)));\n    }\n\n    // OP_ENDIF\n    parts.push('68');\n\n    return parts.join('');\n  }\n\n  private pushData(data: Uint8Array): string {\n    const len = data.length;\n    let prefix: string;\n\n    if (len <= 75) {\n      prefix = len.toString(16).padStart(2, '0');\n    } else if (len <= 255) {\n      prefix = '4c' + len.toString(16).padStart(2, '0');\n    } else if (len <= 65535) {\n      const lenHex = len.toString(16).padStart(4, '0');\n      prefix = '4d' + lenHex.slice(2, 4) + lenHex.slice(0, 2);\n    } else {\n      const lenHex = len.toString(16).padStart(8, '0');\n      prefix = '4e' + lenHex.slice(6, 8) + lenHex.slice(4, 6) + lenHex.slice(2, 4) + lenHex.slice(0, 2);\n    }\n\n    return prefix + bytesToHex(data);\n  }\n\n  private pushInt(n: number): string {\n    if (n === 0) return '00';\n    if (n >= 1 && n <= 16) return (0x50 + n).toString(16);\n    if (n < 256) return '01' + n.toString(16).padStart(2, '0');\n    if (n < 65536) {\n      const hex = n.toString(16).padStart(4, '0');\n      return '02' + hex.slice(2, 4) + hex.slice(0, 2);\n    }\n    // Larger numbers...\n    const hex = n.toString(16).padStart(8, '0');\n    return '04' + hex.slice(6, 8) + hex.slice(4, 6) + hex.slice(2, 4) + hex.slice(0, 2);\n  }\n\n  // ==========================================================================\n  // Inscription Lookup\n  // ==========================================================================\n\n  async getInscription(inscriptionId: string): Promise<InscriptionInfo | null> {\n    // Check cache first\n    const cached = this.inscriptions.get(inscriptionId);\n    if (cached) return cached;\n\n    // Would fetch from API in real implementation\n    return null;\n  }\n\n  async getInscriptionContent(inscriptionId: string): Promise<Uint8Array | null> {\n    const info = await this.getInscription(inscriptionId);\n    return info?.content || null;\n  }\n\n  async getInscriptionsByAddress(address: string): Promise<InscriptionInfo[]> {\n    // Would fetch from API in real implementation\n    return [];\n  }\n\n  async getCollection(collectionId: string): Promise<CollectionInfo | null> {\n    // Would fetch from API in real implementation\n    return null;\n  }\n\n  // ==========================================================================\n  // Batch Operations\n  // ==========================================================================\n\n  async prepareBatchInscription(\n    envelopes: InscriptionEnvelope[],\n    destinationAddress: string,\n    feeRate: number = DEFAULT_FEE_RATE\n  ): Promise<BatchInscription> {\n    const batch: BatchInscription = {\n      id: generateBatchId(),\n      envelopes,\n      status: 'pending',\n      results: [],\n      totalFee: 0n,\n      createdAt: new Date(),\n    };\n\n    // Calculate total fees\n    for (const envelope of envelopes) {\n      const estimate = this.estimateFees(envelope, feeRate);\n      batch.totalFee += estimate.total;\n    }\n\n    return batch;\n  }\n\n  // ==========================================================================\n  // Utilities\n  // ==========================================================================\n\n  getExplorerUrl(inscriptionId: string): string {\n    switch (this.network) {\n      case 'bsv':\n        return `https://1satordinals.com/inscription/${inscriptionId}`;\n      case 'bitcoin':\n        return `https://ordinals.com/inscription/${inscriptionId}`;\n    }\n  }\n\n  getContentUrl(inscriptionId: string): string {\n    switch (this.network) {\n      case 'bsv':\n        return `https://1satordinals.com/content/${inscriptionId}`;\n      case 'bitcoin':\n        return `https://ordinals.com/content/${inscriptionId}`;\n    }\n  }\n\n  setNetwork(network: InscriptionNetwork): void {\n    this.network = network;\n    this.apiUrl = this.getDefaultApiUrl(network);\n  }\n\n  getNetwork(): InscriptionNetwork {\n    return this.network;\n  }\n}\n\n/** Prepared inscription */\nexport interface PreparedInscription {\n  id: string;\n  envelope: InscriptionEnvelope;\n  envelopeScript: string;\n  destinationAddress: string;\n  changeAddress: string;\n  feeEstimate: FeeEstimate;\n  status: InscriptionStatus;\n  createdAt: Date;\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\nexport function createInscriptionService(\n  network: InscriptionNetwork = 'bsv',\n  apiUrl?: string\n): InscriptionService {\n  return new InscriptionService(network, apiUrl);\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nfunction generateInscriptionId(): string {\n  return `pending_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n}\n\nfunction generateBatchId(): string {\n  return `batch_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n}\n\nfunction hexToBytes(hex: string): Uint8Array {\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);\n  }\n  return bytes;\n}\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nexport function getContentTypeFromExtension(filename: string): ContentType {\n  const ext = filename.split('.').pop()?.toLowerCase() || '';\n  return CONTENT_TYPE_MAP[ext] || 'application/octet-stream' as ContentType;\n}\n\nexport function getInscriptionType(contentType: ContentType): InscriptionType {\n  if (contentType.startsWith('image/')) return 'image';\n  if (contentType.startsWith('video/')) return 'video';\n  if (contentType.startsWith('audio/')) return 'audio';\n  if (contentType === 'text/html') return 'html';\n  if (contentType === 'text/plain') return 'text';\n  if (contentType === 'application/json') return 'json';\n  if (contentType === 'application/pdf') return 'document';\n  if (contentType === 'model/gltf-binary') return '3d';\n  if (contentType.includes('javascript') || contentType === 'text/css') return 'code';\n  return 'text';\n}\n\nexport function parseInscriptionId(inscriptionId: string): { txid: string; index: number } | null {\n  const parts = inscriptionId.split('i');\n  if (parts.length !== 2) return null;\n\n  const txid = parts[0];\n  const index = parseInt(parts[1], 10);\n\n  if (txid.length !== 64 || isNaN(index)) return null;\n\n  return { txid, index };\n}\n\nexport function formatInscriptionId(txid: string, index: number): string {\n  return `${txid}i${index}`;\n}\n\nexport function formatSatpoint(txid: string, vout: number, offset: number = 0): string {\n  return `${txid}:${vout}:${offset}`;\n}\n\nexport function parseSatpoint(satpoint: string): { txid: string; vout: number; offset: number } | null {\n  const parts = satpoint.split(':');\n  if (parts.length < 2) return null;\n\n  const txid = parts[0];\n  const vout = parseInt(parts[1], 10);\n  const offset = parts[2] ? parseInt(parts[2], 10) : 0;\n\n  if (txid.length !== 64 || isNaN(vout)) return null;\n\n  return { txid, vout, offset };\n}\n\nexport function calculateContentHash(content: Uint8Array): string {\n  // Placeholder - would use actual SHA256 in real implementation\n  let hash = 0n;\n  for (const byte of content) {\n    hash = (hash * 31n + BigInt(byte)) % (2n ** 256n);\n  }\n  return hash.toString(16).padStart(64, '0');\n}\n\nexport function formatFileSize(bytes: number): string {\n  if (bytes >= 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;\n  if (bytes >= 1024) return `${(bytes / 1024).toFixed(2)} KB`;\n  return `${bytes} B`;\n}\n\nexport function isValidInscriptionContent(content: Uint8Array): { valid: boolean; error?: string } {\n  if (content.length === 0) {\n    return { valid: false, error: 'Content cannot be empty' };\n  }\n\n  if (content.length > MAX_CONTENT_SIZE) {\n    return {\n      valid: false,\n      error: `Content exceeds maximum size of ${formatFileSize(MAX_CONTENT_SIZE)}`,\n    };\n  }\n\n  return { valid: true };\n}\n"],"mappings":"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","names":["hex"]}