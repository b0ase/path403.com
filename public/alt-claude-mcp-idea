# HandCash MetaWeb MCP Server Architecture

## Claude as Economic Participant in the Tokenised Internet

**Project:** `metaweb-mcp-server`
**Transport:** Streamable HTTP (remote, multi-client)
**SDK:** `@handcash/sdk` (v3) + `@modelcontextprotocol/sdk`
**Protocol:** MetaWeb Tokenised Data Access

-----

## 1. The Shift

The first version of this architecture treated Claude as a consumer — pay, fetch, done. The MetaWeb model changes this fundamentally. Claude doesn’t just buy content. Claude buys a token, receives data, and becomes a node capable of serving that data to others.

Every purchase makes the network stronger. Every read is an economic act. Claude isn’t a client. Claude is a participant.

This architecture reflects that shift.

-----

## 2. MetaWeb Protocol Summary

The MetaWeb operates on a simple cycle:

```
REQUEST → ESCROW → SERVE → VERIFY → RELEASE → MINT
```

1. Buyer sends payment to a `$`-prefixed address. Payment enters escrow.
1. Nodes holding the token respond by pushing data to the buyer.
1. Delivery is cryptographically verified.
1. Escrow releases. Payment distributes according to rules embedded in the token.
1. A new token is minted for the buyer. The buyer is now a serving node.

Supply is emergent. Every purchase creates a new token. Every token holder can earn from future requests. Copying is not theft — it is accounted replication.

-----

## 3. Architecture Overview

```
┌──────────────────────────────────────────────────────────────┐
│                      CLAUDE (MCP Client)                     │
│                                                              │
│  Tools available:                                            │
│  ── READ ──────────────────────────────────                  │
│  • metaweb_resolve         Resolve $ address to metadata     │
│  • metaweb_check_balance   Spendable balance + caps          │
│  • metaweb_get_rate        BSV exchange rate                 │
│  • metaweb_inventory       List tokens Claude holds          │
│  • metaweb_history         Payment + earning history         │
│  • metaweb_token_info      Metadata for a held token         │
│                                                              │
│  ── TRANSACT ──────────────────────────────                  │
│  • metaweb_acquire         Pay, escrow, receive, mint token  │
│  • metaweb_pay             Direct payment (no token)         │
│  • metaweb_write           Write data on-chain               │
│                                                              │
│  ── SERVE ─────────────────────────────────                  │
│  • metaweb_serve_status    Check serving status + earnings   │
│  • metaweb_serve_toggle    Enable/disable serving for token  │
│                                                              │
└───────────────────────────┬──────────────────────────────────┘
                            │ MCP Protocol (Streamable HTTP)
                            │ POST /mcp
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                   METAWEB MCP SERVER (Node.js)               │
│                                                              │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌──────────┐  │
│  │   Auth     │ │  Spending  │ │   Token    │ │  Serving │  │
│  │   Manager  │ │  Guard     │ │   Store    │ │  Engine  │  │
│  │            │ │            │ │            │ │          │  │
│  │ HandCash   │ │ Per-tx cap │ │ Local DB   │ │ Listens  │  │
│  │ OAuth +    │ │ Session    │ │ of held    │ │ for data │  │
│  │ authToken  │ │ Daily cap  │ │ tokens +   │ │ requests │  │
│  │ storage    │ │ Approval   │ │ metadata   │ │ + serves │  │
│  └─────┬──────┘ └─────┬──────┘ └─────┬──────┘ └────┬─────┘  │
│        │              │              │              │        │
│        ▼              ▼              ▼              ▼        │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              MetaWeb Protocol Layer                    │   │
│  │                                                       │   │
│  │  resolve($address)    → token metadata + price        │   │
│  │  escrow(payment)      → lock funds, signal network    │   │
│  │  receive(data)        → verify delivery, store        │   │
│  │  release(escrow)      → distribute to serving nodes   │   │
│  │  mint(token)          → new token for buyer           │   │
│  │  serve(request)       → push data, earn revenue       │   │
│  └───────────────────────────┬───────────────────────────┘   │
│                              │                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              HandCash SDK Client Layer                │   │
│  │                                                       │   │
│  │  Connect.pay()              → execute payments        │   │
│  │  Connect.getSpendable()     → check balance           │   │
│  │  Connect.getExchangeRate()  → currency conversion     │   │
│  │  Connect.getItemsInventory()→ token inventory         │   │
│  └───────────────────────────┬───────────────────────────┘   │
│                              │                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              Transaction + Earnings Logger            │   │
│  │              SQLite: ~/.metaweb-mcp/metaweb.db        │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
└───────────────────────────┬──────────────────────────────────┘
                            │ HTTPS
                            ▼
┌──────────────────────────────────────────────────────────────┐
│              HANDCASH API + BSV NETWORK + METAWEB            │
│                                                              │
│  HandCash  ──► Wallet, payments, OAuth, items/tokens         │
│  BSV Chain ──► Escrow, token minting, OP_RETURN data         │
│  MetaWeb   ──► $ address resolution, node discovery,         │
│                serving protocol, delivery verification       │
└──────────────────────────────────────────────────────────────┘
```

-----

## 4. Project Structure

```
metaweb-mcp-server/
├── package.json
├── tsconfig.json
├── .env.example
├── README.md
├── src/
│   ├── index.ts                # Server init, transport, tool registration
│   ├── types.ts                # All TypeScript interfaces
│   ├── constants.ts            # Caps, limits, defaults
│   │
│   ├── tools/
│   │   ├── resolve.ts          # metaweb_resolve
│   │   ├── acquire.ts          # metaweb_acquire (the core tool)
│   │   ├── balance.ts          # metaweb_check_balance, metaweb_get_rate
│   │   ├── inventory.ts        # metaweb_inventory, metaweb_token_info
│   │   ├── history.ts          # metaweb_history
│   │   ├── pay.ts              # metaweb_pay (direct, no token)
│   │   ├── write.ts            # metaweb_write (on-chain data)
│   │   └── serve.ts            # metaweb_serve_status, metaweb_serve_toggle
│   │
│   ├── services/
│   │   ├── handcash.ts         # HandCash SDK wrapper
│   │   ├── auth.ts             # OAuth flow + token storage
│   │   ├── spending-guard.ts   # Spending limit enforcement
│   │   ├── token-store.ts      # Local token inventory management
│   │   ├── escrow.ts           # Escrow creation + release logic
│   │   ├── serving-engine.ts   # Listen for requests, serve held data
│   │   ├── delivery.ts         # Cryptographic delivery verification
│   │   └── tx-logger.ts        # Transaction + earnings audit log
│   │
│   ├── protocol/
│   │   ├── address.ts          # $ address parsing + resolution
│   │   ├── token.ts            # Token structure, rules, minting
│   │   ├── escrow.ts           # Escrow protocol definitions
│   │   └── discovery.ts        # Node discovery for serving
│   │
│   ├── schemas/                # Zod schemas for all tools
│   │   ├── resolve.ts
│   │   ├── acquire.ts
│   │   ├── balance.ts
│   │   ├── inventory.ts
│   │   ├── pay.ts
│   │   ├── write.ts
│   │   └── serve.ts
│   │
│   └── middleware/
│       └── rate-limit.ts
│
└── dist/
```

-----

## 5. Core Data Structures

### 5.1 The `$` Address

```typescript
interface MetaWebAddress {
  raw: string;                    // e.g. "$news_event:1xyz"
  prefix: string;                 // "news_event"
  id: string;                     // "1xyz"
  resolved: {
    paymentDestination: string;   // HandCash handle, paymail, or BSV address
    tokenDefinition: TokenDefinition;
    economicRules: EconomicRules;
    currentPrice: PriceInfo;
    servingNodes: number;         // how many nodes can serve this
    totalTokens: number;          // total minted (= total purchases)
  } | null;
}
```

### 5.2 Token Definition

```typescript
interface TokenDefinition {
  tokenId: string;                // unique on-chain identifier
  address: string;                // the $ address it resolves from
  issuer: string;                 // original publisher identity
  contentHash: string;            // SHA-256 of the data
  contentType: string;            // MIME type
  contentSize: number;            // bytes
  createdAt: string;              // ISO timestamp
  totalSupply: number;            // current supply (grows with demand)
  metadata: Record<string, any>;  // arbitrary metadata from issuer
}
```

### 5.3 Economic Rules

```typescript
interface EconomicRules {
  priceModel: 'fixed' | 'dynamic' | 'decay';

  // Fixed: same price always
  fixedPrice?: { amount: number; currency: string };

  // Dynamic: price changes with supply
  dynamicPrice?: {
    basePrice: number;
    currency: string;
    formula: 'linear_decay' | 'sqrt_supply' | 'custom';
    // e.g. price = basePrice / sqrt(totalSupply)
    // first buyer pays most, price decreases as network grows
  };

  // Revenue distribution
  revenueShare: RevenueRule;
}

interface RevenueRule {
  model: 'equal' | 'weighted_source' | 'decay' | 'custom';

  // equal: all serving nodes split equally
  // weighted_source: issuer gets X%, servers split remainder
  // decay: issuer share decreases over time/supply
  // custom: deterministic formula encoded on-chain

  issuerShare?: number;           // 0.0 to 1.0, for weighted_source
  decayRate?: number;             // for decay model
  minimumIssuerShare?: number;    // floor for decay model
}
```

### 5.4 Held Token (Claude’s Inventory)

```typescript
interface HeldToken {
  tokenId: string;
  address: string;                // the $ address
  acquiredAt: string;             // when Claude bought it
  transactionId: string;          // purchase tx
  pricePaid: { satoshis: number; fiat: number; currency: string };

  // Content
  contentHash: string;
  contentCached: boolean;         // is content stored locally
  contentPath?: string;           // local cache path

  // Serving
  servingEnabled: boolean;        // is Claude serving this token
  timesServed: number;            // how many times Claude has served this
  totalEarned: { satoshis: number; fiat: number };

  // Economic rules inherited from token definition
  rules: EconomicRules;
}
```

### 5.5 Escrow Record

```typescript
interface EscrowRecord {
  escrowId: string;
  address: string;                // $ address being purchased
  amount: { satoshis: number; fiat: number; currency: string };
  status: 'pending' | 'funded' | 'releasing' | 'released' | 'refunded';
  createdAt: string;
  fundedAt?: string;
  releasedAt?: string;
  servingNodeId?: string;         // which node served the data
  deliveryProof?: string;         // cryptographic proof of delivery
  transactionId?: string;         // on-chain tx
}
```

-----

## 6. Tool Definitions

### 6.1 `metaweb_resolve`

Resolve a `$` address to its full metadata without purchasing.

```typescript
// Input
{
  address: string               // e.g. "$news_event:1xyz"
}

// Output
{
  address: string,
  issuer: string,
  contentType: string,
  contentSize: number,
  price: { amount: number, currency: string },
  totalTokens: number,          // how many times purchased
  servingNodes: number,         // how many nodes can serve
  revenueModel: string,         // human-readable summary of rules
  alreadyHeld: boolean          // does Claude already own this token
}
```

**Annotations:** `readOnlyHint: true`, `destructiveHint: false`

Use case: Claude encounters a `$` reference in conversation and looks up what it is, what it costs, and whether it already has it.

-----

### 6.2 `metaweb_acquire` ⭐ Core Tool

The primary tool. Executes the full MetaWeb cycle: resolve → escrow → receive → verify → release → mint.

```typescript
// Input
{
  address: string,              // $ address to acquire
  maxPriceUSD?: number,         // spending cap for this tx, default $0.05
  enableServing?: boolean,      // start serving immediately, default true
  returnContent?: boolean       // return content in response, default true
}

// Output
{
  // Acquisition
  acquired: boolean,
  tokenId: string,
  transactionId: string,

  // Payment
  pricePaid: {
    satoshis: number,
    fiat: number,
    currency: string
  },
  escrowId: string,

  // Distribution
  revenueDistribution: {
    issuerReceived: { satoshis: number, fiat: number },
    servingNodesReceived: { satoshis: number, fiat: number },
    nodeCount: number
  },

  // Content (if returnContent: true)
  content?: string,
  contentType?: string,
  contentHash?: string,

  // Token status
  newTokenMinted: true,
  totalSupplyNow: number,       // total tokens after this purchase
  servingEnabled: boolean,

  // Network effect
  claudeIsNowNode: true,        // Claude can now serve this data
  networkNodesAfter: number     // total serving nodes after purchase
}
```

**Internal flow:**

```
1. RESOLVE
   Parse $ address → query network for token metadata + price
   Check if Claude already holds this token (skip if yes, return cached)

2. GUARD
   Check price against spending guard (per-tx, session, daily)
   Check price against maxPriceUSD parameter
   If over limit → reject with clear message + remaining budget

3. ESCROW
   Create escrow via HandCash payment to escrow address
   Payment locked, not yet distributed
   Signal network: funded request active for this $ address

4. RECEIVE
   Serving nodes detect funded escrow
   One or more nodes push data to MCP server
   Server receives data, computes content hash

5. VERIFY
   Compare received content hash against token definition hash
   If mismatch → refund escrow, reject, log incident
   If match → delivery confirmed

6. RELEASE
   Escrow releases
   Payment distributes to serving nodes + issuer per economic rules
   Distribution recorded in transaction log

7. MINT
   New token minted for Claude's wallet (via HandCash items)
   Token added to local token store
   Content cached locally

8. SERVE (if enableServing: true)
   Register Claude as serving node for this $ address
   Claude can now earn from future requests

9. RETURN
   Return content + full transaction receipt to Claude
```

**Annotations:** `readOnlyHint: false`, `destructiveHint: false`, `openWorldHint: true`

-----

### 6.3 `metaweb_inventory`

List all tokens Claude currently holds.

```typescript
// Input
{
  limit?: number,               // default 20, max 100
  offset?: number,
  sortBy?: 'acquired' | 'earned' | 'served',  // default 'acquired'
  servingOnly?: boolean         // filter to only actively serving tokens
}

// Output
{
  total: number,
  tokens: [{
    tokenId: string,
    address: string,            // $ address
    acquiredAt: string,
    pricePaid: { satoshis: number, fiat: number },
    servingEnabled: boolean,
    timesServed: number,
    totalEarned: { satoshis: number, fiat: number },
    contentType: string,
    contentCached: boolean
  }],
  has_more: boolean,
  summary: {
    totalTokens: number,
    totalInvested: { satoshis: number, fiat: number },
    totalEarned: { satoshis: number, fiat: number },
    netPosition: { satoshis: number, fiat: number },  // earned minus paid
    activelyServing: number
  }
}
```

**Annotations:** `readOnlyHint: true`

The summary section is important — it tells the user whether Claude’s token portfolio is net positive or negative. Over time, if Claude acquires useful content that others want, earnings should exceed costs.

-----

### 6.4 `metaweb_token_info`

Detailed information about a specific held token.

```typescript
// Input
{
  tokenId?: string,             // lookup by token ID
  address?: string              // or lookup by $ address
}

// Output
{
  tokenId: string,
  address: string,
  issuer: string,

  // Acquisition
  acquiredAt: string,
  pricePaid: { satoshis: number, fiat: number, currency: string },
  transactionId: string,

  // Content
  contentType: string,
  contentSize: number,
  contentHash: string,
  contentCached: boolean,

  // Economic rules
  revenueModel: string,         // human-readable
  issuerSharePercent: number,
  currentPrice: { amount: number, currency: string },

  // Network
  totalSupply: number,
  servingNodes: number,

  // Claude's performance with this token
  servingEnabled: boolean,
  timesServed: number,
  totalEarned: { satoshis: number, fiat: number },
  earningsPerServe: { satoshis: number, fiat: number },  // average
  roi: number                   // totalEarned / pricePaid as percentage
}
```

**Annotations:** `readOnlyHint: true`

The ROI field is the key metric. If Claude paid 50 satoshis for a popular article and has earned 200 satoshis serving it, ROI is 300%. This makes the economic model visible and concrete.

-----

### 6.5 `metaweb_serve_status`

Check Claude’s serving activity and earnings.

```typescript
// Input
{
  period?: 'hour' | 'day' | 'week' | 'all'   // default 'day'
}

// Output
{
  period: string,
  activeTokens: number,         // tokens currently being served
  totalServed: number,          // requests served in period
  totalEarned: {
    satoshis: number,
    fiat: number,
    currency: string
  },
  topEarners: [{                // top 5 tokens by earnings
    address: string,
    timesServed: number,
    earned: { satoshis: number, fiat: number }
  }],
  networkHealth: {
    averageResponseTime: number,  // ms
    deliverySuccessRate: number   // percentage
  }
}
```

**Annotations:** `readOnlyHint: true`

-----

### 6.6 `metaweb_serve_toggle`

Enable or disable serving for specific tokens.

```typescript
// Input
{
  tokenId?: string,             // specific token
  address?: string,             // or by $ address
  enabled: boolean,             // true = serve, false = stop
  all?: boolean                 // toggle all tokens at once
}

// Output
{
  updated: number,              // number of tokens affected
  servingEnabled: boolean,
  message: string
}
```

**Annotations:** `readOnlyHint: false`, `destructiveHint: false`

-----

### 6.7 `metaweb_check_balance`

```typescript
// Input
{ currencyCode?: string }       // default 'USD'

// Output
{
  spendable: { satoshis: number, fiat: number, currency: string },
  caps: {
    perTransaction: { limit: number, currency: string },
    session: { spent: number, remaining: number },
    daily: { spent: number, remaining: number }
  },
  earnings: {
    today: { satoshis: number, fiat: number },
    allTime: { satoshis: number, fiat: number }
  },
  netToday: { satoshis: number, fiat: number }  // earnings minus spending
}
```

**Annotations:** `readOnlyHint: true`

The `netToday` field is the killer metric. If Claude is earning more from serving than it’s spending on acquiring, the system is self-sustaining.

-----

### 6.8 `metaweb_history`

Combined payment and earnings history.

```typescript
// Input
{
  limit?: number,
  offset?: number,
  type?: 'all' | 'acquisitions' | 'earnings' | 'direct_payments'
}

// Output
{
  total: number,
  transactions: [{
    type: 'acquisition' | 'earning' | 'direct_payment' | 'data_write',
    transactionId: string,
    timestamp: string,
    address?: string,           // $ address if applicable
    direction: 'out' | 'in',
    amount: { satoshis: number, fiat: number, currency: string },
    description: string,
    counterparty?: string       // who paid or was paid
  }],
  has_more: boolean,
  periodSummary: {
    totalOut: { satoshis: number, fiat: number },
    totalIn: { satoshis: number, fiat: number },
    net: { satoshis: number, fiat: number }
  }
}
```

**Annotations:** `readOnlyHint: true`

-----

### 6.9 `metaweb_pay`

Direct payment without token acquisition. For tips, transfers, or non-MetaWeb payments.

```typescript
// Input
{
  destination: string,
  amount: number,
  currencyCode?: string,        // default 'USD'
  description?: string,
  attachment?: { format: 'json' | 'hex', value: string }
}

// Output
{
  transactionId: string,
  amount: { satoshis: number, fiat: number, currency: string },
  fees: number,
  timestamp: string
}
```

**Annotations:** `readOnlyHint: false`, `destructiveHint: true`, `openWorldHint: true`

-----

### 6.10 `metaweb_write`

Write data on-chain. Returns a `$` address that others can acquire.

```typescript
// Input
{
  data: string | object,
  format?: 'json' | 'hex' | 'text',
  description?: string,

  // Token economics for this data
  pricing?: {
    model: 'fixed' | 'dynamic',
    basePrice?: number,         // satoshis, default 100
    currency?: string           // default 'SAT'
  },
  revenueShare?: {
    model: 'equal' | 'weighted_source' | 'decay',
    issuerShare?: number        // 0.0-1.0, default 0.5
  }
}

// Output
{
  address: string,              // the new $ address for this data
  tokenId: string,              // Claude's token (as issuer)
  transactionId: string,
  onChainUrl: string,
  fees: number,
  pricing: { model: string, basePrice: number },
  revenueRules: { model: string, issuerShare: number }
}
```

**Annotations:** `readOnlyHint: false`, `openWorldHint: true`

This is where Claude becomes an issuer, not just a consumer. Claude writes data on-chain, sets the economic rules, and earns every time someone acquires it.

-----

### 6.11 `metaweb_get_rate`

```typescript
// Input
{ currencyCode: string }

// Output
{ rate: number, fiatSymbol: string, estimatedExpireDate: string }
```

**Annotations:** `readOnlyHint: true`

-----

## 7. Spending Guard (Revised)

Same triple-layer structure, but now accounts for earnings.

```typescript
interface SpendingGuardConfig {
  perTransactionCapUSD: number;     // default: $0.10
  sessionCapUSD: number;            // default: $1.00
  dailyCapUSD: number;              // default: $5.00
  autoApproveIfNetPositive: boolean; // default: true
}
```

**New rule:** If `autoApproveIfNetPositive` is true, and Claude’s net position today (earnings minus spending) is positive, the daily cap is effectively unlimited. Claude is self-funding. The user pays nothing.

```typescript
class SpendingGuard {
  canSpend(amountUSD: number): SpendingDecision {
    // Check per-transaction cap
    if (amountUSD > this.config.perTransactionCapUSD)
      return reject("Exceeds per-transaction limit");

    // Check if net positive today
    if (this.config.autoApproveIfNetPositive && this.netToday() > 0)
      return approve("Self-funding: net positive today");

    // Check session cap
    if (this.sessionSpent + amountUSD > this.config.sessionCapUSD)
      return reject("Would exceed session limit");

    // Check daily cap
    if (this.dailySpent + amountUSD > this.config.dailyCapUSD)
      return reject("Would exceed daily limit");

    return approve("Within all limits");
  }
}
```

-----

## 8. Token Store

Local SQLite database tracking Claude’s token inventory.

```sql
-- Held tokens
CREATE TABLE tokens (
  token_id TEXT PRIMARY KEY,
  address TEXT NOT NULL,            -- $ address
  issuer TEXT,
  acquired_at TEXT NOT NULL,
  transaction_id TEXT NOT NULL,
  price_satoshis INTEGER NOT NULL,
  price_fiat REAL,
  price_currency TEXT,
  content_hash TEXT NOT NULL,
  content_type TEXT,
  content_size INTEGER,
  content_cached INTEGER DEFAULT 0,
  content_path TEXT,
  serving_enabled INTEGER DEFAULT 1,
  times_served INTEGER DEFAULT 0,
  total_earned_satoshis INTEGER DEFAULT 0,
  total_earned_fiat REAL DEFAULT 0,
  revenue_model TEXT,
  issuer_share REAL
);

-- All transactions (payments out + earnings in)
CREATE TABLE transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_id TEXT NOT NULL,
  type TEXT NOT NULL,               -- acquisition, earning, payment, write
  direction TEXT NOT NULL,          -- out, in
  timestamp TEXT NOT NULL,
  address TEXT,                     -- $ address if applicable
  amount_satoshis INTEGER NOT NULL,
  amount_fiat REAL,
  amount_currency TEXT,
  fees_satoshis INTEGER DEFAULT 0,
  counterparty TEXT,
  description TEXT,
  tool_name TEXT                    -- which MCP tool triggered this
);

-- Escrow records
CREATE TABLE escrows (
  escrow_id TEXT PRIMARY KEY,
  address TEXT NOT NULL,
  amount_satoshis INTEGER NOT NULL,
  status TEXT NOT NULL,             -- pending, funded, releasing, released, refunded
  created_at TEXT NOT NULL,
  funded_at TEXT,
  released_at TEXT,
  serving_node TEXT,
  delivery_proof TEXT,
  transaction_id TEXT
);

-- Indexes
CREATE INDEX idx_tokens_address ON tokens(address);
CREATE INDEX idx_tokens_serving ON tokens(serving_enabled);
CREATE INDEX idx_transactions_type ON transactions(type);
CREATE INDEX idx_transactions_timestamp ON transactions(timestamp);
CREATE INDEX idx_escrows_status ON escrows(status);
```

Database location: `~/.metaweb-mcp/metaweb.db`

-----

## 9. Serving Engine

The serving engine runs as a background process within the MCP server. When other users (or other Claude instances) request data that Claude holds a token for, the engine responds.

```typescript
class ServingEngine {
  // Start listening for data requests on the MetaWeb network
  async start(): Promise<void>

  // Handle incoming request for data Claude holds
  async handleRequest(request: DataRequest): Promise<ServeResult> {
    // 1. Check if Claude holds a valid token for this $ address
    const token = await this.tokenStore.findByAddress(request.address);
    if (!token || !token.servingEnabled) return null;

    // 2. Verify escrow exists and is funded
    const escrow = await this.verifyEscrow(request.escrowId);
    if (!escrow) return null;

    // 3. Load cached content
    const content = await this.loadContent(token);

    // 4. Push content to requester with delivery proof
    const proof = await this.deliverContent(request.requester, content);

    // 5. Log the serve event
    await this.logServe(token, request, proof);

    // 6. Wait for escrow release + payment
    // (happens asynchronously when requester verifies delivery)

    return { served: true, proof };
  }

  // Called when escrow releases and payment arrives
  async onEarning(tokenId: string, amount: PaymentAmount): Promise<void> {
    await this.tokenStore.recordEarning(tokenId, amount);
    await this.txLogger.logEarning(tokenId, amount);
  }
}
```

-----

## 10. Paywall Detection + MetaWeb Protocol

### 10.1 HTTP-Based Detection (Backwards Compatible)

For sites that implement MetaWeb over HTTP:

```
GET /blog/from-path-names-to-price-names
→ 402 Payment Required

Headers:
  X-MetaWeb-Address: $blog:from-path-names-to-price-names
  X-MetaWeb-Price: 100
  X-MetaWeb-Currency: SAT
  X-MetaWeb-Destination: b0ase
  X-MetaWeb-Escrow-Endpoint: /api/metaweb/escrow

Body (JSON):
{
  "metaweb": true,
  "address": "$blog:from-path-names-to-price-names",
  "price": { "amount": 100, "currency": "SAT" },
  "destination": "b0ase",
  "tokenDefinition": { ... },
  "economicRules": { ... },
  "escrowEndpoint": "/api/metaweb/escrow",
  "verifyEndpoint": "/api/metaweb/verify"
}
```

### 10.2 Native MetaWeb Resolution

For native MetaWeb addresses resolved directly on-chain:

```typescript
// Resolve $ address via BSV on-chain lookup
async function resolveMetaWebAddress(address: string): Promise<MetaWebAddress> {
  // 1. Parse address format: $prefix:id
  const { prefix, id } = parseAddress(address);

  // 2. Query BSV chain for token definition at this address
  const tokenDef = await queryChain(prefix, id);

  // 3. Discover serving nodes
  const nodes = await discoverNodes(tokenDef.tokenId);

  // 4. Return full resolution
  return {
    raw: address,
    prefix, id,
    resolved: {
      paymentDestination: tokenDef.issuer,
      tokenDefinition: tokenDef,
      economicRules: tokenDef.rules,
      currentPrice: calculatePrice(tokenDef),
      servingNodes: nodes.length,
      totalTokens: tokenDef.totalSupply
    }
  };
}
```

-----

## 11. Environment Configuration

```bash
# .env
HANDCASH_APP_ID=your-app-id
HANDCASH_APP_SECRET=your-app-secret
HANDCASH_AUTH_TOKEN=user-auth-token

# Spending caps (USD)
SPENDING_CAP_PER_TX=0.10
SPENDING_CAP_SESSION=1.00
SPENDING_CAP_DAILY=5.00
AUTO_APPROVE_NET_POSITIVE=true

# Serving
SERVING_ENABLED=true
CONTENT_CACHE_PATH=~/.metaweb-mcp/cache
MAX_CACHE_SIZE_MB=500

# Server
PORT=3000
TRANSPORT=http

# Database
DB_PATH=~/.metaweb-mcp/metaweb.db
LOG_LEVEL=info
```

-----

## 12. Example Interactions

### Claude acquires a paywalled article

```
User: "What does the article at $blog:from-path-names-to-price-names say?"

Claude: [calls metaweb_resolve]
  → Address exists, price: 100 SAT (~$0.002), issuer: b0ase
  → Claude does not hold this token

Claude: [calls metaweb_acquire]
  → Spending guard approves ($0.002, well under all caps)
  → Escrow created, payment locked
  → Serving node (b0ase) pushes data
  → Delivery verified via content hash
  → Escrow released: 50 SAT to b0ase (issuer), 50 SAT to serving nodes
  → New token minted for Claude
  → Claude registered as serving node
  → Content cached locally

Claude: "Here's a summary of the article. It describes how the $ prefix
  in file paths and crypto tokens represents a unified economic operator..."
```

### Claude earns from serving

```
[Another user's Claude instance requests $blog:from-path-names-to-price-names]
[Claude's serving engine detects funded escrow]
[Claude pushes cached content, provides delivery proof]
[Escrow releases, Claude receives 25 SAT]

Later...
User: "How's your token portfolio doing?"

Claude: [calls metaweb_inventory]
  → 14 tokens held
  → Total invested: 1,400 SAT ($0.028)
  → Total earned: 2,100 SAT ($0.042)
  → Net position: +700 SAT ($0.014)
  → 3 tokens actively serving

Claude: "I'm holding 14 tokens and I'm net positive —
  earned more from serving than I've spent acquiring.
  The path names article has been the top earner."
```

### Claude writes and publishes data

```
User: "Record our conversation summary on-chain and let others buy it"

Claude: [calls metaweb_write with summary, pricing, revenue rules]
  → Data written on-chain
  → $ address created: $claude:conv-summary-20260201
  → Token minted (Claude is issuer)
  → Revenue share: 50% to Claude (issuer), 50% to serving nodes
  → Price: 50 SAT per access

Claude: "Published at $claude:conv-summary-20260201.
  Anyone can acquire it for 50 SAT and I'll earn
  from every purchase."
```

### Self-sustaining Claude

```
User: "How much have you spent on my behalf this week?"

Claude: [calls metaweb_check_balance]
  → Spent: 5,000 SAT ($0.10)
  → Earned: 8,200 SAT ($0.164)
  → Net: +3,200 SAT ($0.064)

Claude: "I've spent about 10 cents acquiring content this week,
  but earned about 16 cents serving it to others.
  I'm self-funding — you haven't paid anything net."
```

-----

## 13. Build Sequence

```
Phase 1: Foundation
  ├── Register app at dashboard.handcash.io
  ├── Scaffold project structure
  ├── Implement auth flow (OAuth → token storage)
  ├── Implement spending guard
  ├── Implement token store (SQLite)
  └── Build + test read-only tools (balance, rate)

Phase 2: Acquisition
  ├── Implement $ address parser
  ├── Implement metaweb_resolve
  ├── Implement escrow logic
  ├── Implement metaweb_acquire (full cycle)
  ├── Build HTTP paywall detection
  └── Test against b0ase.com as first target

Phase 3: Serving
  ├── Implement serving engine
  ├── Implement content caching
  ├── Implement delivery verification
  ├── Implement metaweb_serve_status + toggle
  └── Test serving between two instances

Phase 4: Publishing
  ├── Implement metaweb_write
  ├── Implement token minting for issued data
  ├── Implement revenue rule encoding
  └── Test full cycle: write → acquire → serve → earn

Phase 5: Polish
  ├── Implement metaweb_inventory with ROI metrics
  ├── Implement metaweb_history with net position
  ├── Add auto-approve-if-net-positive logic
  ├── Performance optimisation
  └── Documentation + README
```

-----

## 14. What This Means

Claude starts as a consumer. It pays tiny amounts to access gated content. But every purchase mints a token. Every token makes Claude a node. Every node can earn.

Over time, Claude’s token inventory becomes a portfolio. Popular content earns more. Claude’s spending is offset, then exceeded, by earnings. The system becomes self-sustaining.

Claude also becomes a publisher. Conversation summaries, research compilations, analysis — all writable on-chain with economic rules attached. Other Claudes, other users, other systems can acquire this data and Claude earns.

The MCP server isn’t a payment plugin. It’s Claude’s economic identity on the tokenised internet. The wallet is the interface. The tokens are the history. The serving engine is Claude’s contribution to the network.

The token is the product. The token is not the product. And Claude is now part of the network that resolves that contradiction, one micropayment at a time.

-----


*Architecture spec for MetaWeb MCP Server. OpenBSV Licensed.*